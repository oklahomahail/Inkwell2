// src/test/runBenchmarks.ts /* eslint-env node */ import * as fs from 'node:fs'; import { runQuickBenchmark, runFullBenchmark, runStressBenchmark, type BenchmarkResult, } from './searchBenchmarkHarness'; // Node-only (OK in tests/CI). We avoid `require()` per eslint rule. /* ---------- helpers ---------- */ const isNode = typeof process !== 'undefined' && typeof process.versions !== 'undefined' && !!process.versions.node; const mb = (_bytes: number) => (bytes > 0 ? (bytes / 1024 / 1024).toFixed(1) : '0.0'); /* ---------- Quick benchmark for development ---------- */ export async function _validateSearchPerformance(): Promise<void> { console.log('Starting search performance validation...\n'); try { const result = await runQuickBenchmark(); console.log('=== BENCHMARK RESULTS ==='); console.log(`Status: ${result.passed ? 'PASS ✅' : 'FAIL ❌'}`); console.log( `\nCorpus: ${result.corpus.totalWords.toLocaleString()} words, ${result.corpus.totalScenes} scenes, ${result.corpus.characters} characters`, ); console.log( `Index: ${mb(result.indexBuild.sizeBytes)}MB, built in ${result.indexBuild.timeMs}ms`, ); console.log(`\nQuery Performance:`); console.log(` P50: ${result.queryPerformance.p50.toFixed(1)}ms (target: ≤50ms)`); console.log(` P95: ${result.queryPerformance.p95.toFixed(1)}ms (target: ≤120ms)`); console.log(` P99: ${result.queryPerformance.p99.toFixed(1)}ms`); console.log(` Failure rate: ${(result.queryPerformance.failureRate * 100).toFixed(1)}%`); console.log( ` Average results per query: ${result.queryPerformance.averageResultCount.toFixed(1)}`, ); if (result.memoryUsage.deltaMB > 0) { console.log(`\nMemory: +${result.memoryUsage.deltaMB.toFixed(1)}MB`); } console.log(`\nPerformance by Query Type:`); Object.entries(result.detailsByQueryType).forEach(([type,  stats]) => { console.log( ` ${type}: ${stats.count} queries, P50=${stats.p50.toFixed(1)}ms, P95=${stats.p95.toFixed( 1, )}ms`, ); }); if (result.suggestions.length > 0) { console.log(`\nSuggestions:`); result.suggestions.forEach((s) => { console.log(` • ${s}`); }); } } catch (error) { console.error('Benchmark failed:', error); throw error; } } /* ---------- Comprehensive benchmark for CI/CD ---------- */ export async function _runCiBenchmarks(): Promise<boolean> { console.log('Running CI benchmarks...\n'); const results: BenchmarkResult[] = []; try { console.log('1/2: Running full benchmark...'); const fullResult = await runFullBenchmark(); results.push(fullResult); console.log( `Full benchmark: ${fullResult.passed ? 'PASS' : 'FAIL'} (P50: ${fullResult.queryPerformance.p50.toFixed( 1, )}ms, P95: ${fullResult.queryPerformance.p95.toFixed(1)}ms)\n`, ); console.log('2/2: Running stress benchmark...'); const stressResult = await runStressBenchmark(); results.push(stressResult); console.log( `Stress benchmark: ${stressResult.passed ? 'PASS' : 'FAIL'} (P50: ${stressResult.queryPerformance.p50.toFixed( 1, )}ms, P95: ${stressResult.queryPerformance.p95.toFixed(1)}ms)\n`, ); const allPassed = results.every((r) => r.passed); console.log('=== CI BENCHMARK SUMMARY ==='); console.log(`Overall Status: ${allPassed ? 'PASS ✅' : 'FAIL ❌'}`); if (!allPassed) { console.log('\nFailures:'); results.forEach((r, _index) => { if (!r.passed) { const benchmarkName = index === 0 ? 'Full' : 'Stress'; console.log(`\n${benchmarkName} Benchmark Issues:`); r.suggestions.forEach((s) => { console.log(` • ${s}`); }); } }); } return allPassed; } catch (error) { console.error('CI benchmarks failed:', error); return false; } } /* ---------- Performance regression checker ---------- */ export async function _checkPerformanceRegression(baselineResults?: BenchmarkResult): Promise<void> { console.log('Checking for performance regressions...\n'); const currentResult = await runFullBenchmark(); if (!baselineResults) { console.log('No baseline provided. Current performance:'); console.log(` P50: ${currentResult.queryPerformance.p50.toFixed(1)}ms`); console.log(` P95: ${currentResult.queryPerformance.p95.toFixed(1)}ms`); console.log(` Index build: ${currentResult.indexBuild.timeMs}ms`); console.log(` Index size: ${mb(currentResult.indexBuild.sizeBytes)}MB`); return; } const regressions: string[] = []; const improvements: string[] = []; const pct = (_delta: number, _base: number) => (base === 0 ? 0 : delta / base); // P50 { const change = pct( currentResult.queryPerformance.p50 - baselineResults.queryPerformance.p50, baselineResults.queryPerformance.p50, ); if (change > 0.1) { regressions.push( `P50 latency regressed by ${(change * 100).toFixed(1)}% (${baselineResults.queryPerformance.p50.toFixed( 1, )}ms → ${currentResult.queryPerformance.p50.toFixed(1)}ms)`, ); } else if (change < -0.1) { improvements.push( `P50 latency improved by ${Math.abs(change * 100).toFixed(1)}% (${baselineResults.queryPerformance.p50.toFixed( 1, )}ms → ${currentResult.queryPerformance.p50.toFixed(1)}ms)`, ); } } // P95 { const change = pct( currentResult.queryPerformance.p95 - baselineResults.queryPerformance.p95, baselineResults.queryPerformance.p95, ); if (change > 0.1) { regressions.push( `P95 latency regressed by ${(change * 100).toFixed(1)}% (${baselineResults.queryPerformance.p95.toFixed( 1, )}ms → ${currentResult.queryPerformance.p95.toFixed(1)}ms)`, ); } else if (change < -0.1) { improvements.push( `P95 latency improved by ${Math.abs(change * 100).toFixed(1)}% (${baselineResults.queryPerformance.p95.toFixed( 1, )}ms → ${currentResult.queryPerformance.p95.toFixed(1)}ms)`, ); } } // Index build time { const change = pct( currentResult.indexBuild.timeMs - baselineResults.indexBuild.timeMs, baselineResults.indexBuild.timeMs, ); if (change > 0.2) { regressions.push( `Index build time regressed by ${(change * 100).toFixed(1)}% (${baselineResults.indexBuild.timeMs}ms → ${currentResult.indexBuild.timeMs}ms)`, ); } } // Index size { const change = pct( currentResult.indexBuild.sizeBytes - baselineResults.indexBuild.sizeBytes, baselineResults.indexBuild.sizeBytes, ); if (change > 0.2) { regressions.push( `Index size grew by ${(change * 100).toFixed(1)}% (${mb( baselineResults.indexBuild.sizeBytes, )}MB → ${mb(currentResult.indexBuild.sizeBytes)}MB)`, ); } } console.log('=== REGRESSION CHECK ==='); if (regressions.length > 0) { console.log('❌ Performance regressions detected:'); regressions.forEach((r) => { console.log(` • ${r}`); }); } if (improvements.length > 0) { console.log('✅ Performance improvements:'); improvements.forEach((i) => { console.log(` • ${i}`); }); } if (regressions.length === 0 && improvements.length === 0) { console.log('✅ No significant performance changes detected'); } if (regressions.length > 0) { throw new Error(`Performance regressions detected: ${regressions.length} issues found`); } } /* ---------- Baseline save/load (Node only; safe no-ops in browser) ---------- */ export function _saveBaselineResults( result: BenchmarkResult, filePath: string = './benchmark-baseline.json', ): void { if (!isNode) { console.log('Baseline saving not supported in browser environment'); return; } try { fs.writeFileSync(filePath, JSON.stringify(result, null, 2), 'utf8'); console.log(`Baseline results saved to ${filePath}`); } catch (error) { console.error('Failed to save baseline results:', error); } } export function _loadBaselineResults( filePath: string = './benchmark-baseline.json', ): BenchmarkResult | null { if (!isNode) return null; try { if (!fs.existsSync(filePath)) return null; const raw = fs.readFileSync(filePath, 'utf8'); return JSON.parse(raw) as BenchmarkResult; } catch (error) { console.warn('Could not load baseline results:', error); return null; } }
