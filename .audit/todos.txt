/Users/davehail/Developer/inkwell/PR24_STATUS_SUMMARY.md:54:- [x] TODO v0.7.0 markers throughout code
/Users/davehail/Developer/inkwell/PR24_STATUS_SUMMARY.md:88:- [ ] Full cleanup of TODO v0.7.0 markers
/Users/davehail/Developer/inkwell/PR24_STATUS_SUMMARY.md:218:- [ ] Verify TODO v0.7.0 markers are appropriate
/Users/davehail/Developer/inkwell/PR24_STATUS_SUMMARY.md:398:- **Primary Reviewer:** [TBD]
/Users/davehail/Developer/inkwell/PR24_STATUS_SUMMARY.md:404:- **QA Engineer:** [TBD]
/Users/davehail/Developer/inkwell/USER_PERSISTENCE_SUMMARY.md:94:- Encryption settings (placeholder)
/Users/davehail/Developer/inkwell/TOUR_GUARDRAILS_COMPLETE.md:177:8. **`docs/PR_TEMPLATE_TOUR_CHECKLIST.md`** - PR template additions
/Users/davehail/Developer/inkwell/TOUR_GUARDRAILS_COMPLETE.md:264:- See `docs/PR_TEMPLATE_TOUR_CHECKLIST.md` for PR guidelines
/Users/davehail/Developer/inkwell/vite.config.ts:53:            '@tiptap/extension-placeholder',
/Users/davehail/Developer/inkwell/SPOTLIGHT_TOUR_PHASE2_COMPLETE.md:30:   - Subscribes to TourService (placeholder for integration)
/Users/davehail/Developer/inkwell/SPOTLIGHT_TOUR_PHASE2_COMPLETE.md:151:⏳ **TourService subscription** (placeholder in useSpotlightUI)  
/Users/davehail/Developer/inkwell/SPOTLIGHT_TOUR_PHASE2_COMPLETE.md:244:1. **Connect TourService**: Replace placeholder subscriptions in `useSpotlightUI.ts`
/Users/davehail/Developer/inkwell/docs/engineering/TEAM_ANNOUNCEMENT.md:124:Run `pnpm typecheck` to see all errors. Use `@ts-expect-error` as a last resort with a TODO comment.
/Users/davehail/Developer/inkwell/docs/engineering/WORKFLOW_QUICK_REFERENCE.md:79:// @ts-expect-error - TODO: Fix after library upgrade
/Users/davehail/Developer/inkwell/TYPE_CONSOLIDATION_STATUS.md:25:- **DONE**: Marked Scene as @deprecated in writing.ts
/Users/davehail/Developer/inkwell/scripts/delete-redundant-docs.sh:74:git rm -f docs/PR_TEMPLATE_TOUR_CHECKLIST.md 2>/dev/null || true
/Users/davehail/Developer/inkwell/scripts/delete-redundant-docs.sh:94:git rm -f FEEDBACK_TEMPLATE.md 2>/dev/null || true
/Users/davehail/Developer/inkwell/docs/engineering/linting-and-ci-playbook.md:356:- WIP commit to temporary branch
/Users/davehail/Developer/inkwell/src/editor/__tests__/EnhancedChapterEditor.test.tsx:192:  it('should show placeholder when empty', () => {
/Users/davehail/Developer/inkwell/src/editor/__tests__/EnhancedChapterEditor.test.tsx:196:    expect(textarea).toHaveAttribute('placeholder', 'Start writing your chapter...');
/Users/davehail/Developer/inkwell/src/editor/EnhancedChapterEditor.tsx:86:  // TODO: Wire TipTap editor here
/Users/davehail/Developer/inkwell/src/editor/EnhancedChapterEditor.tsx:87:  // For now, use a simple textarea as placeholder
/Users/davehail/Developer/inkwell/src/editor/EnhancedChapterEditor.tsx:98:        placeholder="Start writing your chapter..."
/Users/davehail/Developer/inkwell/ARCHIVE_ACTIVATION_SUMMARY.md:226:The TODOs in `NavContext.tsx` (lines 276, 299) are in **helper utilities** (`NavigationHelpers.navigateToSceneWithFallback`, etc.), not in core navigation methods. These helpers already have:
/Users/davehail/Developer/inkwell/ARCHIVE_ACTIVATION_SUMMARY.md:234:**No changes needed** - The validation TODOs are placeholders for future storage integration, not critical safety issues. The helpers already safely handle bad IDs by falling back to parent routes.
/Users/davehail/Developer/inkwell/scripts/verify-tour-implementation.sh:23:EXPORT_TEMPLATE=$(grep -r "data-tour-id=\"export-template\"" src/ | wc -l | tr -d ' ')
/Users/davehail/Developer/inkwell/scripts/verify-tour-implementation.sh:32:echo "   • export-template: $([[ $EXPORT_TEMPLATE -gt 0 ]] && echo '✅' || echo '❌') ($EXPORT_TEMPLATE found)"
/Users/davehail/Developer/inkwell/scripts/verify-tour-implementation.sh:57:[[ $EXPORT_TEMPLATE -gt 0 ]] && ((TOTAL++))
/Users/davehail/Developer/inkwell/CONSOLIDATION_PROGRESS.md:176:- [ ] Move scene-based components with @deprecated
/Users/davehail/Developer/inkwell/CONSOLIDATION_PROGRESS.md:185:│       ├── SceneEditor.tsx (@deprecated)
/Users/davehail/Developer/inkwell/CONSOLIDATION_PROGRESS.md:186:│       ├── SceneList.tsx (@deprecated)
/Users/davehail/Developer/inkwell/CONSOLIDATION_PROGRESS.md:187:│       ├── SceneHeader.tsx (@deprecated)
/Users/davehail/Developer/inkwell/eslint-report.json:210:    "source": "import React, { useEffect, useState } from 'react';\n\nimport { supabase } from '@/lib/supabaseClient';\nimport { useGo } from '@/utils/navigate';\nimport { normalizeSafeRedirect } from '@/utils/safeRedirect';\n\nexport type AuthFormMode = 'signin' | 'signup';\n\n/**\n * Maps raw Supabase error messages to user-friendly descriptions\n */\nfunction getAuthErrorMessage(\n  rawMessage: string,\n  mode: AuthFormMode,\n  tab: 'password' | 'magic',\n): string {\n  const lower = rawMessage.toLowerCase();\n\n  // Invalid credentials\n  if (lower.includes('invalid') && (lower.includes('credentials') || lower.includes('login'))) {\n    return 'The email or password you entered is incorrect. Please try again.';\n  }\n\n  // User not found\n  if (lower.includes('user') && lower.includes('not found')) {\n    return mode === 'signin'\n      ? \"We couldn't find an account with that email. Please check your email or sign up.\"\n      : 'Unable to create account. Please try again.';\n  }\n\n  // Email already registered\n  if (lower.includes('already') && lower.includes('registered')) {\n    return 'An account with this email already exists. Try signing in instead.';\n  }\n\n  // Invalid email format\n  if (lower.includes('invalid') && lower.includes('email')) {\n    return 'Please enter a valid email address (e.g., you@example.com).';\n  }\n\n  // Password too weak\n  if (lower.includes('password') && (lower.includes('weak') || lower.includes('strength'))) {\n    return 'Please choose a stronger password with at least 8 characters, including letters and numbers.';\n  }\n\n  // Rate limiting\n  if (lower.includes('rate limit') || lower.includes('too many')) {\n    return 'Too many attempts. Please wait a few minutes before trying again.';\n  }\n\n  // Email sending issues\n  if (lower.includes('email') && (lower.includes('send') || lower.includes('deliver'))) {\n    return 'Unable to send email. Please check your email address and try again.';\n  }\n\n  // Network issues\n  if (lower.includes('network') || lower.includes('connection') || lower.includes('timeout')) {\n    return 'Connection issue. Please check your internet connection and try again.';\n  }\n\n  // Magic link specific\n  if (tab === 'magic' && lower.includes('otp')) {\n    return 'Unable to send magic link. Please try again or use email & password sign in.';\n  }\n\n  // Signup specific - email confirmation\n  if (mode === 'signup' && lower.includes('confirm')) {\n    return 'Please check your email to confirm your account before signing in.';\n  }\n\n  // Generic fallback with more helpful context\n  if (rawMessage) {\n    return `Authentication error: ${rawMessage}. Please try again or contact support if the issue persists.`;\n  }\n\n  return 'Something went wrong. Please try again or contact support if the issue persists.';\n}\n\nexport function AuthForm({\n  mode,\n  redirect,\n  primaryCtaLabel,\n}: {\n  mode: AuthFormMode;\n  redirect: string;\n  primaryCtaLabel: string;\n}) {\n  const go = useGo();\n  const [activeTab, setActiveTab] = useState<'password' | 'magic'>('password');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [confirm, setConfirm] = useState('');\n  const [fullName, setFullName] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [err, setErr] = useState<string | null>(null);\n  const [notice, setNotice] = useState<string | null>(null);\n\n  // Default tab is password on every mount and route\n  useEffect(() => {\n    setActiveTab('password');\n  }, [mode]);\n\n  // Prepare the callback URL for auth redirects - ensure we use the consistent naming for params\n  const emailRedirectTo = `${window.location.origin}/auth/callback?next=${encodeURIComponent(redirect)}`;\n\n  // Mode-specific validation and submission logic\n  const handleSignIn = async () => {\n    if (activeTab === 'password') {\n      // Sign in with email/password\n      const { error } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      });\n\n      if (error) throw error;\n      go(normalizeSafeRedirect(redirect));\n      return;\n    } else {\n      // Magic Link flow (only available for sign-in)\n      const { error } = await supabase.auth.signInWithOtp({\n        email,\n        options: {\n          emailRedirectTo,\n        },\n      });\n\n      if (error) throw error;\n      setNotice('Magic link sent. Check your email.');\n      // Optional: redirect to a \"check email\" page instead\n      // go('/check-email?mode=signin', { replace: true });\n    }\n  };\n\n  const handleSignUp = async () => {\n    // Sign up requires email/password validation\n    if (!password || password.length < 8) {\n      setErr('Use at least 8 characters.');\n      return false;\n    }\n\n    if (password !== confirm) {\n      setErr('Passwords do not match.');\n      return false;\n    }\n\n    // Create new account with optional full name\n    const { error } = await supabase.auth.signUp({\n      email,\n      password,\n      options: {\n        emailRedirectTo,\n        data: { full_name: fullName || undefined },\n      },\n    });\n\n    if (error) throw error;\n\n    // If using email confirmation (recommended), show a message\n    setNotice('Check your email to confirm your account.');\n    // Optional: redirect to a \"check email\" page instead\n    // go('/check-email?mode=signup', { replace: true });\n\n    return true;\n  };\n\n  const onSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setErr(null);\n    setNotice(null);\n    setLoading(true);\n\n    try {\n      if (mode === 'signup') {\n        await handleSignUp();\n      } else {\n        await handleSignIn();\n      }\n    } catch (e: any) {\n      // Map Supabase errors to user-friendly messages\n      const errorMessage = getAuthErrorMessage(e?.message || '', mode, activeTab);\n      setErr(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const showConfirm = mode === 'signup' && activeTab === 'password';\n\n  // Mode-specific UI helpers\n  const tabBtn = (k: 'password' | 'magic', label: string) => (\n    <button\n      type=\"button\"\n      onClick={() => setActiveTab(k)}\n      className={`px-3 py-2 text-sm font-medium ${activeTab === k ? 'text-[#13294B] border-b-2 border-[#D4AF37]' : 'text-slate-500'}`}\n      aria-pressed={activeTab === k}\n    >\n      {label}\n    </button>\n  );\n\n  // Mode-specific labels and hints\n  const emailPlaceholder = mode === 'signin' ? 'Enter your email' : 'Enter your email address';\n  const passwordPlaceholder =\n    mode === 'signin' ? 'Enter your password' : 'Create a strong password';\n  const passwordLabel = mode === 'signin' ? 'Password' : 'Create password';\n\n  return (\n    <form onSubmit={onSubmit} className=\"space-y-5\">\n      {/* Tab selector - only show Magic Link option for sign-in */}\n      <div className=\"flex items-center gap-4 border-b pb-2\">\n        {tabBtn('password', 'Email & Password')}\n        {mode === 'signin' && (\n          <>\n            <span className=\"h-5 w-px bg-slate-200\" />\n            {tabBtn('magic', 'Magic Link')}\n          </>\n        )}\n      </div>\n\n      <div className=\"space-y-4\">\n        {/* Full Name field - only for sign-up */}\n        {mode === 'signup' && (\n          <div>\n            <label htmlFor=\"fullname-input\" className=\"block text-sm font-medium text-slate-700\">\n              Full name\n            </label>\n            <input\n              id=\"fullname-input\"\n              type=\"text\"\n              value={fullName}\n              onChange={(e) => setFullName(e.target.value)}\n              className=\"mt-1 w-full rounded-lg border border-slate-300 px-3 py-2 outline-none focus:ring-2 focus:ring-[#D4AF37]\"\n              autoComplete=\"name\"\n              placeholder=\"Enter your full name\"\n            />\n          </div>\n        )}\n\n        {/* Email field - common to both modes */}\n        <div>\n          <label htmlFor=\"email-input\" className=\"block text-sm font-medium text-slate-700\">\n            Email address\n          </label>\n          <input\n            id=\"email-input\"\n            required\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            className=\"mt-1 w-full rounded-lg border border-slate-300 px-3 py-2 outline-none focus:ring-2 focus:ring-[#D4AF37]\"\n            autoComplete=\"email\"\n            placeholder={emailPlaceholder}\n          />\n        </div>\n\n        {activeTab === 'password' && (\n          <>\n            <div>\n              <label htmlFor=\"password-input\" className=\"block text-sm font-medium text-slate-700\">\n                {passwordLabel}\n              </label>\n              <input\n                id=\"password-input\"\n                required\n                type=\"password\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n                className=\"mt-1 w-full rounded-lg border border-slate-300 px-3 py-2 outline-none focus:ring-2 focus:ring-[#D4AF37]\"\n                autoComplete={mode === 'signup' ? 'new-password' : 'current-password'}\n                placeholder={passwordPlaceholder}\n                minLength={mode === 'signup' ? 8 : undefined}\n              />\n              {mode === 'signin' && (\n                <div className=\"mt-2 text-right\">\n                  <a\n                    href=\"/auth/forgot-password\"\n                    className=\"text-sm text-[#13294B] hover:underline\"\n                  >\n                    Forgot your password?\n                  </a>\n                </div>\n              )}\n            </div>\n\n            {showConfirm && (\n              <div>\n                <label\n                  htmlFor=\"confirm-password-input\"\n                  className=\"block text-sm font-medium text-slate-700\"\n                >\n                  Confirm password\n                </label>\n                <input\n                  id=\"confirm-password-input\"\n                  required\n                  type=\"password\"\n                  value={confirm}\n                  onChange={(e) => setConfirm(e.target.value)}\n                  className=\"mt-1 w-full rounded-lg border border-slate-300 px-3 py-2 outline-none focus:ring-2 focus:ring-[#D4AF37]\"\n                  autoComplete=\"new-password\"\n                  placeholder=\"Confirm your password\"\n                />\n              </div>\n            )}\n          </>\n        )}\n      </div>\n\n      {/* Error and notification handling */}\n      {err && <p className=\"text-sm text-red-600\">{err}</p>}\n      {notice && <p className=\"text-sm text-emerald-700\">{notice}</p>}\n\n      {/* Mode-specific submission button */}\n      <button\n        type=\"submit\"\n        disabled={loading}\n        className={`w-full rounded-xl bg-[#13294B] text-white px-4 py-3 font-semibold ring-1 ring-black/5 hover:opacity-90 disabled:opacity-60`}\n        data-testid={`${mode}-button`}\n      >\n        {loading\n          ? 'Please wait…'\n          : mode === 'signup'\n            ? 'Create account'\n            : activeTab === 'password'\n              ? 'Sign in'\n              : 'Send magic link'}\n      </button>\n\n      {/* Mode-specific helper text */}\n      {mode === 'signin' && activeTab === 'password' && (\n        <p className=\"text-center text-xs text-slate-500\">\n          Trouble signing in? Try the Magic Link tab for password-free sign in.\n        </p>\n      )}\n      {mode === 'signin' && activeTab === 'magic' && (\n        <p className=\"text-center text-xs text-slate-500\">\n          We'll email you a secure link for password-free access to your account.\n        </p>\n      )}\n      {mode === 'signup' && (\n        <p className=\"text-center text-xs text-slate-500\">\n          By creating an account, you agree to our Terms of Service and Privacy Policy.\n        </p>\n      )}\n\n      {/* Account switching links removed - now handled by AuthFooter component */}\n    </form>\n  );\n}\n",
/Users/davehail/Developer/inkwell/eslint-report.json:6863:    "source": "import { useCallback } from 'react';\n\nimport { useAuth } from '../context/AuthContext';\nimport { useMaybeDB, defineStores } from '../data/dbFactory';\n\nexport interface TutorialProgress {\n  slug: string;\n  progress: {\n    currentStep: number;\n    completedSteps: string[];\n    tourType: 'full-onboarding' | 'feature-tour' | 'contextual-help';\n    startedAt: number;\n    completedAt?: number;\n    isCompleted: boolean;\n    totalSteps: number;\n    lastActiveAt: number;\n  };\n  updatedAt: number;\n}\n\nexport interface TutorialPreferences {\n  neverShowAgain: boolean;\n  remindMeLater: boolean;\n  remindMeLaterUntil?: number;\n  completedTours: string[];\n  tourDismissals: number;\n  hasLaunched?: boolean;\n}\n\nexport interface CompletionChecklist {\n  createProject: boolean;\n  addChapter: boolean;\n  addCharacter: boolean;\n  writeContent: boolean;\n  useTimeline: boolean;\n  exportProject: boolean;\n  useAI: boolean;\n}\n\n/**\n * Hook for managing tutorial progress, preferences, and checklist data.\n */\nexport function useTutorialStorage() {\n  const { user } = useAuth();\n  const db = useMaybeDB();\n  const stores = defineStores(db);\n\n  const isUserActive = Boolean(user?.id && db);\n\n  const getProgress = useCallback(\n    async (_slug: string): Promise<TutorialProgress | null> => {\n      if (!isUserActive) return null;\n      // TODO: implement IndexedDB get logic\n      return null;\n    },\n    [isUserActive],\n  );\n\n  const setProgress = useCallback(\n    async (_slug: string, _progress: TutorialProgress['progress']) => {\n      if (!isUserActive) return;\n      // TODO: implement IndexedDB put logic\n    },\n    [isUserActive],\n  );\n\n  const clearProgress = useCallback(\n    async (_slug?: string) => {\n      if (!isUserActive) return;\n      // TODO: implement clear logic for one or all progress entries\n    },\n    [isUserActive],\n  );\n\n  const getPreferences = useCallback(async (): Promise<TutorialPreferences | null> => {\n    if (!isUserActive) return null;\n    // TODO: implement get preferences logic\n    return null;\n  }, [isUserActive]);\n\n  const setPreferences = useCallback(\n    async (_preferences: TutorialPreferences) => {\n      if (!isUserActive) return;\n      // TODO: implement save preferences logic\n    },\n    [isUserActive],\n  );\n\n  const getChecklist = useCallback(async (): Promise<CompletionChecklist | null> => {\n    if (!isUserActive) return null;\n    // TODO: implement get checklist logic\n    return null;\n  }, [isUserActive]);\n\n  const setChecklist = useCallback(\n    async (_checklist: CompletionChecklist) => {\n      if (!isUserActive) return;\n      // TODO: implement save checklist logic\n    },\n    [isUserActive],\n  );\n\n  const getAllProgress = useCallback(async (): Promise<TutorialProgress[]> => {\n    if (!isUserActive) return [];\n    // TODO: implement get all progress logic\n    return [];\n  }, [isUserActive]);\n\n  /**\n   * Reset a tour's progress so it can be relaunched from step 0.\n   * totalSteps is optional; if omitted we'll keep whatever was there (or default to 4).\n   * tourType is optional; defaults to 'full-onboarding' to match first-run.\n   */\n  const resetProgress = useCallback(\n    async (\n      slug: string,\n      _totalSteps?: number,\n      _tourType: TutorialProgress['progress']['tourType'] = 'full-onboarding',\n    ) => {\n      if (!isUserActive) return;\n      const existing = await getProgress(slug);\n      const now = Date.now();\n      const currentTotal = _totalSteps ?? existing?.progress.totalSteps ?? 4;\n      const payload: TutorialProgress = {\n        slug,\n        updatedAt: now,\n        progress: {\n          currentStep: 0,\n          completedSteps: [],\n          tourType: _tourType,\n          startedAt: now,\n          completedAt: undefined,\n          isCompleted: false,\n          totalSteps: currentTotal,\n          lastActiveAt: now,\n        },\n      };\n      await setProgress(slug, payload.progress);\n    },\n    [getProgress, setProgress, isUserActive],\n  );\n\n  return {\n    // Core progress methods\n    getProgress,\n    setProgress,\n    clearProgress,\n    getAllProgress,\n\n    // Reset utility\n    resetProgress,\n\n    // Preferences methods\n    getPreferences,\n    setPreferences,\n\n    // Checklist methods\n    getChecklist,\n    setChecklist,\n\n    // User context\n    userId: user?.id || null,\n    isUserActive,\n  };\n}\n\n/**\n * Legacy localStorage-based storage (fallback for migration)\n */\nexport class LegacyTutorialStorage {\n  private static getKey(suffix: string, profileId?: string): string {\n    return profileId ? `inkwell:tutorial:${profileId}:${suffix}` : `inkwell:tutorial:${suffix}`;\n  }\n\n  static getProgress(slug: string = '__default__', profileId?: string): TutorialProgress | null {\n    try {\n      const key = this.getKey(`progress:${slug}`, profileId);\n      const data = localStorage.getItem(key);\n      return data ? (JSON.parse(data) as TutorialProgress) : null;\n    } catch {\n      return null;\n    }\n  }\n\n  static setProgress(\n    slug: string = '__default__',\n    progress: TutorialProgress,\n    profileId?: string,\n  ): void {\n    try {\n      const key = this.getKey(`progress:${slug}`, profileId);\n      localStorage.setItem(key, JSON.stringify(progress));\n    } catch {\n      /* ignore */\n    }\n  }\n\n  static getPreferences(profileId?: string): TutorialPreferences | null {\n    try {\n      const key = this.getKey('preferences', profileId);\n      const data = localStorage.getItem(key);\n      return data ? (JSON.parse(data) as TutorialPreferences) : null;\n    } catch {\n      return null;\n    }\n  }\n\n  static getChecklist(profileId?: string): CompletionChecklist | null {\n    try {\n      const key = this.getKey('checklist', profileId);\n      const data = localStorage.getItem(key);\n      return data ? (JSON.parse(data) as CompletionChecklist) : null;\n    } catch {\n      return null;\n    }\n  }\n\n  static getAllLegacyKeys(): string[] {\n    return Object.keys(localStorage).filter((k) => k.startsWith('inkwell:tutorial:'));\n  }\n\n  static clearLegacyData(profileId?: string): void {\n    const prefix = profileId ? `inkwell:tutorial:${profileId}:` : 'inkwell:tutorial:';\n    Object.keys(localStorage).forEach((k) => {\n      if (k.startsWith(prefix)) localStorage.removeItem(k);\n    });\n  }\n}\n\n/**\n * Migration helper – migrates old localStorage tutorial data into the new IndexedDB\n */\nexport async function _migrateLegacyTutorialData(\n  profileId: string,\n  db: any, // Replace with the correct ProfileStorageManager type\n  isFirstProfile = false,\n): Promise<void> {\n  // TODO: implement migration logic from LegacyTutorialStorage to IndexedDB\n  // Use `defineStores(db)` and upsert data into appropriate tables.\n}\n\n// Export the default hook\nexport default useTutorialStorage;\n",
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:46:      '@tiptap/extension-placeholder':
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:453:  '@babel/plugin-proposal-private-property-in-object@7.21.0-placeholder-for-preset-env.2':
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:892:    resolution: {integrity: sha512-BIW7bofD2yAWoE8H4V40FikC+1nNFEKBisMECccS16W1rt6qqhNTBDmIw5HaqmMgtLNz9e7oiALiEUuKrQ4oHg==}
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:1890:  '@tiptap/extension-placeholder@3.7.2':
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:2039:    deprecated: This is a stub types definition. history provides its own type definitions, so you do not need this installed.
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:2096:    deprecated: This is a stub types definition. recharts provides its own type definitions, so you do not need this installed.
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:2478:    resolution: {integrity: sha512-3duEwti880xqi4eAMN8AyR4a0ByT90zoYdLlevfrvU43vb0YZwZVfxOgxWrLXXXpyugL0hNZc9G6BiB5B3nUug==}
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:5152:    resolution: {integrity: sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==}
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:6353:  '@babel/plugin-proposal-private-property-in-object@7.21.0-placeholder-for-preset-env.2(@babel/core@7.28.4)':
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:6760:      '@babel/plugin-proposal-private-property-in-object': 7.21.0-placeholder-for-preset-env.2(@babel/core@7.28.4)
/Users/davehail/Developer/inkwell/pnpm-lock.yaml:7886:  '@tiptap/extension-placeholder@3.7.2(@tiptap/extensions@3.7.2(@tiptap/core@3.7.2(@tiptap/pm@3.7.2))(@tiptap/pm@3.7.2))':
/Users/davehail/Developer/inkwell/src/styles/design-system.css:1:/* Inkwell Design System - Professional & Cohesive UI */ /* ============================================= COLOR SYSTEM ============================================= */ :root, [data-theme='light'] { /* Primary Brand Colors */ --color-primary-50: #eff6ff; --color-primary-100: #dbeafe; --color-primary-200: #bfdbfe; --color-primary-300: #93c5fd; --color-primary-400: #60a5fa; --color-primary-500: #3b82f6; --color-primary-600: #2563eb; --color-primary-700: #1d4ed8; --color-primary-800: #1e40af; --color-primary-900: #1e3a8a; /* Neutral Colors */ --color-slate-50: #f8fafc; --color-slate-100: #f1f5f9; --color-slate-200: #e2e8f0; --color-slate-300: #cbd5e1; --color-slate-400: #94a3b8; --color-slate-500: #64748b; --color-slate-600: #475569; --color-slate-700: #334155; --color-slate-800: #1e293b; --color-slate-900: #0f172a; /* Semantic Colors */ --color-success-50: #f0fdf4; --color-success-500: #22c55e; --color-success-600: #16a34a; --color-warning-50: #fffbeb; --color-warning-500: #f59e0b; --color-warning-600: #d97706; --color-error-50: #fef2f2; --color-error-500: #ef4444; --color-error-600: #dc2626; /* Background Colors */ --color-bg-primary: var(--color-slate-50); --color-bg-secondary: #fff; --color-bg-tertiary: var(--color-slate-100); --color-bg-accent: var(--color-primary-50); /* Text Colors */ --color-text-primary: var(--color-slate-900); --color-text-secondary: var(--color-slate-600); --color-text-muted: var(--color-slate-500); --color-text-inverse: #fff; /* Border Colors */ --color-border-light: var(--color-slate-200); --color-border-medium: var(--color-slate-300); --color-border-strong: var(--color-slate-400); --color-border-accent: var(--color-primary-200); /* Spacing System */ --space-1: 0.25rem; /* 4px */ --space-2: 0.5rem; /* 8px */ --space-3: 0.75rem; /* 12px */ --space-4: 1rem; /* 16px */ --space-5: 1.25rem; /* 20px */ --space-6: 1.5rem; /* 24px */ --space-8: 2rem; /* 32px */ --space-10: 2.5rem; /* 40px */ --space-12: 3rem; /* 48px */ --space-16: 4rem; /* 64px */ --space-20: 5rem; /* 80px */ /* Radius System */ --radius-sm: 0.375rem; /* 6px */ --radius-md: 0.5rem; /* 8px */ --radius-lg: 0.75rem; /* 12px */ --radius-xl: 1rem; /* 16px */ --radius-2xl: 1.5rem; /* 24px */ /* Shadow System */ --shadow-xs: 0 1px 2px 0 rgb(0 0 0 / 5%); --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 10%), 0 1px 2px -1px rgb(0 0 0 / 10%); --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 10%), 0 2px 4px -2px rgb(0 0 0 / 10%); --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 10%), 0 4px 6px -4px rgb(0 0 0 / 10%); --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 10%), 0 8px 10px -6px rgb(0 0 0 / 10%); /* Typography Scale */ --font-size-xs: 0.75rem; /* 12px */ --font-size-sm: 0.875rem; /* 14px */ --font-size-base: 1rem; /* 16px */ --font-size-lg: 1.125rem; /* 18px */ --font-size-xl: 1.25rem; /* 20px */ --font-size-2xl: 1.5rem; /* 24px */ --font-size-3xl: 1.875rem; /* 30px */ --font-size-4xl: 2.25rem; /* 36px */ --font-size-5xl: 3rem; /* 48px */ /* Line Heights */ --leading-tight: 1.25; --leading-snug: 1.375; --leading-normal: 1.5; --leading-relaxed: 1.625; --leading-loose: 2; /* Font Weights */ --font-weight-normal: 400; --font-weight-medium: 500; --font-weight-semibold: 600; --font-weight-bold: 700; /* Transitions */ --transition-fast: 150ms ease; --transition-normal: 250ms ease; --transition-slow: 350ms ease; } /* Dark mode colors */ .dark, [data-theme='dark'] { --color-bg-primary: var(--color-slate-900); --color-bg-secondary: var(--color-slate-800); --color-bg-tertiary: var(--color-slate-700); --color-bg-accent: #1e40af; --color-text-primary: var(--color-slate-100); --color-text-secondary: var(--color-slate-300); --color-text-muted: var(--color-slate-400); --color-border-light: var(--color-slate-700); --color-border-medium: var(--color-slate-600); --color-border-strong: var(--color-slate-500); --color-border-accent: var(--color-primary-500); } /* ============================================= TYPOGRAPHY SYSTEM ============================================= */ .text-display-2xl { font-size: var(--font-size-5xl); font-weight: var(--font-weight-bold); line-height: var(--leading-tight); letter-spacing: -0.025em; } .text-display-xl { font-size: var(--font-size-4xl); font-weight: var(--font-weight-bold); line-height: var(--leading-tight); letter-spacing: -0.025em; } .text-heading-xl { font-size: var(--font-size-3xl); font-weight: var(--font-weight-semibold); line-height: var(--leading-tight); letter-spacing: -0.025em; } .text-heading-lg { font-size: var(--font-size-2xl); font-weight: var(--font-weight-semibold); line-height: var(--leading-tight); } .text-heading-md { font-size: var(--font-size-xl); font-weight: var(--font-weight-semibold); line-height: var(--leading-snug); } .text-heading-sm { font-size: var(--font-size-lg); font-weight: var(--font-weight-semibold); line-height: var(--leading-snug); } .text-body-lg { font-size: var(--font-size-lg); font-weight: var(--font-weight-normal); line-height: var(--leading-relaxed); } .text-body-base { font-size: var(--font-size-base); font-weight: var(--font-weight-normal); line-height: var(--leading-normal); } .text-body-sm { font-size: var(--font-size-sm); font-weight: var(--font-weight-normal); line-height: var(--leading-normal); } .text-caption { font-size: var(--font-size-xs); font-weight: var(--font-weight-normal); line-height: var(--leading-normal); color: var(--color-text-muted); } .text-overline { font-size: var(--font-size-xs); font-weight: var(--font-weight-semibold); line-height: var(--leading-normal); text-transform: uppercase; letter-spacing: 0.1em; color: var(--color-text-muted); } /* ============================================= COMPONENT SYSTEM ============================================= */ /* Base Card Component */ .card { background-color: var(--color-bg-secondary); border: 1px solid var(--color-border-light); border-radius: var(--radius-lg); box-shadow: var(--shadow-xs); transition: all var(--transition-normal); overflow: hidden; } .card:hover { box-shadow: var(--shadow-sm); border-color: var(--color-border-medium); } .card-interactive { cursor: pointer; } .card-interactive:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); border-color: var(--color-border-accent); } .card-header { padding: var(--space-6); border-bottom: 1px solid var(--color-border-light); } .card-content { padding: var(--space-6); } .card-footer { padding: var(--space-6); border-top: 1px solid var(--color-border-light); background-color: var(--color-bg-tertiary); } /* Button System */ .btn { display: inline-flex; align-items: center; justify-content: center; gap: var(--space-2); padding: var(--space-3) var(--space-4); border-radius: var(--radius-md); font-size: var(--font-size-sm); font-weight: var(--font-weight-medium); line-height: var(--leading-tight); text-decoration: none; transition: all var(--transition-fast); cursor: pointer; border: 1px solid transparent; white-space: nowrap; } .btn:disabled { opacity: 0.6; cursor: not-allowed; } .btn-sm { padding: var(--space-2) var(--space-3); font-size: var(--font-size-xs); } .btn-lg { padding: var(--space-4) var(--space-6); font-size: var(--font-size-base); } .btn-primary { background-color: var(--color-primary-600); color: var(--color-text-inverse); border-color: var(--color-primary-600); } .btn-primary:hover { background-color: var(--color-primary-700); border-color: var(--color-primary-700); transform: translateY(-1px); box-shadow: var(--shadow-sm); } .btn-secondary { background-color: var(--color-bg-secondary); color: var(--color-text-primary); border-color: var(--color-border-medium); } .btn-secondary:hover { background-color: var(--color-bg-tertiary); border-color: var(--color-border-strong); } .btn-ghost { background-color: transparent; color: var(--color-text-secondary); border-color: transparent; } .btn-ghost:hover { background-color: var(--color-bg-tertiary); color: var(--color-text-primary); } .btn-danger { background-color: var(--color-error-500); color: var(--color-text-inverse); border-color: var(--color-error-500); } .btn-danger:hover { background-color: var(--color-error-600); border-color: var(--color-error-600); } /* Input System */ .input { width: 100%; padding: var(--space-3) var(--space-4); background-color: var(--color-bg-secondary); border: 1px solid var(--color-border-medium); border-radius: var(--radius-md); font-size: var(--font-size-sm); line-height: var(--leading-normal); color: var(--color-text-primary); transition: all var(--transition-fast); } .input::placeholder { color: var(--color-text-muted); } .input:focus { outline: none; border-color: var(--color-primary-500); box-shadow: 0 0 0 3px var(--color-primary-100); } .input:disabled { opacity: 0.6; cursor: not-allowed; background-color: var(--color-bg-tertiary); } .dark .input:focus { box-shadow: 0 0 0 3px rgb(59 130 246 / 30%); } /* Badge System */ .badge { display: inline-flex; align-items: center; gap: var(--space-1); padding: var(--space-1) var(--space-2); border-radius: var(--radius-sm); font-size: var(--font-size-xs); font-weight: var(--font-weight-medium); line-height: var(--leading-tight); text-transform: uppercase; letter-spacing: 0.05em; } .badge-primary { background-color: var(--color-primary-100); color: var(--color-primary-800); } .badge-success { background-color: var(--color-success-50); color: var(--color-success-600); } .badge-warning { background-color: var(--color-warning-50); color: var(--color-warning-600); } .badge-error { background-color: var(--color-error-50); color: var(--color-error-600); } .badge-neutral { background-color: var(--color-slate-100); color: var(--color-slate-700); } /* Progress System */ .progress { width: 100%; height: var(--space-2); background-color: var(--color-slate-200); border-radius: var(--radius-sm); overflow: hidden; } .dark .progress { background-color: var(--color-slate-700); } .progress-bar { height: 100%; background-color: var(--color-primary-500); transition: width var(--transition-slow); border-radius: var(--radius-sm); } /* Divider */ .divider { border: none; border-top: 1px solid var(--color-border-light); margin: var(--space-6) 0; } /* Focus Ring */ .focus-ring:focus-visible { outline: none; box-shadow: 0 0 0 3px var(--color-primary-200); } .dark .focus-ring:focus-visible { box-shadow: 0 0 0 3px rgb(59 130 246 / 30%); } /* Loading States */ .loading { position: relative; overflow: hidden; } .loading::after { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, var(--color-slate-200), transparent); animation: shimmer 2s infinite; } .dark .loading::after { background: linear-gradient(90deg, transparent, var(--color-slate-600), transparent); } @keyframes shimmer { 0% { left: -100%; } 100% { left: 100%; } } /* ============================================= LAYOUT UTILITIES ============================================= */ .container { max-width: 1200px; margin: 0 auto; padding: 0 var(--space-6); } .container-sm { max-width: 640px; margin: 0 auto; padding: 0 var(--space-4); } .container-lg { max-width: 1400px; margin: 0 auto; padding: 0 var(--space-8); } .stack { display: flex; flex-direction: column; } .stack-sm > * + * { margin-top: var(--space-2); } .stack-md > * + * { margin-top: var(--space-4); } .stack-lg > * + * { margin-top: var(--space-6); } .cluster { display: flex; flex-wrap: wrap; gap: var(--space-2); align-items: center; } .cluster-sm { gap: var(--space-1); } .cluster-lg { gap: var(--space-4); } .center { display: flex; align-items: center; justify-content: center; } .between { display: flex; justify-content: space-between; align-items: center; } .surface { background-color: var(--color-bg-secondary); border-radius: var(--radius-lg); padding: var(--space-6); box-shadow: var(--shadow-xs); } /* ============================================= ANIMATION UTILITIES ============================================= */ .fade-in { animation: fade-in var(--transition-normal) ease-out; } .slide-up { animation: slide-up var(--transition-normal) ease-out; } .scale-in { animation: scale-in var(--transition-normal) ease-out; } @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } } @keyframes slide-up { from { opacity: 0; transform: translateY(var(--space-4)); } to { opacity: 1; transform: translateY(0); } } @keyframes scale-in { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } } /* ============================================= TAILWIND COMPATIBILITY LAYER ============================================= */ @layer components { .bg-primary-50 { background-color: var(--color-primary-50); } .bg-primary-100 { background-color: var(--color-primary-100); } .bg-primary-500 { background-color: var(--color-primary-500); } .bg-primary-600 { background-color: var(--color-primary-600); } .bg-primary-700 { background-color: var(--color-primary-700); } .bg-primary-900 { background-color: var(--color-primary-900); } .text-primary-400 { color: var(--color-primary-400); } .text-primary-500 { color: var(--color-primary-500); } .text-primary-600 { color: var(--color-primary-600); } .border-primary-200 { border-color: var(--color-primary-200); } .border-primary-500 { border-color: var(--color-primary-500); } .border-primary-800 { border-color: var(--color-primary-800); } } /* ============================================= RESPONSIVE UTILITIES ============================================= */ @media (width <= 640px) { .container { padding: 0 var(--space-4); } .card-content, .card-header, .card-footer { padding: var(--space-4); } .text-display-2xl { font-size: var(--font-size-3xl); } .text-display-xl { font-size: var(--font-size-2xl); } .text-heading-xl { font-size: var(--font-size-xl); } } 
/Users/davehail/Developer/inkwell/FINAL_STATUS.md:56:- WritingPanel: Marked @deprecated with migration guide
/Users/davehail/Developer/inkwell/src/services/backupService.ts:1:// src/services/backupService.ts /** Renamed string union for process status */ export type BackupProcessStatus = 'idle' | 'saving' | 'success' | 'error' | 'retrying'; /** Object describing overall backup stats */ export interface BackupStats { totalBackups: number; totalSize: string; lastBackup: number | null; autoBackupEnabled: boolean; storageWarning: boolean; } /** State of the BackupManager */ export interface BackupManagerState { status: BackupProcessStatus; lastSuccess: number | null; error: string | null; retryCount: number; retryDelayMs: number; } /** Backup data structure */ export interface Backup { id: string; type?: 'auto' | 'manual' | 'emergency'; title?: string; description?: string; data: unknown; timestamp: number; size?: number; isCorrupted?: boolean; } type NotifyFn = (_message: string, _type?: 'info' | 'success' | 'error') => void; const BACKUPS_KEY = 'app_backups'; // Simple lock mechanism for concurrent operations let saveLock: Promise<void> | null = null; // Utility functions export async function _getBackups(): Promise<Backup[]> { try { const json = localStorage.getItem(BACKUPS_KEY); if (!json) return []; return JSON.parse(json) as Backup[]; } catch { return []; } } export async function _saveBackup(backup: Backup): Promise<void> { // Wait for any pending save operations to complete while (saveLock) { await saveLock; } // Create a new lock for this operation saveLock = (async () => { const backups = await getBackups(); backups.push(backup); localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups)); })(); try { await saveLock; } finally { saveLock = null; } } export async function _restoreBackup( id: string, ): Promise<{ success: boolean; message?: string; error?: string }> { try { const backups = await getBackups(); const backup = backups.find((b) => b.id === id); if (!backup) { return { success: false, error: 'Backup not found' }; } if (!backup.data || backup.data === null || typeof backup.data !== 'object') { return { success: false, error: 'Invalid backup data format' }; } // Check if the backup contains project data or writing chapters const data = backup.data as any; // Validate that the backup has at least some meaningful data const hasProjects = data.projects && Array.isArray(data.projects); const hasChapters = data.writingChapters && typeof data.writingChapters === 'object'; const hasAppData = data.appData && typeof data.appData === 'object'; if (!hasProjects && !hasChapters && !hasAppData) { return { success: false, error: 'Invalid backup data format' }; } // Restore projects if present if (data.projects && Array.isArray(data.projects)) { try { // Create backup of current state first const currentProjects = localStorage.getItem('inkwell_enhanced_projects'); if (currentProjects) { const emergencyBackup: Backup = { id: `emergency_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, type: 'emergency', title: 'Emergency Backup Before Restore', description: `Automatic backup created before restoring backup ${id}`, data: JSON.parse(currentProjects), timestamp: Date.now(), }; await saveBackup(emergencyBackup); } // Restore the project data localStorage.setItem('inkwell_enhanced_projects', JSON.stringify(data.projects)); } catch (error) { return { success: false, error: `Failed to restore projects: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } // Restore writing chapters if present if (data.writingChapters && typeof data.writingChapters === 'object') { try { for (const [projectId, chapters] of Object.entries(data.writingChapters)) { if (Array.isArray(chapters)) { const key = `inkwell_writing_chapters_${projectId}`; // Create emergency backup of current writing data const currentChapters = localStorage.getItem(key); if (currentChapters) { const emergencyBackup: Backup = { id: `emergency_chapters_${projectId}_${Date.now()}`, type: 'emergency', title: `Emergency Writing Backup - ${projectId}`, description: `Automatic backup of writing chapters before restore`, data: { projectId, chapters: JSON.parse(currentChapters) }, timestamp: Date.now(), }; await saveBackup(emergencyBackup); } localStorage.setItem(key, JSON.stringify(chapters)); } } } catch (error) { return { success: false, error: `Failed to restore writing chapters: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } // Restore general app data if present if (data.appData && typeof data.appData === 'object') { try { for (const [key, value] of Object.entries(data.appData)) { if (key.startsWith('inkwell_')) { localStorage.setItem(key, JSON.stringify(value)); } } } catch (error) { devLog.warn('Failed to restore some app data:', error); } } // Trigger a page reload to refresh the app state // This ensures all components pick up the restored data setTimeout(() => { window.location.reload(); }, 1000); return { success: true, message: 'Backup restored successfully! The page will reload to apply changes.', }; } catch (error) { return { success: false, error: `Failed to restore backup: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } export async function _deleteBackup( id: string, ): Promise<{ success: boolean; message?: string; error?: string }> { try { let backups = await getBackups(); const initialLength = backups.length; backups = backups.filter((b) => b.id !== id); if (backups.length === initialLength) { return { success: false, error: 'Backup not found' }; } localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups)); return { success: true, message: 'Backup deleted successfully' }; } catch (error) { return { success: false, error: `Failed to delete backup: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } export async function _exportBackup( id: string, ): Promise<{ success: boolean; message?: string; error?: string }> { try { const backups = await getBackups(); const backup = backups.find((b) => b.id === id); if (!backup) return { success: false, error: 'Backup not found' }; const dataStr = JSON.stringify(backup, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `backup_${backup.id}_${new Date().toISOString().split('T')[0]}.json`; a.click(); URL.revokeObjectURL(url); return { success: true, message: 'Backup exported successfully' }; } catch (error) { return { success: false, error: `Failed to export backup: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } export async function _importBackup( file: File, ): Promise<{ success: boolean; message?: string; error?: string }> { try { const text = await file.text(); const backup: Backup = JSON.parse(text); // Validate backup structure if (!backup.id || !backup.timestamp || backup.data === undefined) { return { success: false, error: 'Invalid backup file format' }; } // Check if backup already exists const existingBackups = await getBackups(); if (existingBackups.some((b) => b.id === backup.id)) { return { success: false, error: 'Backup with this ID already exists' }; } await saveBackup(backup); return { success: true, message: 'Backup imported successfully' }; } catch (error) { return { success: false, error: error instanceof Error && error.message.includes('JSON') ? 'Invalid file format' : `Failed to import backup: ${error instanceof Error ? error.message : 'Invalid file format'}`, }; } } export async function _clearAllBackups(): Promise<{ success: boolean; message?: string; error?: string; }> { try { localStorage.removeItem(BACKUPS_KEY); return { success: true, message: 'All backups cleared successfully' }; } catch (error) { return { success: false, error: `Failed to clear backups: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } export async function _getBackupStatus(): Promise<BackupStats> { const backups = await getBackups(); // Calculate total size based on individual backup sizes when available, or data size const totalSizeBytes = backups.length === 0 ? 0 : backups.reduce((total, _backup) => { if (backup.size) return total + backup.size; return total + new Blob([JSON.stringify(backup.data)]).size; }, 0); const formatSize = (bytes: number): string => { if (bytes < 1024) return `${bytes} B`; if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`; if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`; return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`; }; return { totalBackups: backups.length, totalSize: formatSize(totalSizeBytes), lastBackup: backups.length > 0 ? backups[backups.length - 1]!.timestamp : null, autoBackupEnabled: false, // TODO: Implement auto-backup functionality storageWarning: totalSizeBytes > 4 * 1024 * 1024, // Warn if over 4MB }; } // Auto-backup functionality - Fixed type issue let autoBackupInterval: ReturnType<typeof setInterval> | null = null; export function _startAutoBackup(_getAppData: () => string, getTitle: () => string, intervalMs: number = 300000, // Default 5 minutes ): void { if (autoBackupInterval) { stopAutoBackup(); } autoBackupInterval = setInterval(async () => { try { const backup: Backup = { id: `auto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, type: 'auto', title: getTitle(), description: 'Automatic backup', data: getAppData(), timestamp: Date.now(), }; await saveBackup(backup); devLog.debug('Auto-backup created successfully'); } catch (error) { devLog.error('Auto-backup failed:', error); } }, intervalMs); } export function _stopAutoBackup(): void { if (autoBackupInterval) { clearInterval(autoBackupInterval); autoBackupInterval = null; } } export async function _createManualBackup( data?: unknown, title?: string, description?: string, ): Promise<{ success: boolean; backup?: Backup; error?: string }> { try { // If no data provided, create a comprehensive backup of current state let backupData = data; if (!data) { backupData = { // Backup all project data projects: JSON.parse(localStorage.getItem('inkwell_enhanced_projects') || '[]'), // Backup all writing chapters for all projects writingChapters: (() => { const chapters: Record<string, any> = {}; for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key && key.startsWith('inkwell_writing_chapters_')) { const projectId = key.replace('inkwell_writing_chapters_', ''); const data = localStorage.getItem(key); if (data) { try { chapters[projectId] = JSON.parse(data); } catch (error) { devLog.warn( `Failed to backup writing chapters for project ${projectId}:`, error, ); } } } } return chapters; })(), // Backup other app data appData: (() => { const appData: Record<string, any> = {}; for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if ( key && key.startsWith('inkwell_') && !key.startsWith('inkwell_enhanced_projects') && !key.startsWith('inkwell_writing_chapters_') ) { const data = localStorage.getItem(key); if (data) { try { appData[key] = JSON.parse(data); } catch { // Store as string if it's not JSON appData[key] = data; } } } } return appData; })(), // Metadata about the backup backupMetadata: { version: '1.0', createdBy: 'Inkwell Manual Backup', timestamp: Date.now(), userAgent: navigator.userAgent, }, }; } const backup: Backup = { id: `manual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, type: 'manual', title: title || 'Manual Backup', description: description || 'User-created comprehensive backup', data: backupData, timestamp: Date.now(), size: new Blob([JSON.stringify(backupData)]).size, }; await saveBackup(backup); return { success: true, backup }; } catch (error) { return { success: false, error: `Failed to create backup: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } // Advanced BackupManager class for complex backup operations export class BackupManager { private state: BackupManagerState = { status: 'idle', lastSuccess: null, error: null, retryCount: 0, retryDelayMs: 1000, }; private isSaving = false; private maxRetries = 5; constructor( private backupFn: () => Promise<void>, private notify: NotifyFn, ) {} public getState(): BackupManagerState { return { ...this.state }; } public async listBackups(): Promise<Backup[]> { return getBackups(); } public async getStatus(): Promise<BackupStats> { return getBackupStatus(); } public async restoreBackup(id: string) { return restoreBackup(id); } public async deleteBackup(id: string) { return deleteBackup(id); } public async exportBackup(id: string) { return exportBackup(id); } public async importBackup(file: File) { return importBackup(file); } public async clearAllBackups() { return clearAllBackups(); } public async backup(): Promise<void> { if (this.isSaving) { this.notify('Backup already in progress. Please wait.', 'info'); return; } this.isSaving = true; this.updateStatus('saving'); this.notify('Starting backup...', 'info'); try { await this.backupFn(); this.updateStatus('success'); this.state.lastSuccess = Date.now(); this.state.error = null; this.state.retryCount = 0; this.state.retryDelayMs = 1000; this.notify('Backup successful!', 'success'); } catch (error: any) { this.state.error = error?.message || 'Unknown error'; this.updateStatus('error'); this.notify(`Backup failed: ${this.state.error}`, 'error'); await this.retryBackup(); } finally { this.isSaving = false; } } private async retryBackup(): Promise<void> { if (this.state.retryCount >= this.maxRetries) { this.notify('Maximum backup retry attempts reached. Please try again later.', 'error'); return; } this.state.retryCount++; this.updateStatus('retrying'); this.notify( `Retrying backup (#${this.state.retryCount}) in ${this.state.retryDelayMs / 1000} seconds...`, 'info', ); await this.delay(this.state.retryDelayMs); this.state.retryDelayMs *= 2; await this.backup(); } private updateStatus(status: BackupProcessStatus): void { this.state.status = status; } private delay(ms: number): Promise<void> { return new Promise((resolve) => setTimeout(resolve, ms)); } } // Create and export the service instance const backupService = new BackupManager( () => Promise.resolve(), () => {}, ); // Export as default export default backupService;
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:24:# A. Placeholder and stub sweeps
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:25:echo "Scanning for TODOs and stubs..."
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:26:rg -n --no-heading -S 'TODO|FIXME|XXX|TBD|HACK|WIP|TEMP|PUNT|stub|placeholder|not implemented|unimplemented|@deprecated' \
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:31:rg -n --no-heading -S 'throw new Error\\(|assert\\.fail\\(|//\\s*throw\\b|return\\s+null\\s*//\\s*stub' \
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:42:echo "Scanning for placeholder strings..."
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:44:  "${ROOT_DIR}" > "${AUDIT_DIR}/placeholders.txt" || true
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:91:COUNT_TODOS=$(count_file "${AUDIT_DIR}/todos.txt")
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:95:COUNT_PLACEHOLDERS=$(count_file "${AUDIT_DIR}/placeholders.txt")
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:103:# F. Generate Ship Readiness Report stub
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:132:Deprecated or TODO-like tags: ${COUNT_TODOS}
/Users/davehail/Developer/inkwell/scripts/run-audit.sh:133:Throw patterns and stubs: ${COUNT_THROWS}
/Users/davehail/Developer/inkwell/SESSION_SUMMARY.md:364:- See `src/adapters/README.md` for adapter usage (TODO: create this)
/Users/davehail/Developer/inkwell/SESSION_SUMMARY.md:365:- See `src/model/README.md` for gateway usage (TODO: create this)
/Users/davehail/Developer/inkwell/src/services/index.ts:1:// src/services/index.ts - Export search service export { storageService } from './storageService'; export { exportService } from './exportService'; export { searchService } from './searchService'; // Add this export export { ProfessionalExportService, EXPORT_TEMPLATES } from './professionalExportService'; 
/Users/davehail/Developer/inkwell/docs/ops/04-security.md:66:2. Check for stale TODOs (older than 30 days)
/Users/davehail/Developer/inkwell/src/services/__mocks__/SnapshotService.ts:18:  /** For tests that stub this. Default throws to make stubbing obvious. */
/Users/davehail/Developer/inkwell/src/services/__mocks__/SnapshotService.ts:20:    throw new Error('readCurrentState not implemented. Tests should mock this.');
/Users/davehail/Developer/inkwell/src/services/aiPlotAnalysisService.test.ts:272:      // For now, history is not implemented, so should be empty
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:52:      // TODO: implement IndexedDB get logic
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:61:      // TODO: implement IndexedDB put logic
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:69:      // TODO: implement clear logic for one or all progress entries
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:76:    // TODO: implement get preferences logic
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:83:      // TODO: implement save preferences logic
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:90:    // TODO: implement get checklist logic
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:97:      // TODO: implement save checklist logic
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:104:    // TODO: implement get all progress logic
/Users/davehail/Developer/inkwell/src/services/tutorialStorage.ts:237:  // TODO: implement migration logic from LegacyTutorialStorage to IndexedDB
/Users/davehail/Developer/inkwell/src/services/backupServices.ts:1:// src/services/backupService.ts /** Renamed string union for process status */ export type BackupProcessStatus = 'idle' | 'saving' | 'success' | 'error' | 'retrying'; /** Object describing overall backup stats */ export interface BackupStats { totalBackups: number; totalSize: string; lastBackup: number | null; autoBackupEnabled: boolean; storageWarning: boolean; } /** State of the BackupManager */ export interface BackupManagerState { status: BackupProcessStatus; lastSuccess: number | null; error: string | null; retryCount: number; retryDelayMs: number; } /** Backup data structure */ export interface Backup { id: string; type?: 'auto' | 'manual' | 'emergency'; title?: string; description?: string; data: unknown; timestamp: number; size?: number; isCorrupted?: boolean; } type NotifyFn = (_message: string, _type?: 'info' | 'success' | 'error') => void; const BACKUPS_KEY = 'app_backups'; // Utility functions export async function _getBackups(): Promise<Backup[]> { try { const json = localStorage.getItem(BACKUPS_KEY); if (!json) return []; return JSON.parse(json) as Backup[]; } catch { return []; } } export async function _saveBackup(backup: Backup): Promise<void> { const backups = await getBackups(); backups.push(backup); localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups)); } export async function _restoreBackup( id: string, ): Promise<{ success: boolean; message?: string; error?: string }> { try { const backups = await getBackups(); const backup = backups.find((b) => b.id === id); if (!backup) { return { success: false, error: 'Backup not found' }; } // TODO: Implement actual restore logic based on your app's needs // This would typically involve restoring the backup.data to your app state devLog.debug('Restoring backup:', backup); return { success: true, message: 'Backup restored successfully' }; } catch (error) { return { success: false, error: `Failed to restore backup: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } export async function _deleteBackup( id: string, ): Promise<{ success: boolean; message?: string; error?: string }> { try { let backups = await getBackups(); const initialLength = backups.length; backups = backups.filter((b) => b.id !== id); if (backups.length === initialLength) { return { success: false, error: 'Backup not found' }; } localStorage.setItem(BACKUPS_KEY, JSON.stringify(backups)); return { success: true, message: 'Backup deleted successfully' }; } catch (error) { return { success: false, error: `Failed to delete backup: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } export async function _exportBackup( id: string, ): Promise<{ success: boolean; message?: string; error?: string }> { try { const backups = await getBackups(); const backup = backups.find((b) => b.id === id); if (!backup) return { success: false, error: 'Backup not found' }; const dataStr = JSON.stringify(backup, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `backup_${backup.id}_${new Date().toISOString().split('T')[0]}.json`; a.click(); URL.revokeObjectURL(url); return { success: true, message: 'Backup exported successfully' }; } catch (error) { return { success: false, error: `Failed to export backup: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } export async function _importBackup( file: File, ): Promise<{ success: boolean; message?: string; error?: string }> { try { const text = await file.text(); const backup: Backup = JSON.parse(text); // Validate backup structure if (!backup.id || !backup.timestamp || backup.data === undefined) { return { success: false, error: 'Invalid backup file format' }; } // Check if backup already exists const existingBackups = await getBackups(); if (existingBackups.some((b) => b.id === backup.id)) { return { success: false, error: 'Backup with this ID already exists' }; } await saveBackup(backup); return { success: true, message: 'Backup imported successfully' }; } catch (error) { return { success: false, error: `Failed to import backup: ${error instanceof Error ? error.message : 'Invalid file format'}`, }; } } export async function _clearAllBackups(): Promise<{ success: boolean; message?: string; error?: string; }> { try { localStorage.removeItem(BACKUPS_KEY); return { success: true, message: 'All backups cleared successfully' }; } catch (error) { return { success: false, error: `Failed to clear backups: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } export async function _getBackupStatus(): Promise<BackupStats> { const backups = await getBackups(); const totalSizeBytes = new Blob([JSON.stringify(backups)]).size; const formatSize = (bytes: number): string => { if (bytes < 1024) return `${bytes} B`; if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`; if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`; return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`; }; return { totalBackups: backups.length, totalSize: formatSize(totalSizeBytes), lastBackup: backups.length > 0 ? backups[backups.length - 1]!.timestamp : null, autoBackupEnabled: false, // TODO: Implement auto-backup functionality storageWarning: totalSizeBytes > 4 * 1024 * 1024, // Warn if over 4MB }; } // Auto-backup functionality - Fixed type issue let autoBackupInterval: ReturnType<typeof setInterval> | null = null; export function _startAutoBackup(_getAppData: () => string, getTitle: () => string, intervalMs: number = 300000, // Default 5 minutes ): void { if (autoBackupInterval) { stopAutoBackup(); } autoBackupInterval = setInterval(async () => { try { const backup: Backup = { id: `auto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, type: 'auto', title: getTitle(), description: 'Automatic backup', data: getAppData(), timestamp: Date.now(), }; await saveBackup(backup); devLog.debug('Auto-backup created successfully'); } catch (error) { devLog.error('Auto-backup failed:', error); } }, intervalMs); } export function _stopAutoBackup(): void { if (autoBackupInterval) { clearInterval(autoBackupInterval); autoBackupInterval = null; } } export async function _createManualBackup( data: unknown, title?: string, description?: string, ): Promise<{ success: boolean; backup?: Backup; error?: string }> { try { const backup: Backup = { id: `manual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, type: 'manual', title: title || 'Manual Backup', description: description || 'User-created backup', data, timestamp: Date.now(), size: new Blob([JSON.stringify(data)]).size, }; await saveBackup(backup); return { success: true, backup }; } catch (error) { return { success: false, error: `Failed to create backup: ${error instanceof Error ? error.message : 'Unknown error'}`, }; } } // Advanced BackupManager class for complex backup operations export class BackupManager { private state: BackupManagerState = { status: 'idle', lastSuccess: null, error: null, retryCount: 0, retryDelayMs: 1000, }; private isSaving = false; private maxRetries = 5; constructor( private backupFn: () => Promise<void>, private notify: NotifyFn, ) {} public getState(): BackupManagerState { return { ...this.state }; } public async listBackups(): Promise<Backup[]> { return getBackups(); } public async getStatus(): Promise<BackupStats> { return getBackupStatus(); } public async restoreBackup(id: string) { return restoreBackup(id); } public async deleteBackup(id: string) { return deleteBackup(id); } public async exportBackup(id: string) { return exportBackup(id); } public async importBackup(file: File) { return importBackup(file); } public async clearAllBackups() { return clearAllBackups(); } public async backup(): Promise<void> { if (this.isSaving) { this.notify('Backup already in progress. Please wait.', 'info'); return; } this.isSaving = true; this.updateStatus('saving'); this.notify('Starting backup...', 'info'); try { await this.backupFn(); this.updateStatus('success'); this.state.lastSuccess = Date.now(); this.state.error = null; this.state.retryCount = 0; this.state.retryDelayMs = 1000; this.notify('Backup successful!', 'success'); } catch (error: any) { this.state.error = error?.message || 'Unknown error'; this.updateStatus('error'); this.notify(`Backup failed: ${this.state.error}`, 'error'); await this.retryBackup(); } finally { this.isSaving = false; } } private async retryBackup(): Promise<void> { if (this.state.retryCount >= this.maxRetries) { this.notify('Maximum backup retry attempts reached. Please try again later.', 'error'); return; } this.state.retryCount++; this.updateStatus('retrying'); this.notify( `Retrying backup (#${this.state.retryCount}) in ${this.state.retryDelayMs / 1000} seconds...`, 'info', ); await this.delay(this.state.retryDelayMs); this.state.retryDelayMs *= 2; await this.backup(); } private updateStatus(status: BackupProcessStatus): void { this.state.status = status; } private delay(ms: number): Promise<void> { return new Promise((resolve) => setTimeout(resolve, ms)); } }
/Users/davehail/Developer/inkwell/scripts/audit/dep-triage.sh:12:  "@tiptap/extension-placeholder" "@tiptap/extension-typography" "@tiptap/pm"
/Users/davehail/Developer/inkwell/src/context/NavContext.tsx:276:      // TODO: Add validation logic here
/Users/davehail/Developer/inkwell/src/context/NavContext.tsx:299:      // TODO: Add validation logic here
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:96:      cloudStorageUsed: null, // TODO: Implement cloud storage tracking
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:98:      pendingSyncItems: 0, // TODO: Implement with sync queue
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:195:    // TODO: Implement actual migration logic
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:210:    // TODO: Implement actual migration logic
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:230:    // TODO: Implement backup logic
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:267:      // TODO: Implement actual sync logic
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:274:        itemCount: 0, // TODO: Track actual item count
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:310:      // TODO: Implement actual backup logic
/Users/davehail/Developer/inkwell/src/services/userPersistenceService.ts:317:        itemCount: 0, // TODO: Track actual item count
/Users/davehail/Developer/inkwell/src/styles/forms/inputs.css:1:/* Inputs */ .input-base { @apply block w-full rounded-lg border border-gray-300 px-3 py-2 text-sm placeholder-gray-400 shadow-sm transition-colors; } .input-focus { @apply focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500; } .input-error { @apply border-red-300 focus:border-red-500 focus:ring-red-500; } 
/Users/davehail/Developer/inkwell/docs/test-coverage-summary.md:82:| **tutorialStorage**               | TBD   | 🔜 Planned        | localStorage helpers, migrations               |
/Users/davehail/Developer/inkwell/src/types/writing.ts:41:/** @deprecated Use Chapter.content instead of nested scenes */
/Users/davehail/Developer/inkwell/src/types/writing.ts:44:/** @deprecated Scene-based writing is deprecated - use chapters directly */
/Users/davehail/Developer/inkwell/src/App.css:62:  content: attr(data-placeholder);
/Users/davehail/Developer/inkwell/src/types/index.ts:51: * @deprecated Scene-based writing is deprecated.
/Users/davehail/Developer/inkwell/src/types/index.ts:58: * @deprecated Use EnhancedProject instead
/Users/davehail/Developer/inkwell/src/services/supabaseSync.ts:75:      pendingChanges: 0, // TODO: Implement pending changes tracking
/Users/davehail/Developer/inkwell/src/services/supabaseSync.ts:228:        conflicts: [], // TODO: Implement conflict detection
/Users/davehail/Developer/inkwell/src/adapters/sceneToChapter.ts:13: * @deprecated Use Chapter from types/project.ts instead
/Users/davehail/Developer/inkwell/src/adapters/chapterToLegacyScene.ts:7: * @deprecated This adapter exists only for backwards compatibility
/Users/davehail/Developer/inkwell/ICON_REPLACEMENT_SUMMARY.md:36:   - Replaced BookOpen in writing interface placeholder
/Users/davehail/Developer/inkwell/src/services/__tests__/connectivityService.test.ts:8:    vi.stubGlobal('navigator', {
/Users/davehail/Developer/inkwell/src/services/__tests__/connectivityService.test.ts:244:    it('should handle navigator.onLine stubbing', () => {
/Users/davehail/Developer/inkwell/src/services/__tests__/connectivityService.test.ts:246:      vi.stubGlobal('navigator', {
/Users/davehail/Developer/inkwell/scripts/rollout-workflow-improvements.sh:100:echo "2. Use the PR template from docs/engineering/PR_TEMPLATE.md"
/Users/davehail/Developer/inkwell/src/pages/Login.tsx:225:                placeholder="you@example.com"
/Users/davehail/Developer/inkwell/src/exports/exportEngines/docxEngine.ts:10: * TODO: Upgrade to true DOCX generation using a library like docx.js
/Users/davehail/Developer/inkwell/src/exports/exportEngines/docxEngine.ts:24:      tableOfContents: false, // TODO: Implement
/Users/davehail/Developer/inkwell/FINAL_OPERATIONAL_CHECKLIST.md:29:- [x] `docs/PR_TEMPLATE_TOUR_CHECKLIST.md`
/Users/davehail/Developer/inkwell/FINAL_OPERATIONAL_CHECKLIST.md:329:- PR guide: `docs/PR_TEMPLATE_TOUR_CHECKLIST.md`
/Users/davehail/Developer/inkwell/src/exports/exportEngines/epubEngine.ts:10: * TODO: Generate proper EPUB zip with metadata, CSS, and structure
/Users/davehail/Developer/inkwell/docs/BEGINNER_MODE_INTEGRATION.md:449:| **Starter Templates**        | ✅ Yes       | Data configuration  | Template sets filtered by `VITE_CUSTOM_TEMPLATES_ENABLED`        |
/Users/davehail/Developer/inkwell/WORLD_BUILDING_IMPLEMENTATION.md:24:- Replace placeholder with functional component
/Users/davehail/Developer/inkwell/src/types/project.ts:68:  personality: string[]; // e.g., ['curious', 'stubborn']
/Users/davehail/Developer/inkwell/src/types/project.ts:122:  // TODO v0.7.0: Remove these after all components are migrated
/Users/davehail/Developer/inkwell/src/types/project.ts:123:  /** @deprecated Use content property instead - scenes model is deprecated */
/Users/davehail/Developer/inkwell/src/types/project.ts:125:  /** @deprecated Use wordCount property instead */
/Users/davehail/Developer/inkwell/src/types/project.ts:187:  // TODO v0.7.0: Make these required again after migration complete
/Users/davehail/Developer/inkwell/docs/TOUR_DEVTOOLS_REFERENCE.md:218:- [PR Checklist](./PR_TEMPLATE_TOUR_CHECKLIST.md)
/Users/davehail/Developer/inkwell/src/services/mockAIService.ts:336:    // Replace placeholders with context if available
/Users/davehail/Developer/inkwell/src/features/preview/PreviewWriter.tsx:199:                placeholder="Start writing..."
/Users/davehail/Developer/inkwell/scripts/ci/check-ship-blockers.sh:6:PATTERN='TODO\[SHIP\]|FIXME\[SHIP\]|HACK\[SHIP\]'
/Users/davehail/Developer/inkwell/src/services/exportService.ts:281:  // Export as DOCX (placeholder implementation)
/Users/davehail/Developer/inkwell/src/features/plotboards/store.ts:18:  DEFAULT_PLOT_TEMPLATES,
/Users/davehail/Developer/inkwell/src/features/plotboards/store.ts:186:  templates: DEFAULT_PLOT_TEMPLATES.reduce(
/Users/davehail/Developer/inkwell/src/setupTests.ts:68:// ------------ BroadcastChannel: idempotent stub ------------
/Users/davehail/Developer/inkwell/src/setupTests.ts:70:  // simple flag so we don't re-declare the stub if setupFiles are loaded twice
/Users/davehail/Developer/inkwell/src/setupTests.ts:90:  // If the environment already has a BC, don't overwrite unless you want to force the stub.
/Users/davehail/Developer/inkwell/src/data/sampleProject.ts:105:export const PROJECT_TEMPLATES = {
/Users/davehail/Developer/inkwell/src/services/analyticsService.ts:859:/** @deprecated Use trackEvent instead */
/Users/davehail/Developer/inkwell/src/data/dbFactory.ts:2:// Minimal, safe stubs (replace with your real implementation if you have it)
/Users/davehail/Developer/inkwell/src/services/enhancedSearchService.mainthread.test.ts:5:// We'll stub storageService that enhancedSearchService uses internally
/Users/davehail/Developer/inkwell/SPOTLIGHT_TOUR_PHASE2_INTEGRATION_COMPLETE.md:330:1. Connect real analytics service (replace placeholder)
/Users/davehail/Developer/inkwell/src/services/SnapshotServiceImpl.ts:227:    throw new Error('readCurrentState not implemented');
/Users/davehail/Developer/inkwell/src/features/plotboards/import/importSystem.ts:1:// Enhanced Plot Boards Import System // Supports validation, conflict resolution, schema migration, and merge capabilities import { trace } from '../../../utils/trace'; import { ExportBundle, ExportFormat } from '../export/exportSystem'; import { SchemaVersionManager } from '../schema/versioning'; import { PlotBoard, PlotColumn, PlotBoardTemplate } from '../types'; import { SavedViewData } from '../views/savedViews'; /* ========= Import Types ========= */ export interface ImportOptions { mergeStrategy?: MergeStrategy; conflictResolution?: ConflictResolution; validateSchema?: boolean; autoMigrate?: boolean; createBackup?: boolean; allowOverwrite?: boolean; preserveIds?: boolean; importViews?: boolean; importTemplates?: boolean; importSettings?: boolean; } export enum MergeStrategy { REPLACE = 'replace', // Replace entire board MERGE = 'merge', // Merge data intelligently APPEND = 'append', // Add as new columns/cards } export enum ConflictResolution { SKIP = 'skip', // Skip conflicting items OVERWRITE = 'overwrite', // Overwrite existing items RENAME = 'rename', // Rename conflicting items MANUAL = 'manual', // Require manual resolution } export interface ImportResult { success: boolean; board?: PlotBoard; views?: SavedViewData[]; templates?: PlotBoardTemplate[]; metadata?: ImportMetadata; conflicts?: ImportConflict[]; errors?: string[]; warnings?: string[]; migration?: MigrationInfo; } export interface ImportMetadata { importedAt: string; originalSchema: string; targetSchema: string; sourceFormat: ExportFormat; itemsImported: { boards: number; columns: number; cards: number; views: number; templates: number; }; conflicts: number; warnings: number; } export interface ImportConflict { type: ConflictType; item: string; existing: any; incoming: any; resolution?: ConflictResolution; resolved?: boolean; } export enum ConflictType { BOARD_EXISTS = 'board_exists', COLUMN_EXISTS = 'column_exists', CARD_EXISTS = 'card_exists', VIEW_EXISTS = 'view_exists', TEMPLATE_EXISTS = 'template_exists', SCHEMA_MISMATCH = 'schema_mismatch', ID_COLLISION = 'id_collision', } export interface MigrationInfo { required: boolean; fromVersion: string; toVersion: string; changes: string[]; warnings: string[]; } /* ========= Import System Class ========= */ export class PlotBoardImportSystem { private schemaManager = new SchemaVersionManager(); /** * Import plot board data from various formats */ async importData( data: string | ExportBundle, existingBoard?: PlotBoard, options: Partial<ImportOptions> = {}, ): Promise<ImportResult> { const opts: ImportOptions = { mergeStrategy: MergeStrategy.REPLACE, conflictResolution: ConflictResolution.SKIP, validateSchema: true, autoMigrate: true, createBackup: true, allowOverwrite: false, preserveIds: true, importViews: true, importTemplates: false, importSettings: true, ...options, }; try { trace.log('Starting import', 'user_action', 'info', { options: opts }); // Parse data const bundle = typeof data === 'string' ? this.parseImportData(data) : data; if (!bundle) { throw new Error('Invalid import data format'); } // Validate and migrate schema if needed const migrationResult = await this.handleSchemaMigration(bundle, opts); if (migrationResult.errors && migrationResult.errors.length > 0 && opts.validateSchema) { throw new Error(`Schema migration failed: ${migrationResult.errors.join(', ')}`); } // Detect conflicts const conflicts = existingBoard ? await this.detectConflicts(bundle, existingBoard, opts) : []; // Resolve conflicts if (conflicts.length > 0) { await this.resolveConflicts(conflicts, opts.conflictResolution!); } // Perform import based on merge strategy const importResult = await this.performImport(bundle, existingBoard, conflicts, opts); return { success: true, ...importResult, conflicts, migration: migrationResult.migration, metadata: { importedAt: new Date().toISOString(), originalSchema: bundle.metadata?.schemaVersion || 'unknown', targetSchema: this.schemaManager.getCurrentVersion(), sourceFormat: bundle.metadata?.format || ExportFormat.JSON, itemsImported: { boards: importResult.board ? 1 : 0, columns: importResult.board?.columns.length || 0, cards: importResult.board?.columns.reduce((sum, _col) => sum + col.cards.length, 0) || 0, views: importResult.views?.length || 0, templates: importResult.templates?.length || 0, }, conflicts: conflicts.length, warnings: importResult.warnings?.length || 0, }, }; } catch (error) { trace.log('Import failed', 'user_action', 'error', { error }); return { success: false, errors: [error instanceof Error ? error.message : 'Import failed'], }; } } /** * Import from file */ async importFromFile( file: File, existingBoard?: PlotBoard, options: Partial<ImportOptions> = {}, ): Promise<ImportResult> { try { const text = await this.readFileAsText(file); return await this.importData(text, existingBoard, options); } catch (error) { return { success: false, errors: [ `Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`, ], }; } } /** * Parse import data from string */ private parseImportData(data: string): ExportBundle | null { try { const parsed = JSON.parse(data); // Check if it's a full export bundle if (parsed.metadata && parsed.board) { return parsed as ExportBundle; } // Check if it's just a board if (parsed.id && parsed.projectId && parsed.columns) { return { metadata: { exportedAt: new Date().toISOString(), schemaVersion: 'unknown', format: ExportFormat.JSON, boardId: parsed.id, boardTitle: parsed.title || 'Imported Board', cardsCount: parsed.columns?.reduce( (sum: number, _col: any) => sum + (col.cards?.length || 0), 0, ) || 0, columnsCount: parsed.columns?.length || 0, totalSize: new Blob([data]).size, checksum: '', }, board: parsed, }; } // Check if it's a template if (parsed.name && parsed.columns && parsed.category) { const board: PlotBoard = { id: `board_${Date.now()}`, projectId: 'imported', title: parsed.name, description: parsed.description, columns: parsed.columns.map((colTemplate: any, _index: number) => ({ id: `col_${Date.now()}_${index}`, boardId: `board_${Date.now()}`, title: colTemplate.title, description: colTemplate.description, color: colTemplate.color, order: colTemplate.order || index, cards: (colTemplate.defaultCards || []).map((cardTemplate: any, _cardIndex: number) => ({ id: `card_${Date.now()}_${index}_${cardIndex}`, columnId: `col_${Date.now()}_${index}`, title: cardTemplate.title, description: cardTemplate.description, order: cardIndex, status: cardTemplate.status, priority: cardTemplate.priority, tags: cardTemplate.tags || [], createdAt: new Date(), updatedAt: new Date(), })), type: colTemplate.type, settings: { autoColor: true, showCardCount: true, collapsible: false, sortBy: 'order', showProgress: true, }, })), settings: { showWordCounts: true, showTimeline: true, showCharacters: true, colorScheme: 'auto', compactView: false, enableQuickActions: true, }, createdAt: new Date(), updatedAt: new Date(), }; return { metadata: { exportedAt: new Date().toISOString(), schemaVersion: 'template', format: ExportFormat.TEMPLATE, boardId: board.id, boardTitle: board.title, cardsCount: board.columns.reduce((sum, _col) => sum + col.cards.length, 0), columnsCount: board.columns.length, totalSize: new Blob([data]).size, checksum: '', }, board, }; } return null; } catch (error) { trace.log('Failed to parse import data', 'user_action', 'error', { error }); return null; } } /** * Handle schema migration */ private async handleSchemaMigration( bundle: ExportBundle, options: ImportOptions, ): Promise<{ migration?: MigrationInfo; errors?: string[] }> { if (!options.validateSchema) { return {}; } const sourceVersion = bundle.metadata?.schemaVersion || 'unknown'; const currentVersion = this.schemaManager.getCurrentVersion(); if (sourceVersion === 'unknown') { return { migration: { required: false, fromVersion: sourceVersion, toVersion: currentVersion, changes: [], warnings: ['Source schema version is unknown - skipping migration'], }, }; } if (this.schemaManager.compareVersions(sourceVersion, currentVersion) === 0) { return {}; // No migration needed } if (options.autoMigrate) { try { const migrationResult = await this.schemaManager.migrate(bundle); return { migration: { required: true, fromVersion: sourceVersion, toVersion: currentVersion, changes: [`Migrated from ${sourceVersion} to ${currentVersion}`], warnings: migrationResult.warnings || [], }, }; } catch (error) { return { errors: [`Migration failed: ${error instanceof Error ? error.message : 'Unknown error'}`], }; } } return { migration: { required: true, fromVersion: sourceVersion, toVersion: currentVersion, changes: ['Manual migration required'], warnings: ['Auto-migration is disabled'], }, }; } /** * Detect conflicts between imported data and existing data */ private async detectConflicts( bundle: ExportBundle, existingBoard: PlotBoard, options: ImportOptions, ): Promise<ImportConflict[]> { const conflicts: ImportConflict[] = []; // Board-level conflicts if (bundle.board.id === existingBoard.id && !options.allowOverwrite) { conflicts.push({ type: ConflictType.BOARD_EXISTS, item: `Board: ${bundle.board.title}`, existing: existingBoard, incoming: bundle.board, }); } // Column conflicts for (const incomingColumn of bundle.board.columns) { const existingColumn = existingBoard.columns.find( (col) => col.id === incomingColumn.id || col.title === incomingColumn.title, ); if (existingColumn) { conflicts.push({ type: ConflictType.COLUMN_EXISTS, item: `Column: ${incomingColumn.title}`, existing: existingColumn, incoming: incomingColumn, }); // Card conflicts within columns for (const incomingCard of incomingColumn.cards) { const existingCard = existingColumn.cards.find( (card) => card.id === incomingCard.id || (card.title === incomingCard.title && card.sceneId === incomingCard.sceneId), ); if (existingCard) { conflicts.push({ type: ConflictType.CARD_EXISTS, item: `Card: ${incomingCard.title}`, existing: existingCard, incoming: incomingCard, }); } } } } return conflicts; } /** * Resolve conflicts based on resolution strategy */ private async resolveConflicts( conflicts: ImportConflict[], resolution: ConflictResolution, ): Promise<void> { for (const conflict of conflicts) { switch (resolution) { case ConflictResolution.SKIP: conflict.resolution = ConflictResolution.SKIP; conflict.resolved = true; break; case ConflictResolution.OVERWRITE: conflict.resolution = ConflictResolution.OVERWRITE; conflict.resolved = true; break; case ConflictResolution.RENAME: conflict.resolution = ConflictResolution.RENAME; conflict.resolved = true; // Rename the incoming item if (conflict.type === ConflictType.COLUMN_EXISTS) { conflict.incoming.title = `${conflict.incoming.title} (Imported)`; conflict.incoming.id = `${conflict.incoming.id}_imported_${Date.now()}`; } else if (conflict.type === ConflictType.CARD_EXISTS) { conflict.incoming.title = `${conflict.incoming.title} (Imported)`; conflict.incoming.id = `${conflict.incoming.id}_imported_${Date.now()}`; } break; case ConflictResolution.MANUAL: conflict.resolution = ConflictResolution.MANUAL; conflict.resolved = false; break; default: conflict.resolution = ConflictResolution.SKIP; conflict.resolved = true; } } } /** * Perform the actual import based on strategy */ private async performImport( bundle: ExportBundle, existingBoard: PlotBoard | undefined, conflicts: ImportConflict[], options: ImportOptions, ): Promise<{ board?: PlotBoard; views?: SavedViewData[]; templates?: PlotBoardTemplate[]; warnings?: string[]; }> { const warnings: string[] = []; let resultBoard: PlotBoard; let resultViews: SavedViewData[] = []; let resultTemplates: PlotBoardTemplate[] = []; // Handle board import based on merge strategy switch (options.mergeStrategy) { case MergeStrategy.REPLACE: resultBoard = bundle.board; break; case MergeStrategy.MERGE: if (existingBoard) { resultBoard = await this.mergeBoards(existingBoard, bundle.board, conflicts, options); } else { resultBoard = bundle.board; } break; case MergeStrategy.APPEND: if (existingBoard) { resultBoard = await this.appendToBoard(existingBoard, bundle.board, conflicts, options); } else { resultBoard = bundle.board; } break; default: resultBoard = bundle.board; } // Import views if requested if (options.importViews && bundle.views) { resultViews = bundle.views.map((view) => ({ ...view, view: { ...view.view, boardId: resultBoard.id, id: options.preserveIds ? view.view.id : `view_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, }, })); } // Import templates if requested if (options.importTemplates && bundle.templates) { resultTemplates = bundle.templates.map((template) => ({ ...template, id: options.preserveIds ? template.id : `template_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, isBuiltIn: false, // Imported templates are never built-in })); } // Add warnings for unresolved conflicts const unresolvedConflicts = conflicts.filter((c) => !c.resolved); if (unresolvedConflicts.length > 0) { warnings.push(`${unresolvedConflicts.length} conflicts require manual resolution`); } return { board: resultBoard, views: resultViews, templates: resultTemplates, warnings, }; } /** * Merge two boards intelligently */ private async mergeBoards( existingBoard: PlotBoard, incomingBoard: PlotBoard, conflicts: ImportConflict[], _options: ImportOptions, ): Promise<PlotBoard> { const mergedBoard: PlotBoard = { ...existingBoard, title: incomingBoard.title || existingBoard.title, description: incomingBoard.description || existingBoard.description, updatedAt: new Date(), }; // Merge columns const existingColumnMap = new Map(existingBoard.columns.map((col) => [col.id, col])); const mergedColumns: PlotColumn[] = [...existingBoard.columns]; for (const incomingColumn of incomingBoard.columns) { const conflict = conflicts.find( (c) => c.type === ConflictType.COLUMN_EXISTS && c.incoming === incomingColumn, ); if (conflict && conflict.resolution === ConflictResolution.SKIP) { continue; } if (conflict && conflict.resolution === ConflictResolution.OVERWRITE) { const index = mergedColumns.findIndex((col) => col.id === incomingColumn.id); if (index !== -1) { mergedColumns[index] = incomingColumn; } } else if (!existingColumnMap.has(incomingColumn.id)) { mergedColumns.push({ ...incomingColumn, boardId: mergedBoard.id, order: mergedColumns.length, }); } } mergedBoard.columns = mergedColumns; return mergedBoard; } /** * Append incoming data to existing board as new columns */ private async appendToBoard( existingBoard: PlotBoard, incomingBoard: PlotBoard, _conflicts: ImportConflict[], _options: ImportOptions, ): Promise<PlotBoard> { const appendedBoard: PlotBoard = { ...existingBoard, updatedAt: new Date(), }; const newColumns = incomingBoard.columns.map((column, _index) => ({ ...column, id: `${column.id}_appended_${Date.now()}`, boardId: appendedBoard.id, order: existingBoard.columns.length + index, cards: column.cards.map((card) => ({ ...card, id: `${card.id}_appended_${Date.now()}`, columnId: `${column.id}_appended_${Date.now()}`, })), })); appendedBoard.columns = [...existingBoard.columns, ...newColumns]; return appendedBoard; } /** * Utility: Read file as text */ private readFileAsText(file: File): Promise<string> { return new Promise((resolve, _reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result as string); reader.onerror = () => reject(reader.error); reader.readAsText(file); }); } /** * Preview import without actually importing */ async previewImport( data: string | ExportBundle, existingBoard?: PlotBoard, options: Partial<ImportOptions> = {}, ): Promise<{ preview: { boardTitle: string; columnsCount: number; cardsCount: number; viewsCount: number; templatesCount: number; }; conflicts: ImportConflict[]; migration?: MigrationInfo; errors?: string[]; }> { try { const bundle = typeof data === 'string' ? this.parseImportData(data) : data; if (!bundle) { throw new Error('Invalid import data format'); } const conflicts = existingBoard ? await this.detectConflicts(bundle, existingBoard, options as ImportOptions) : []; const migrationResult = await this.handleSchemaMigration(bundle, options as ImportOptions); return { preview: { boardTitle: bundle.board.title, columnsCount: bundle.board.columns.length, cardsCount: bundle.board.columns.reduce((sum, _col) => sum + col.cards.length, 0), viewsCount: bundle.views?.length || 0, templatesCount: bundle.templates?.length || 0, }, conflicts, migration: migrationResult.migration, errors: migrationResult.errors, }; } catch (error) { return { preview: { boardTitle: '', columnsCount: 0, cardsCount: 0, viewsCount: 0, templatesCount: 0, }, conflicts: [], errors: [error instanceof Error ? error.message : 'Preview failed'], }; } } } // Export singleton instance export const plotBoardImportSystem = new PlotBoardImportSystem();
/Users/davehail/Developer/inkwell/TOUR_DATA_ATTRIBUTES_IMPLEMENTATION.md:70:2. Replaced placeholder tour card with actual `<TourCompletionCard />` component
/Users/davehail/Developer/inkwell/docs/PHASE_1_INTEGRATION_COMPLETE.md:143:- ⏳ TODO: Reopening project returns to last active chapter (localStorage)
/Users/davehail/Developer/inkwell/docs/PHASE_1_INTEGRATION_COMPLETE.md:144:- ⏳ TODO: Writing header shows "Saving…" then "Saved X min ago"
/Users/davehail/Developer/inkwell/src/features/plotboards/export/exportSystem.ts:1:// Enhanced Plot Boards Export System // Supports multiple formats with validation and metadata import { trace } from '../../../utils/trace'; import { CURRENT_SCHEMA_VERSION } from '../schema/versioning'; import { PlotBoard, PlotBoardTemplate } from '../types'; import { SavedViewData } from '../views/savedViews'; /* ========= Export Types ========= */ export interface ExportOptions { format: ExportFormat; includeViews?: boolean; includeTemplates?: boolean; includeMetadata?: boolean; includeCards?: boolean; includeSettings?: boolean; compression?: boolean; validate?: boolean; } export enum ExportFormat { JSON = 'json', MARKDOWN = 'markdown', CSV = 'csv', YAML = 'yaml', TEMPLATE = 'template', } export interface ExportResult { success: boolean; data?: string; filename: string; mimeType: string; size: number; metadata: ExportMetadata; errors?: string[]; warnings?: string[]; } export interface ExportMetadata { exportedAt: string; schemaVersion: string; format: ExportFormat; boardId: string; boardTitle: string; cardsCount: number; columnsCount: number; viewsCount?: number; templatesCount?: number; totalSize: number; checksum: string; } export interface ExportBundle { metadata: ExportMetadata; board: PlotBoard; views?: SavedViewData[]; templates?: PlotBoardTemplate[]; settings?: any; } /* ========= Export System Class ========= */ export class PlotBoardExportSystem { private generateChecksum(data: string): string { // Simple checksum for data integrity let hash = 0; for (let i = 0; i < data.length; i++) { const char = data.charCodeAt(i); hash = (hash << 5) - hash + char; hash = hash & hash; // Convert to 32-bit integer } return Math.abs(hash).toString(16); } private sanitizeFilename(name: string): string { return name .replace(/[^a-z0-9]/gi, '-') .replace(/-+/g, '-') .replace(/^-|-$/g, '') .toLowerCase(); } /** * Export a complete plot board with all data */ async exportBoard( board: PlotBoard, views: SavedViewData[] = [], templates: PlotBoardTemplate[] = [], options: Partial<ExportOptions> = {}, ): Promise<ExportResult> { const opts: ExportOptions = { format: ExportFormat.JSON, includeViews: true, includeTemplates: false, includeMetadata: true, includeCards: true, includeSettings: true, compression: false, validate: true, ...options, }; try { trace.log('Exporting board', 'user_action', 'info', { boardId: board.id, format: opts.format, options: opts, }); let exportData: string; let mimeType: string; let fileExtension: string; switch (opts.format) { case ExportFormat.JSON: const result = await this.exportAsJSON(board, views, templates, opts); exportData = result.data; mimeType = result.mimeType; fileExtension = 'json'; break; case ExportFormat.MARKDOWN: const mdResult = await this.exportAsMarkdown(board, opts); exportData = mdResult.data; mimeType = mdResult.mimeType; fileExtension = 'md'; break; case ExportFormat.CSV: const csvResult = await this.exportAsCSV(board, opts); exportData = csvResult.data; mimeType = csvResult.mimeType; fileExtension = 'csv'; break; case ExportFormat.YAML: const yamlResult = await this.exportAsYAML(board, views, templates, opts); exportData = yamlResult.data; mimeType = yamlResult.mimeType; fileExtension = 'yaml'; break; case ExportFormat.TEMPLATE: const templateResult = await this.exportAsTemplate(board, opts); exportData = templateResult.data; mimeType = templateResult.mimeType; fileExtension = 'json'; break; default: throw new Error(`Unsupported export format: ${opts.format}`); } // Generate metadata const metadata: ExportMetadata = { exportedAt: new Date().toISOString(), schemaVersion: CURRENT_SCHEMA_VERSION, format: opts.format, boardId: board.id, boardTitle: board.title, cardsCount: board.columns.reduce((sum, _col) => sum + col.cards.length, 0), columnsCount: board.columns.length, viewsCount: opts.includeViews ? views.length : undefined, templatesCount: opts.includeTemplates ? templates.length : undefined, totalSize: new Blob([exportData]).size, checksum: this.generateChecksum(exportData), }; // Generate filename const timestamp = new Date().toISOString().slice(0, 10); const safeBoardTitle = this.sanitizeFilename(board.title); const filename = `${safeBoardTitle}-${timestamp}.${fileExtension}`; return { success: true, data: exportData, filename, mimeType, size: metadata.totalSize, metadata, errors: [], warnings: [], }; } catch (error) { trace.log('Export failed', 'user_action', 'error', { error }); return { success: false, filename: '', mimeType: '', size: 0, metadata: { exportedAt: new Date().toISOString(), schemaVersion: CURRENT_SCHEMA_VERSION, format: opts.format, boardId: board.id, boardTitle: board.title, cardsCount: 0, columnsCount: 0, totalSize: 0, checksum: '', }, errors: [error instanceof Error ? error.message : 'Export failed'], }; } } /** * Export as JSON format */ private async exportAsJSON( board: PlotBoard, views: SavedViewData[], templates: PlotBoardTemplate[], options: ExportOptions, ): Promise<{ data: string; mimeType: string }> { const bundle: ExportBundle = { metadata: { exportedAt: new Date().toISOString(), schemaVersion: CURRENT_SCHEMA_VERSION, format: ExportFormat.JSON, boardId: board.id, boardTitle: board.title, cardsCount: board.columns.reduce((sum, _col) => sum + col.cards.length, 0), columnsCount: board.columns.length, viewsCount: options.includeViews ? views.length : undefined, templatesCount: options.includeTemplates ? templates.length : undefined, totalSize: 0, checksum: '', }, board: options.includeCards ? board : { ...board, columns: board.columns.map((col) => ({ ...col, cards: [], // Exclude cards if requested })), }, }; if (options.includeViews) { bundle.views = views; } if (options.includeTemplates) { bundle.templates = templates; } if (options.includeSettings) { bundle.settings = { boardSettings: board.settings, columnSettings: board.columns.map((col) => ({ columnId: col.id, settings: col.settings, })), }; } const data = JSON.stringify(bundle, null, 2); bundle.metadata.totalSize = new Blob([data]).size; bundle.metadata.checksum = this.generateChecksum(data); return { data: JSON.stringify(bundle, null, 2), mimeType: 'application/json', }; } /** * Export as Markdown format */ private async exportAsMarkdown( board: PlotBoard, options: ExportOptions, ): Promise<{ data: string; mimeType: string }> { let markdown = `# ${board.title}\n\n`; if (board.description) { markdown += `${board.description}\n\n`; } // Metadata if (options.includeMetadata) { markdown += `## Board Information\n\n`; markdown += `- **Created**: ${board.createdAt.toLocaleDateString()}\n`; markdown += `- **Updated**: ${board.updatedAt.toLocaleDateString()}\n`; markdown += `- **Columns**: ${board.columns.length}\n`; markdown += `- **Total Cards**: ${board.columns.reduce((sum, _col) => sum + col.cards.length, 0)}\n`; markdown += `- **Project ID**: ${board.projectId}\n\n`; markdown += `---\n\n`; } // Columns and Cards board.columns .sort((a, _b) => a.order - b.order) .forEach((column) => { markdown += `## ${column.title}\n\n`; if (column.description) { markdown += `*${column.description}*\n\n`; } if (options.includeCards && column.cards.length > 0) { column.cards .sort((a, _b) => a.order - b.order) .forEach((card) => { markdown += `### ${card.title}\n\n`; if (card.description) { markdown += `${card.description}\n\n`; } markdown += `- **Status**: ${card.status}\n`; markdown += `- **Priority**: ${card.priority}\n`; if (card.tags.length > 0) { markdown += `- **Tags**: ${card.tags.join(', ')}\n`; } if (card.wordCount) { markdown += `- **Word Count**: ${card.wordCount}\n`; } if (card.notes) { markdown += `\n**Notes**: ${card.notes}\n`; } markdown += `\n---\n\n`; }); } else if (options.includeCards) { markdown += `*No cards in this column*\n\n`; } }); return { data: markdown, mimeType: 'text/markdown', }; } /** * Export as CSV format (cards only) */ private async exportAsCSV( board: PlotBoard, _options: ExportOptions, ): Promise<{ data: string; mimeType: string }> { const headers = [ 'Card Title', 'Description', 'Column', 'Status', 'Priority', 'Tags', 'Word Count', 'Order', 'Created', 'Updated', 'Scene ID', 'Chapter ID', 'Notes', ]; let csv = headers.join(',') + '\n'; board.columns .sort((a, _b) => a.order - b.order) .forEach((column) => { column.cards .sort((a, _b) => a.order - b.order) .forEach((card) => { const row = [ this.escapeCSV(card.title), this.escapeCSV(card.description || ''), this.escapeCSV(column.title), card.status, card.priority, this.escapeCSV(card.tags.join('; ')), card.wordCount || 0, card.order, card.createdAt.toISOString(), card.updatedAt.toISOString(), card.sceneId || '', card.chapterId || '', this.escapeCSV(card.notes || ''), ]; csv += row.join(',') + '\n'; }); }); return { data: csv, mimeType: 'text/csv', }; } /** * Export as YAML format */ private async exportAsYAML( board: PlotBoard, views: SavedViewData[], templates: PlotBoardTemplate[], options: ExportOptions, ): Promise<{ data: string; mimeType: string }> { // Simple YAML serialization for board data let yaml = `title: "${board.title}"\n`; yaml += `id: "${board.id}"\n`; yaml += `project_id: "${board.projectId}"\n`; yaml += `created_at: "${board.createdAt.toISOString()}"\n`; yaml += `updated_at: "${board.updatedAt.toISOString()}"\n\n`; if (board.description) { yaml += `description: "${board.description}"\n\n`; } yaml += `columns:\n`; board.columns .sort((a, _b) => a.order - b.order) .forEach((column) => { yaml += ` - title: "${column.title}"\n`; yaml += ` id: "${column.id}"\n`; yaml += ` type: "${column.type}"\n`; yaml += ` color: "${column.color}"\n`; yaml += ` order: ${column.order}\n`; if (column.description) { yaml += ` description: "${column.description}"\n`; } if (options.includeCards && column.cards.length > 0) { yaml += ` cards:\n`; column.cards .sort((a, _b) => a.order - b.order) .forEach((card) => { yaml += ` - title: "${card.title}"\n`; yaml += ` id: "${card.id}"\n`; yaml += ` status: "${card.status}"\n`; yaml += ` priority: "${card.priority}"\n`; yaml += ` order: ${card.order}\n`; if (card.description) { yaml += ` description: "${card.description}"\n`; } if (card.tags.length > 0) { yaml += ` tags: [${card.tags.map((tag) => `"${tag}"`).join(', ')}]\n`; } if (card.wordCount) { yaml += ` word_count: ${card.wordCount}\n`; } }); } }); return { data: yaml, mimeType: 'application/x-yaml', }; } /** * Export as reusable template */ private async exportAsTemplate( board: PlotBoard, options: ExportOptions, ): Promise<{ data: string; mimeType: string }> { const template: PlotBoardTemplate = { id: `template_${Date.now()}`, name: `${board.title} Template`, description: board.description || `Template created from ${board.title}`, category: 'custom' as any, tags: ['custom', 'exported'], isBuiltIn: false, columns: board.columns.map((column) => ({ title: column.title, _description: column.description || '', _type: column.type, _color: column.color, _order: column.order, _defaultCards: options.includeCards ? column.cards.map((card) => ({ title: card.title, description: card.description || '', status: card.status, priority: card.priority, tags: card.tags, })) : [], })), }; return { data: JSON.stringify(template, null, 2), mimeType: 'application/json', }; } /** * Utility: Escape CSV values */ private escapeCSV(value: string): string { if (value.includes(',') || value.includes('"') || value.includes('\n')) { return `"${value.replace(/"/g, '""')}"`; } return value; } /** * Download exported data */ async downloadExport(exportResult: ExportResult): Promise<void> { if (!exportResult.success || !exportResult.data) { throw new Error('Export failed - no data to download'); } try { const blob = new Blob([exportResult.data], { type: exportResult.mimeType }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = exportResult.filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); // Cleanup setTimeout(() => URL.revokeObjectURL(url), 1000); trace.log('Download initiated', 'user_action', 'info', { filename: exportResult.filename, size: exportResult.size, }); } catch (error) { trace.log('Download failed', 'user_action', 'error', { error }); throw new Error(`Download failed: ${error}`); } } /** * Validate export data integrity */ validateExport(exportResult: ExportResult): { valid: boolean; errors: string[] } { const errors: string[] = []; if (!exportResult.data) { errors.push('Export data is empty'); } if (!exportResult.metadata) { errors.push('Export metadata is missing'); } if (exportResult.metadata) { // Verify checksum const calculatedChecksum = this.generateChecksum(exportResult.data || ''); if (calculatedChecksum !== exportResult.metadata.checksum) { errors.push('Data integrity check failed - checksum mismatch'); } // Verify size const actualSize = new Blob([exportResult.data || '']).size; if (actualSize !== exportResult.metadata.totalSize) { errors.push('Size mismatch in export metadata'); } } return { valid: errors.length === 0, errors, }; } } // Export singleton instance export const plotBoardExportSystem = new PlotBoardExportSystem();
/Users/davehail/Developer/inkwell/DEPLOYMENT_CHECKLIST.md:9:  - [x] All critical TODOs resolved
/Users/davehail/Developer/inkwell/DEPLOYMENT_CHECKLIST.md:63:3. **📋 FEEDBACK_TEMPLATE.md** (structured feedback form)
/Users/davehail/Developer/inkwell/DEPLOYMENT_CHECKLIST.md:126:- Use `FEEDBACK_TEMPLATE.md` for structured reporting
/Users/davehail/Developer/inkwell/src/services/editorConsistencyDecorator.ts:487:    // This is a placeholder for more sophisticated timeline checking
/Users/davehail/Developer/inkwell/src/services/enhancedTimelineService.ts:71:    // TODO: Implement scene linkage detection logic
/Users/davehail/Developer/inkwell/src/services/enhancedTimelineService.ts:82:    // TODO: Implement actual timeline linkage logic
/Users/davehail/Developer/inkwell/src/services/enhancedTimelineService.ts:99:    // TODO: Implement timeline navigation logic
/Users/davehail/Developer/inkwell/src/services/enhancedTimelineService.ts:110:    // TODO: Implement timeline validation logic
/Users/davehail/Developer/inkwell/docs/release/ship-readiness-latest.md:27:Deprecated or TODO-like tags: 317
/Users/davehail/Developer/inkwell/docs/release/ship-readiness-latest.md:28:Throw patterns and stubs: 0
/Users/davehail/Developer/inkwell/src/utils/syntheticCorpusGenerator.ts:1:// src/utils/syntheticCorpusGenerator.ts import type { EnhancedProject } from '@/types/project'; import { ChapterStatus, SceneStatus, type Chapter, type Scene } from '@/types/writing'; export type GenreKey = 'fantasy' | 'mystery' | 'romance' | 'sci-fi' | 'literary'; export interface CorpusGenerationOptions { targetWordCount: number; // e.g., 150_000 chapterCount: number; // e.g., 40–60 scenesPerChapter: number; // e.g., 18–22 (to reach ~700–1200 scenes total) avgWordsPerScene: number; // advisory; final varies per scene genreStyle: GenreKey; includeCharacters: boolean; includePlotNotes: boolean; seed?: number; } export interface GeneratedCorpus { project: EnhancedProject; chapters: Chapter[]; stats: { totalWords: number; totalScenes: number; totalChapters: number; avgWordsPerScene: number; generationTime: number; // ms }; } /** * Synthetic Corpus Generator for Performance Testing * - Realistic content with genre-specific vocab * - Stable variability via seeded RNG * - Outputs chapters/scenes shaped for search & performance benchmarks */ export class SyntheticCorpusGenerator { private rng: () => number; private nameIndex = 0; private plotIndex = 0; // Public for benchmark helpers and external callers that want vocab. public static readonly STORY_ELEMENTS: Record< GenreKey, { characters: string[]; locations: string[]; concepts: string[] } > = { fantasy: { characters: [ 'Aeliana', 'Theron', 'Lyra', 'Gareth', 'Seraphina', 'Darius', 'Elara', 'Kael', 'Mirin', 'Aldrich', 'Zara', 'Bran', 'Celestine', 'Dorian', 'Faye', 'Gideon', ], locations: [ 'Shadowmere', 'Dragonspire', 'Whispering Woods', 'Crystal Caverns', 'Thornwick', 'Starfall Keep', 'Mistral Valley', 'Ironhold', 'Silverbrook', 'Stormhaven', ], concepts: [ 'ancient magic', 'dragon bond', 'crystal power', 'shadow realm', 'elven wisdom', 'dwarf forge', 'phoenix flame', 'moonstone', 'spell weaving', 'prophecy', ], }, mystery: { characters: [ 'Detective Morgan', 'Sarah Chen', 'Professor Blake', 'Dr. Williams', 'Inspector Hayes', 'Agent Carter', 'Ms. Rodriguez', 'Captain Stone', 'David Park', 'Emma Foster', ], locations: [ 'Victorian mansion', 'downtown precinct', 'university library', 'old warehouse', 'crime scene', 'forensics lab', 'coffee shop', 'courthouse', 'hotel lobby', ], concepts: [ 'murder weapon', 'alibi', 'evidence', 'witness testimony', 'DNA analysis', 'fingerprints', 'motive', 'red herring', 'cold case', 'breakthrough', ], }, 'sci-fi': { characters: [ 'Commander Vex', 'Dr. Singh', 'Captain Torres', 'Engineer Kim', 'Pilot Chen', 'Admiral Cross', 'Scientist Ray', 'Colonist Webb', 'AI Unit 7', 'Agent Nova', ], locations: [ 'space station', 'Mars colony', 'starship bridge', 'research lab', 'alien world', 'lunar base', 'asteroid mining', 'quantum lab', 'cryogenic bay', 'teleporter', ], concepts: [ 'faster than light', 'quantum field', 'alien contact', 'terraforming', 'AI consciousness', 'time dilation', 'wormhole', 'neural interface', 'genetic modification', 'dark matter', ], }, romance: { characters: [ 'Elena', 'Marco', 'Rhea', 'Jonah', 'Anya', 'Caleb', 'Sofia', 'Luca', 'Maya', 'Nikolai', ], locations: [ 'seaside café', 'old harbor', 'bookshop', 'gallery', 'city park', 'vineyard', 'winter market', 'train platform', 'town square', 'riverside path', ], concepts: [ 'missed connection', 'second chance', 'love letter', 'rivalry', 'secret admirer', 'forgiveness', 'reunion', 'promise', 'hesitation', 'spark', ], }, literary: { characters: [ 'Nadia', 'Elias', 'Marta', 'Hector', 'Iris', 'Samir', 'Ava', 'Tomas', 'Lina', 'Julian', ], locations: [ 'apartment stairwell', 'factory floor', 'supper club', 'tenement roof', 'riverwalk', 'train platform', 'country road', 'museum hall', 'office elevator', 'streetcar', ], concepts: [ 'memory', 'betrayal', 'migration', 'silence', 'inheritance', 'longing', 'mercy', 'duty', 'regret', 'becoming', ], }, }; private static readonly SCENE_TEMPLATES: readonly string[] = [ 'The {character} discovered {concept} in the {location}, changing everything they thought they knew.', 'As dawn broke over {location}, {character} realized the {concept} was more dangerous than expected.', 'The meeting at {location} revealed that {character} had been wrong about the {concept}.', 'Hidden within {location}, the {concept} pulsed with an energy {character} had never felt.', 'When {character} entered {location}, the {concept} immediately drew their attention.', 'The revelation about {concept} at {location} left {character} questioning their beliefs.', 'Through the shadows of {location}, {character} pursued the truth behind the {concept}.', ] as const; constructor(seed?: number) { this.rng = this.createSeededRNG(seed ?? Date.now()); } /** * Generate a complete synthetic corpus for testing. */ async generateCorpus(options: CorpusGenerationOptions): Promise<GeneratedCorpus> { const startTime = Date.now(); // Distribute words across chapters/scenes; final totals vary per scene. const wordsPerChapter = Math.max( 1, Math.floor(options.targetWordCount / Math.max(1, options.chapterCount)), ); const scenesPerChapterBase = Math.max(1, options.scenesPerChapter); const avgWordsPerScene = Math.max(50, Math.floor(wordsPerChapter / scenesPerChapterBase)); // Project metadata const project = this.generateProject(options); // Chapters and scenes const chapters = await this.generateChapters(options, avgWordsPerScene); // Stats const totalWords = chapters.reduce((sum, _ch) => sum + (ch.totalWordCount ?? 0), 0); const totalScenes = chapters.reduce((sum, _ch) => sum + ch.scenes.length, 0); const generationTime = Date.now() - startTime; return { project, chapters, stats: { totalWords, totalScenes, totalChapters: chapters.length, avgWordsPerScene: totalScenes > 0 ? totalWords / totalScenes : 0, generationTime, }, }; } /** * Project metadata shaped to EnhancedProject. * (Dates use epoch ms here, matching common app types.) */ private generateProject(options: CorpusGenerationOptions): EnhancedProject { const elements = SyntheticCorpusGenerator.STORY_ELEMENTS[options.genreStyle]; const project: EnhancedProject = { id: `synthetic_${Date.now()}`, name: this.generateProjectName(options.genreStyle), description: this.generateProjectDescription(options.genreStyle), genre: options.genreStyle, targetWordCount: options.targetWordCount, currentWordCount: 0, characters: options.includeCharacters ? this.generateCharacters(elements.characters) : [], plotNotes: options.includePlotNotes ? this.generatePlotNotes(elements.concepts) : [], worldBuilding: [], chapters: [], // populated separately by caller if desired recentContent: '', createdAt: Date.now() - 30 * 24 * 60 * 60 * 1000, // 30 days ago updatedAt: Date.now(), sessions: this.generateWritingSessions(), // keep whatever shape your app expects for Claude context claudeContext: { includeCharacters: true, includePlotNotes: true, includeWorldBuilding: false, maxCharacters: 5, maxPlotNotes: 10, contextLength: 'medium', } as any, }; return project; } /** * Chapters with realistically varied scene counts and word counts. */ private async generateChapters( options: CorpusGenerationOptions, avgWordsPerScene: number, ): Promise<Chapter[]> { const chapters: Chapter[] = []; const elements = SyntheticCorpusGenerator.STORY_ELEMENTS[options.genreStyle]; for (let chapterIndex = 0; chapterIndex < options.chapterCount; chapterIndex++) { // +/- up to ~3 scenes variability per chapter const scenesInChapter = Math.max( 1, Math.floor(options.scenesPerChapter + (this.rng() - 0.5) * 6), ); const scenes: Scene[] = []; for (let sceneIndex = 0; sceneIndex < scenesInChapter; sceneIndex++) { const scene = this.generateScene( chapterIndex, sceneIndex, avgWordsPerScene, elements, options.genreStyle, ); scenes.push(scene); } const totalWordCount = scenes.reduce((sum, _s) => sum + (s.wordCount ?? 0), 0); const chapter: Chapter = { id: `chapter_${chapterIndex}`, title: `Chapter ${chapterIndex + 1}: ${this.generateChapterTitle(elements)}`, order: chapterIndex, scenes, totalWordCount, status: this.randomChoice([ ChapterStatus.DRAFT, ChapterStatus.IN_PROGRESS, ChapterStatus.COMPLETE, ]), createdAt: new Date(Date.now() - (30 - chapterIndex) * 24 * 60 * 60 * 1000), updatedAt: new Date(Date.now() - Math.floor(this.rng() * 7 * 24 * 60 * 60 * 1000)), }; chapters.push(chapter); } return chapters; } /** * Individual scene with content generated from templates + expansions. */ private generateScene( chapterIndex: number, sceneIndex: number, targetWords: number, elements: { characters: string[]; locations: string[]; concepts: string[] }, genre: GenreKey, ): Scene { // Vary word count ±40% for realistic distribution const wordVariation = (this.rng() - 0.5) * 0.8; const actualWords = Math.max(120, Math.floor(targetWords * (1 + wordVariation))); const content = this.generateSceneContent(actualWords, elements, genre); const scene: Scene = { id: `scene_${chapterIndex}_${sceneIndex}`, title: this.generateSceneTitle(elements), content, status: this.randomChoice([SceneStatus.DRAFT, SceneStatus.REVISION, SceneStatus.COMPLETE]), order: sceneIndex, wordCount: actualWords, wordCountGoal: Math.floor(targetWords * 1.1), summary: this.generateSceneSummary(elements), createdAt: new Date(Date.now() - (30 - chapterIndex) * 24 * 60 * 60 * 1000), updatedAt: new Date(Date.now() - Math.floor(this.rng() * 7 * 24 * 60 * 60 * 1000)), }; return scene; } private generateSceneContent( targetWords: number, elements: { characters: string[]; locations: string[]; concepts: string[] }, _genre: GenreKey, ): string { const paragraphs: string[] = []; let currentWords = 0; while (currentWords < targetWords) { const template = this.randomChoice(SyntheticCorpusGenerator.SCENE_TEMPLATES); let paragraph = template .replace(/{character}/g, this.randomChoice(elements.characters)) .replace(/{location}/g, this.randomChoice(elements.locations)) .replace(/{concept}/g, this.randomChoice(elements.concepts)); // Expand paragraph into ~80–200 words paragraph = this.expandParagraph(paragraph, elements, 80 + Math.floor(this.rng() * 120)); paragraphs.push(paragraph); currentWords += this.countWords(paragraph); } return paragraphs.join('\n\n'); } private expandParagraph( baseSentence: string, _elements: { characters: string[]; locations: string[]; concepts: string[] }, targetWords: number, ): string { const sentences = [baseSentence]; let currentWords = this.countWords(baseSentence); const expansions = [ 'The air grew thick with tension.', 'Shadows danced across the walls.', 'Something felt different about this place.', 'The silence stretched between them.', 'A chill ran down their spine.', 'The implications were staggering.', 'Time seemed to slow.', 'Everything had changed.', 'The mystery deepened.', 'Questions multiplied.', ]; while (currentWords < targetWords && sentences.length < 6) { const expansion = this.randomChoice(expansions); sentences.push(expansion); currentWords += this.countWords(expansion); } return sentences.join(' '); } // Characters / plot notes — shape kept loose to fit various app types private generateCharacters(characterNames: string[]): any[] { return characterNames.slice(0, 8).map((name) => ({ id: `char_${this.nameIndex++}`, name, role: this.randomChoice(['protagonist', 'antagonist', 'supporting', 'minor']), description: `${name} is a complex character with hidden depths and surprising motivations.`, personality: this.randomChoice([ ['brave', 'stubborn', 'loyal'], ['clever', 'cautious', 'determined'], ['mysterious', 'powerful', 'conflicted'], ]), backstory: `${name} has a complicated past that influences their current actions.`, goals: 'To achieve their deepest desire while overcoming internal conflicts.', conflicts: 'Struggles between duty and personal desires.', appearance: 'Distinctive and memorable features that reflect their personality.', relationships: [], appearsInChapters: [], notes: 'Additional character development notes.', createdAt: Date.now(), updatedAt: Date.now(), })); } private generatePlotNotes(concepts: string[]): any[] { return concepts.slice(0, 12).map((concept) => ({ id: `plot_${this.plotIndex++}`, title: `The ${concept} Mystery`, content: `This plot thread explores the significance of ${concept} and its impact on the story.`, type: this.randomChoice(['outline', 'conflict', 'resolution', 'subplot']), priority: this.randomChoice(['high', 'medium', 'low']), status: this.randomChoice(['planned', 'in-progress', 'completed']), relatedCharacters: [], chapterReferences: [], tags: [concept], createdAt: Date.now(), updatedAt: Date.now(), })); } private generateWritingSessions(): any[] { const sessions: any[] = []; for (let i = 0; i < 15; i++) { const start = Date.now() - i * 24 * 60 * 60 * 1000; sessions.push({ id: `session_${i}`, projectId: 'synthetic', startTime: new Date(start), endTime: new Date(start + (30 + this.rng() * 90) * 60 * 1000), wordCount: Math.floor(200 + this.rng() * 800), wordsAdded: Math.floor(200 + this.rng() * 800), productivity: Number(this.rng().toFixed(2)), focusTime: Math.floor(this.rng() * 60), }); } return sessions; } // Helpers private generateProjectName(genre: GenreKey): string { const titles: Record<GenreKey, string[]> = { fantasy: ['The Crystal Prophecy', 'Shadows of Eldoria', "The Dragon's Heir"], mystery: ['The Vanishing Act', 'Secrets in the Shadows', 'The Last Witness'], 'sci-fi': ['Beyond the Stars', 'The Quantum Paradox', 'Colony Zero'], romance: ['Letters on the Pier', 'Second Chances', 'Autumn at the Vineyard'], literary: ['Inheritance of Silence', 'The Long Streetcar', 'Between Rooms'], }; const pool = titles[genre] ?? titles.fantasy; return this.randomChoice(pool); } private generateProjectDescription(genre: GenreKey): string { return `A compelling ${genre} story that explores themes of identity, power, and redemption against a richly detailed backdrop.`; } private generateChapterTitle(elements: { concepts: string[]; locations: string[]; characters: string[]; }): string { const formats = [ 'The {concept}', 'Secrets of {location}', "{character}'s Discovery", 'Journey to {location}', 'The {concept} Revealed', ] as const; return this.randomChoice(formats as unknown as string[]) .replace('{concept}', this.randomChoice(elements.concepts)) .replace('{location}', this.randomChoice(elements.locations)) .replace('{character}', this.randomChoice(elements.characters)); } private generateSceneTitle(elements: { characters: string[]; locations: string[]; concepts: string[]; }): string { return this.randomChoice([ `Meeting at ${this.randomChoice(elements.locations)}`, `${this.randomChoice(elements.characters)}'s Decision`, `Discovery in ${this.randomChoice(elements.locations)}`, `The ${this.randomChoice(elements.concepts)} Incident`, ]); } private generateSceneSummary(elements: { characters: string[]; concepts: string[] }): string { return `A pivotal scene involving ${this.randomChoice(elements.characters)} and the ${this.randomChoice( elements.concepts, )}.`; } private createSeededRNG(seed: number): () => number { // Simple LCG for determinism across environments let state = seed >>> 0; return () => { state = (state * 1664525 + 1013904223) >>> 0; return (state & 0xffffffff) / 0x100000000; }; } private randomChoice<T>(arr: readonly T[]): T { // Assume non-empty arrays; use non-null assertion to satisfy TS. return arr[Math.floor(Math.random() * arr.length)] as T; } private countWords(text: string): number { const m = text.trim().match(/\S+/g); return m ? m.length : 0; } } /** * Performance benchmark harness for search testing. */ export class SearchPerformanceBenchmark { /** * Generate realistic search queries for testing (names, locations, concepts, mixed). */ static generateSearchQueries(corpus: GeneratedCorpus): string[] { const { project } = corpus; const queries: string[] = []; // Character names and first names if (Array.isArray((project as any).characters)) { (project as any).characters.forEach((char: any) => { if (char?.name) { queries.push(char.name); const first = String(char.name).split(' ')[0]; if (first) queries.push(first); } }); } // Locations and concepts from genre vocab const elements = SyntheticCorpusGenerator.STORY_ELEMENTS[ project.genre as keyof typeof SyntheticCorpusGenerator.STORY_ELEMENTS ] ?? SyntheticCorpusGenerator.STORY_ELEMENTS.fantasy; elements.locations.forEach((loc) => queries.push(loc)); elements.concepts.forEach((concept) => queries.push(concept)); // Multi-word and partial fragments queries.push( 'ancient magic power', 'meeting at location', 'character discovery', 'shadow realm portal', 'crystal energy source', 'discov', 'shadow', 'power', 'secret', 'ancient', ); // Cap to a reasonable set return queries.slice(0, 100); } /** * Run performance benchmark with percentile reporting. Accepts any search service * exposing `search(query, { projectId, maxResults }) -> Promise<Hit[]>`. */ static async runBenchmark(_searchService: { search: (q: string, _opts: { projectId: string; maxResults?: number }) => Promise<any[]>; }, corpus: GeneratedCorpus, queries: string[], ): Promise<{ p50: number; p95: number; totalQueries: number; avgResultsPerQuery: number; totalTime: number; }> { const startTime = Date.now(); const latencies: number[] = []; let totalResults = 0; for (const query of queries) { const t0 = Date.now(); try { const results = await searchService.search(query, { projectId: corpus.project.id, maxResults: 20, }); latencies.push(Date.now() - t0); totalResults += Array.isArray(results) ? results.length : 0; } catch { latencies.push(5000); // penalty for failed query } } latencies.sort((a, _b) => a - b); const pick = (_p: number) => latencies[Math.min(latencies.length - 1, Math.max(0, Math.floor(latencies.length * p)))] ?? 0; const p50 = pick(0.5); const p95 = pick(0.95); const totalTime = Date.now() - startTime; return { p50, p95, totalQueries: queries.length, avgResultsPerQuery: queries.length ? totalResults / queries.length : 0, totalTime, }; } }
/Users/davehail/Developer/inkwell/src/data/starterTemplates.ts:1:// src/data/starterTemplates.ts import { formatSceneFilename } from '../services/featureFlagService.presets'; export interface ProjectTemplate { id: string; name: string; description: string; icon: string; category: 'fiction' | 'screenplay' | 'poetry' | 'nonfiction'; difficulty: 'beginner' | 'intermediate' | 'advanced'; estimatedLength: string; chapters: TemplateChapter[]; scenes: TemplateScene[]; characters?: TemplateCharacter[]; notes?: TemplateNote[]; settings?: ProjectSettings; tags?: string[]; } export interface TemplateChapter { id: string; title: string; description?: string; orderIndex: number; scenes: string[]; // Scene IDs } export interface TemplateScene { id: string; title: string; description?: string; chapterId: string; orderIndex: number; content?: string; wordTarget?: number; purpose?: string; conflictType?: string; } export interface TemplateCharacter { id: string; name: string; role: 'protagonist' | 'antagonist' | 'supporting' | 'minor'; description?: string; motivation?: string; conflict?: string; arc?: string; } export interface TemplateNote { id: string; title: string; content: string; category: 'plot' | 'character' | 'setting' | 'research' | 'ideas'; } export interface ProjectSettings { targetWordCount?: number; genre?: string; pointOfView?: 'first' | 'second' | 'third-limited' | 'third-omniscient'; tense?: 'past' | 'present' | 'future'; theme?: string; } // Starter templates optimized for beginners export const STARTER_TEMPLATES: ProjectTemplate[] = [ // Beginner Templates { id: 'simple-novel', name: 'Simple Novel', description: 'A basic story structure to get you started', icon: '📖', category: 'fiction', difficulty: 'beginner', estimatedLength: '50,000-80,000 words', chapters: [ { id: 'chapter-1', title: 'Chapter 1', description: 'Opening chapter to hook readers', orderIndex: 0, scenes: ['opening-scene'], }, ], scenes: [ { id: 'opening-scene', title: 'Opening scene', description: 'Introduce your protagonist and their world', chapterId: 'chapter-1', orderIndex: 0, wordTarget: 1500, purpose: 'Hook the reader and establish the protagonist', content: `Write your opening scene here. Consider starting with:\n\n• Your main character in action\n• A compelling situation or conflict\n• A sense of the story world\n• A reason for readers to keep reading\n\nRemember: You can always revise later. Just get words on the page!`, }, ], settings: { targetWordCount: 60000, pointOfView: 'third-limited', tense: 'past', }, notes: [ { id: 'story-idea', title: 'Story Idea', content: 'What is your story about? Write a one-sentence summary here.', category: 'plot', }, { id: 'main-character', title: 'Main Character', content: 'Who is your protagonist? What do they want? What stands in their way?', category: 'character', }, ], tags: ['beginner', 'novel', 'fiction'], }, { id: 'short-story', name: 'Short Story', description: 'Perfect for a single sitting read', icon: '📝', category: 'fiction', difficulty: 'beginner', estimatedLength: '1,000-5,000 words', chapters: [ { id: 'beginning', title: 'Beginning', description: 'Setup and inciting incident', orderIndex: 0, scenes: ['hook'], }, { id: 'middle', title: 'Middle', description: 'Development and complications', orderIndex: 1, scenes: ['development'], }, { id: 'end', title: 'End', description: 'Climax and resolution', orderIndex: 2, scenes: ['resolution'], }, ], scenes: [ { id: 'hook', title: 'Hook', description: 'Grab attention immediately', chapterId: 'beginning', orderIndex: 0, wordTarget: 500, purpose: 'Establish character, conflict, and stakes quickly', }, { id: 'development', title: 'Development', description: 'Deepen conflict and raise stakes', chapterId: 'middle', orderIndex: 0, wordTarget: 1000, purpose: 'Show character struggling with the central conflict', }, { id: 'resolution', title: 'Resolution', description: 'Resolve conflict and provide satisfaction', chapterId: 'end', orderIndex: 0, wordTarget: 500, purpose: 'Bring the story to a meaningful close', }, ], settings: { targetWordCount: 2500, pointOfView: 'first', tense: 'present', }, tags: ['beginner', 'short-story', 'fiction'], }, // Intermediate Templates { id: 'mystery-3-act', name: 'Mystery with 3 Acts', description: 'Classic mystery structure with investigation phases', icon: '🔍', category: 'fiction', difficulty: 'intermediate', estimatedLength: '70,000-90,000 words', chapters: [ { id: 'act-1-setup', title: 'Act I: Setup', description: 'Introduce detective and crime', orderIndex: 0, scenes: ['hook', 'crime-discovered'], }, { id: 'act-2-investigation', title: 'Act II: Investigation', description: 'Detective investigates and encounters obstacles', orderIndex: 1, scenes: ['initial-investigation', 'complications', 'false-leads'], }, { id: 'act-3-resolution', title: 'Act III: Resolution', description: 'Truth revealed and justice served', orderIndex: 2, scenes: ['breakthrough', 'revelation', 'justice'], }, ], scenes: [ { id: 'hook', title: 'Hook', description: 'Introduce detective in their normal world', chapterId: 'act-1-setup', orderIndex: 0, purpose: 'Establish detective character and skills', }, { id: 'crime-discovered', title: 'Crime Discovered', description: 'The inciting incident - a crime occurs', chapterId: 'act-1-setup', orderIndex: 1, purpose: 'Launch the central mystery', }, { id: 'initial-investigation', title: 'Initial Investigation', description: 'Detective begins gathering clues', chapterId: 'act-2-investigation', orderIndex: 0, purpose: 'Show detective methods and uncover initial leads', }, { id: 'complications', title: 'Complications', description: 'Obstacles arise, stakes increase', chapterId: 'act-2-investigation', orderIndex: 1, purpose: 'Raise tension and show opposition', }, { id: 'false-leads', title: 'False Leads', description: 'Red herrings and dead ends', chapterId: 'act-2-investigation', orderIndex: 2, purpose: 'Mislead reader while building suspense', }, { id: 'breakthrough', title: 'Breakthrough', description: 'Key evidence or realization', chapterId: 'act-3-resolution', orderIndex: 0, purpose: 'Turn the investigation around', }, { id: 'revelation', title: 'Revelation', description: 'Truth is revealed', chapterId: 'act-3-resolution', orderIndex: 1, purpose: 'Expose the criminal and their motive', }, { id: 'justice', title: 'Justice', description: 'Resolution and aftermath', chapterId: 'act-3-resolution', orderIndex: 2, purpose: 'Restore order and provide closure', }, ], characters: [ { id: 'detective', name: '[Detective Name]', role: 'protagonist', description: 'Skilled investigator with unique methods', motivation: 'Seeks truth and justice', conflict: 'Personal flaws or past trauma complicate the investigation', }, { id: 'criminal', name: '[Criminal Name]', role: 'antagonist', description: 'The perpetrator of the central crime', motivation: 'Whatever drove them to commit the crime', conflict: 'Trying to avoid detection while achieving their goals', }, ], settings: { targetWordCount: 80000, genre: 'mystery', pointOfView: 'third-limited', tense: 'past', theme: 'Justice vs. mercy, truth vs. consequences', }, tags: ['intermediate', 'mystery', '3-act', 'investigation'], }, // Advanced Template { id: 'screenplay-5-beat', name: 'Screenplay 5-Beat', description: 'Standard screenplay structure for film/TV', icon: '🎬', category: 'screenplay', difficulty: 'advanced', estimatedLength: '90-120 pages', chapters: [ { id: 'act-1', title: 'Act I', description: 'Setup (pages 1-25)', orderIndex: 0, scenes: ['opening-image', 'inciting-incident'], }, { id: 'act-2a', title: 'Act II-A', description: 'Rising action (pages 26-50)', orderIndex: 1, scenes: ['plot-point-1', 'complications'], }, { id: 'act-2b', title: 'Act II-B', description: 'Midpoint to climax (pages 51-75)', orderIndex: 2, scenes: ['midpoint', 'plot-point-2'], }, { id: 'act-3', title: 'Act III', description: 'Resolution (pages 76-90)', orderIndex: 3, scenes: ['climax', 'resolution'], }, ], scenes: [ { id: 'opening-image', title: 'Opening Image', description: 'Visual representation of the story theme', chapterId: 'act-1', orderIndex: 0, purpose: 'Establish tone and theme visually', }, { id: 'inciting-incident', title: 'Inciting Incident', description: 'Event that launches the story', chapterId: 'act-1', orderIndex: 1, purpose: 'Get the story moving and engage protagonist', }, { id: 'plot-point-1', title: 'Plot Point 1', description: 'Protagonist commits to the journey', chapterId: 'act-2a', orderIndex: 0, purpose: 'Lock protagonist into the main conflict', }, { id: 'midpoint', title: 'Midpoint', description: 'False victory or defeat; stakes raised', chapterId: 'act-2b', orderIndex: 0, purpose: 'Shift story direction and raise stakes', }, { id: 'plot-point-2', title: 'Plot Point 2', description: 'All seems lost moment', chapterId: 'act-2b', orderIndex: 1, purpose: 'Propel into final act with maximum stakes', }, { id: 'climax', title: 'Climax', description: 'Final confrontation and resolution', chapterId: 'act-3', orderIndex: 0, purpose: 'Resolve central conflict dramatically', }, { id: 'resolution', title: 'Resolution', description: 'New normal and closing image', chapterId: 'act-3', orderIndex: 1, purpose: 'Show changed world and character growth', }, ], settings: { targetWordCount: 25000, // Approximate word count for screenplay pointOfView: 'third-omniscient', tense: 'present', }, tags: ['advanced', 'screenplay', '5-beat', 'film', 'tv'], }, ]; // Get templates filtered by UI mode export function _getTemplatesForMode(mode: 'beginner' | 'pro'): ProjectTemplate[] { if (mode === 'beginner') { return STARTER_TEMPLATES.filter((t) => t.difficulty === 'beginner'); } return STARTER_TEMPLATES; // Pro mode gets all templates } // Create project from template export function _createProjectFromTemplate( template: ProjectTemplate, projectName: string, authorId?: string, ) { const projectId = `project-${Date.now()}`; return { id: projectId, name: projectName, description: template.description, createdAt: Date.now(), updatedAt: Date.now(), authorId, // Template settings settings: { ...template.settings, templateId: template.id, templateName: template.name, }, // Chapters with generated IDs chapters: template.chapters.map((chapter,  _index) => ({ ...chapter, id: `${projectId}-${chapter.id}`, projectId, createdAt: Date.now(), updatedAt: Date.now(), })), // Scenes with generated IDs and proper filenames scenes: template.scenes.map((scene,  _index) => { const chapterIndex = template.chapters.findIndex((c) => c.id === scene.chapterId); return { ...scene, id: `${projectId}-${scene.id}`, projectId, chapterId: `${projectId}-${scene.chapterId}`, filename: formatSceneFilename(projectName, chapterIndex, _index), createdAt: Date.now(), updatedAt: Date.now(), content: scene.content || '', // Ensure content is never undefined }; }), // Characters if provided characters: template.characters?.map((character) => ({ ...character, id: `${projectId}-${character.id}`, projectId, createdAt: Date.now(), updatedAt: Date.now(), })) || [], // Notes if provided notes: template.notes?.map((note) => ({ ...note, id: `${projectId}-${note.id}`, projectId, createdAt: Date.now(), updatedAt: Date.now(), })) || [], // Metadata metadata: { templateUsed: template.id, uiMode: template.difficulty === 'beginner' ? 'beginner' : 'pro', tags: template.tags || [], category: template.category, estimatedLength: template.estimatedLength, }, }; } // Opinionated editor defaults export const EDITOR_DEFAULTS = { beginner: { focusMode: true, // Start in distraction-free mode autosaveInterval: 2000, // Save every 2 seconds softWrap: true, // No horizontal scrolling showWordCount: true, // Always show progress showAdvancedFormatting: false, // Keep it simple spellCheck: true, // Help with typos fontSize: 16, // Comfortable reading size lineHeight: 1.6, // Easy on the eyes theme: 'light', // Simple default theme }, pro: { focusMode: false, // Full interface available autosaveInterval: 5000, // Less frequent saves softWrap: true, showWordCount: true, showAdvancedFormatting: true, // All formatting options spellCheck: true, fontSize: 14, // Compact for more content lineHeight: 1.5, theme: 'system', // Respect system preference }, }; // File naming conventions export const NAMING_CONVENTIONS = { project: (_name: string) => name.trim() || 'Untitled Project', chapter: (_index: number, _customTitle?: string) => customTitle?.trim() || `Chapter ${index + 1}`, scene: (_projectName: string, _chapterIndex: number, _sceneIndex: number, _customTitle?: string) => { if (customTitle?.trim()) { return customTitle.trim(); } return formatSceneFilename(projectName, chapterIndex, sceneIndex); }, note: (_category: string, _index: number) => `${category.charAt(0).toUpperCase() + category.slice(1)} Note ${index + 1}`, character: (_role: string, _index: number) => `${role.charAt(0).toUpperCase() + role.slice(1)} ${index + 1}`, }; // Default project settings by genre export const GENRE_DEFAULTS: Record<string, Partial<ProjectSettings>> = { mystery: { pointOfView: 'third-limited', tense: 'past', theme: 'Truth and justice', }, romance: { pointOfView: 'third-limited', tense: 'past', theme: 'Love conquers all', }, 'science-fiction': { pointOfView: 'third-limited', tense: 'past', theme: 'Technology and humanity', }, fantasy: { pointOfView: 'third-limited', tense: 'past', theme: 'Good vs. evil', }, literary: { pointOfView: 'first', tense: 'present', theme: 'Human condition', }, };
/Users/davehail/Developer/inkwell/src/services/aiPlotAnalysisService.ts:107:    // TODO: Integrate with actual AI service
/Users/davehail/Developer/inkwell/src/services/aiPlotAnalysisService.ts:241:    // TODO: Implement storage/retrieval
/Users/davehail/Developer/inkwell/src/services/aiPlotAnalysisService.ts:250:    // TODO: Implement storage
/Users/davehail/Developer/inkwell/docs/BRAND_UPDATE_SUMMARY.md:150:- 📄 **Empty states and placeholders**
/Users/davehail/Developer/inkwell/src/features/plotboards/portability/portabilitySystem.ts:1:// Universal Plot Board Portability System // Ensures cross-instance compatibility, integrity checks, and reliable backup/restore import { trace } from '../../../utils/trace'; import { ExportFormat } from '../export/exportSystem'; import { plotBoardImportSystem } from '../import/importSystem'; import { CURRENT_SCHEMA_VERSION } from '../schema/versioning'; import { PlotBoard, PlotBoardTemplate } from '../types'; import { SavedViewData } from '../views/savedViews'; /* ========= Portability Types ========= */ export interface PortablePackage { format: 'inkwell-plotboard-portable'; version: string; metadata: PortabilityMetadata; data: PortableData; integrity: IntegrityInfo; } export interface PortabilityMetadata { packageId: string; createdAt: string; createdBy: string; sourceInstance: string; targetCompatibility: string[]; description?: string; tags: string[]; schemaVersion: string; compressionUsed: boolean; } export interface PortableData { boards: PlotBoard[]; views: SavedViewData[]; templates: PlotBoardTemplate[]; settings: any[]; relationships: Relationship[]; } export interface Relationship { type: RelationType; sourceId: string; targetId: string; metadata?: any; } export enum RelationType { BOARD_VIEW = 'board_view', CARD_SCENE = 'card_scene', CARD_TIMELINE = 'card_timeline', TEMPLATE_BOARD = 'template_board', } export interface IntegrityInfo { checksum: string; itemCounts: { boards: number; columns: number; cards: number; views: number; templates: number; }; validation: ValidationResult; } export interface ValidationResult { valid: boolean; errors: string[]; warnings: string[]; checkedAt: string; } export interface PortabilityOptions { includeViews?: boolean; includeTemplates?: boolean; includeSettings?: boolean; compression?: boolean; validate?: boolean; description?: string; tags?: string[]; } export interface RestoreOptions { mergeStrategy?: 'replace' | 'merge' | 'append'; conflictResolution?: 'skip' | 'overwrite' | 'rename'; validateIntegrity?: boolean; createBackup?: boolean; targetProjectId?: string; } export interface RestoreResult { success: boolean; restored: { boards: number; views: number; templates: number; }; errors?: string[]; warnings?: string[]; conflicts?: string[]; backupId?: string; } /* ========= Portability System Class ========= */ export class PlotBoardPortabilitySystem { private readonly PORTABLE_FORMAT_VERSION = '1.0.0'; private readonly SUPPORTED_VERSIONS = ['1.0.0']; /** * Create a portable package from boards and related data */ async createPortablePackage( boards: PlotBoard[], views: SavedViewData[] = [], templates: PlotBoardTemplate[] = [], options: Partial<PortabilityOptions> = {}, ): Promise<PortablePackage> { const opts: PortabilityOptions = { includeViews: true, includeTemplates: true, includeSettings: true, compression: false, validate: true, description: '', tags: [], ...options, }; try { trace.log('Creating portable package', 'user_action', 'info', { boardCount: boards.length, options: opts, }); const packageId = `portable_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; // Prepare data const portableData: PortableData = { boards, views: opts.includeViews ? views : [], templates: opts.includeTemplates ? templates : [], settings: opts.includeSettings ? this.extractSettings(boards) : [], relationships: this.extractRelationships(boards, views, templates), }; // Calculate integrity info const integrityInfo = await this.calculateIntegrity(portableData, opts.validate!); // Create metadata const metadata: PortabilityMetadata = { packageId, createdAt: new Date().toISOString(), createdBy: 'Inkwell User', // Could be enhanced with user info sourceInstance: this.getInstanceIdentifier(), targetCompatibility: this.SUPPORTED_VERSIONS, description: opts.description, tags: opts.tags || [], schemaVersion: CURRENT_SCHEMA_VERSION, compressionUsed: opts.compression || false, }; const portablePackage: PortablePackage = { format: 'inkwell-plotboard-portable', version: this.PORTABLE_FORMAT_VERSION, metadata, data: portableData, integrity: integrityInfo, }; trace.log('Portable package created', 'user_action', 'info', { packageId, itemCounts: integrityInfo.itemCounts, }); return portablePackage; } catch (error) { trace.log('Failed to create portable package', 'user_action', 'error', { error }); throw new Error( `Failed to create portable package: ${error instanceof Error ? error.message : 'Unknown error'}`, ); } } /** * Export portable package to file */ async exportPortablePackage( portablePackage: PortablePackage, filename?: string, ): Promise<{ filename: string; size: number; checksum: string }> { try { const data = JSON.stringify(portablePackage, null, 2); const blob = new Blob([data], { type: 'application/json' }); const finalFilename = filename || this.generatePortableFilename(portablePackage); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = finalFilename; document.body.appendChild(link); link.click(); document.body.removeChild(link); setTimeout(() => URL.revokeObjectURL(url), 1000); const checksum = this.calculateChecksum(data); trace.log('Portable package exported', 'user_action', 'info', { filename: finalFilename, size: blob.size, checksum, }); return { filename: finalFilename, size: blob.size, checksum, }; } catch (error) { trace.log('Export failed', 'user_action', 'error', { error }); throw new Error(`Export failed: ${error instanceof Error ? error.message : 'Unknown error'}`); } } /** * Import portable package from file */ async importPortablePackage(file: File): Promise<PortablePackage> { try { const text = await this.readFileAsText(file); const portablePackage = JSON.parse(text) as PortablePackage; // Validate package format await this.validatePortablePackage(portablePackage); trace.log('Portable package imported', 'user_action', 'info', { packageId: portablePackage.metadata.packageId, version: portablePackage.version, }); return portablePackage; } catch (error) { trace.log('Import failed', 'user_action', 'error', { error }); throw new Error(`Import failed: ${error instanceof Error ? error.message : 'Unknown error'}`); } } /** * Restore data from portable package */ async restoreFromPortablePackage( portablePackage: PortablePackage, options: Partial<RestoreOptions> = {}, ): Promise<RestoreResult> { const opts: RestoreOptions = { mergeStrategy: 'replace', conflictResolution: 'skip', validateIntegrity: true, createBackup: true, ...options, }; try { trace.log('Starting restore from portable package', 'user_action', 'info', { packageId: portablePackage.metadata.packageId, options: opts, }); // Validate integrity if (opts.validateIntegrity) { const integrityCheck = await this.validateIntegrity(portablePackage); if (!integrityCheck.valid) { throw new Error(`Integrity validation failed: ${integrityCheck.errors.join(', ')}`); } } let restored = { boards: 0, views: 0, templates: 0 }; const errors: string[] = []; const warnings: string[] = []; const conflicts: string[] = []; // Restore boards for (const board of portablePackage.data.boards) { try { // Update project ID if specified if (opts.targetProjectId) { board.projectId = opts.targetProjectId; } // Import the board using the existing import system const importResult = await plotBoardImportSystem.importData( { metadata: { exportedAt: portablePackage.metadata.createdAt, _schemaVersion: portablePackage.metadata.schemaVersion, _format: ExportFormat.JSON, _boardId: board.id, _boardTitle: board.title, _cardsCount: board.columns.reduce((sum, _col) => sum + col.cards.length, 0), columnsCount: board.columns.length, totalSize: 0, checksum: '', }, board, }, undefined, { mergeStrategy: opts.mergeStrategy as any, conflictResolution: opts.conflictResolution as any, preserveIds: true, }, ); if (importResult.success) { restored.boards++; } else { errors.push( `Failed to restore board "${board.title}": ${importResult.errors?.join(', ')}`, ); } if (importResult.conflicts && importResult.conflicts.length > 0) { conflicts.push(...importResult.conflicts.map((c) => c.item)); } if (importResult.warnings && importResult.warnings.length > 0) { warnings.push(...importResult.warnings); } } catch (error) { errors.push( `Error restoring board "${board.title}": ${error instanceof Error ? error.message : 'Unknown error'}`, ); } } // Restore views (would need integration with saved views system) restored.views = portablePackage.data.views.length; // Restore templates (would need integration with template system) restored.templates = portablePackage.data.templates.length; trace.log('Restore completed', 'user_action', 'info', { restored, errors: errors.length, warnings: warnings.length, conflicts: conflicts.length, }); return { success: errors.length === 0, restored, errors: errors.length > 0 ? errors : undefined, warnings: warnings.length > 0 ? warnings : undefined, conflicts: conflicts.length > 0 ? conflicts : undefined, }; } catch (error) { trace.log('Restore failed', 'user_action', 'error', { error }); return { success: false, restored: { boards: 0, views: 0, templates: 0 }, errors: [error instanceof Error ? error.message : 'Restore failed'], }; } } /** * Validate portable package format and integrity */ async validatePortablePackage(portablePackage: PortablePackage): Promise<ValidationResult> { const errors: string[] = []; const warnings: string[] = []; try { // Check format if (portablePackage.format !== 'inkwell-plotboard-portable') { errors.push(`Invalid package format: ${portablePackage.format}`); } // Check version compatibility if (!this.SUPPORTED_VERSIONS.includes(portablePackage.version)) { errors.push(`Unsupported package version: ${portablePackage.version}`); } // Check required fields if (!portablePackage.metadata) { errors.push('Missing metadata section'); } if (!portablePackage.data) { errors.push('Missing data section'); } if (!portablePackage.integrity) { errors.push('Missing integrity section'); } // Validate integrity if package is complete if (errors.length === 0) { const integrityCheck = await this.validateIntegrity(portablePackage); errors.push(...integrityCheck.errors); warnings.push(...integrityCheck.warnings); } } catch (error) { errors.push(`Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`); } return { valid: errors.length === 0, errors, warnings, checkedAt: new Date().toISOString(), }; } /** * Validate integrity of portable package */ private async validateIntegrity(portablePackage: PortablePackage): Promise<ValidationResult> { const errors: string[] = []; const warnings: string[] = []; try { // Recalculate checksum const dataString = JSON.stringify(portablePackage.data); const calculatedChecksum = this.calculateChecksum(dataString); if (calculatedChecksum !== portablePackage.integrity.checksum) { errors.push('Data integrity check failed - checksum mismatch'); } // Validate item counts const actualCounts = { boards: portablePackage.data.boards.length, columns: portablePackage.data.boards.reduce((sum, _board) => sum + board.columns.length, 0), cards: portablePackage.data.boards.reduce( (sum, _board) => sum + board.columns.reduce((colSum, _col) => colSum + col.cards.length, 0), 0, ), views: portablePackage.data.views.length, templates: portablePackage.data.templates.length, }; const expectedCounts = portablePackage.integrity.itemCounts; if (actualCounts.boards !== expectedCounts.boards) { errors.push( `Board count mismatch: expected ${expectedCounts.boards}, got ${actualCounts.boards}`, ); } if (actualCounts.columns !== expectedCounts.columns) { errors.push( `Column count mismatch: expected ${expectedCounts.columns}, got ${actualCounts.columns}`, ); } if (actualCounts.cards !== expectedCounts.cards) { errors.push( `Card count mismatch: expected ${expectedCounts.cards}, got ${actualCounts.cards}`, ); } if (actualCounts.views !== expectedCounts.views) { warnings.push( `View count mismatch: expected ${expectedCounts.views}, got ${actualCounts.views}`, ); } if (actualCounts.templates !== expectedCounts.templates) { warnings.push( `Template count mismatch: expected ${expectedCounts.templates}, got ${actualCounts.templates}`, ); } // Validate board structure for (const board of portablePackage.data.boards) { if (!board.id || !board.title || !board.projectId) { errors.push(`Invalid board structure: missing required fields`); } for (const column of board.columns) { if (!column.id || !column.title || column.boardId !== board.id) { errors.push(`Invalid column structure in board "${board.title}"`); } for (const card of column.cards) { if (!card.id || !card.title || card.columnId !== column.id) { errors.push(`Invalid card structure in column "${column.title}"`); } } } } } catch (error) { errors.push( `Integrity validation error: ${error instanceof Error ? error.message : 'Unknown error'}`, ); } return { valid: errors.length === 0, errors, warnings, checkedAt: new Date().toISOString(), }; } /** * Calculate integrity info for portable data */ private async calculateIntegrity(data: PortableData, validate: boolean): Promise<IntegrityInfo> { const dataString = JSON.stringify(data); const checksum = this.calculateChecksum(dataString); const itemCounts = { boards: data.boards.length, columns: data.boards.reduce((sum, _board) => sum + board.columns.length, 0), cards: data.boards.reduce( (sum, _board) => sum + board.columns.reduce((colSum, _col) => colSum + col.cards.length, 0), 0, ), views: data.views.length, templates: data.templates.length, }; let validation: ValidationResult = { valid: true, errors: [], warnings: [], checkedAt: new Date().toISOString(), }; if (validate) { // Perform basic validation on the data const errors: string[] = []; const warnings: string[] = []; // Validate boards have required fields for (const board of data.boards) { if (!board.id || !board.title) { errors.push(`Board missing required fields: id or title`); } } validation = { valid: errors.length === 0, errors, warnings, checkedAt: new Date().toISOString(), }; } return { checksum, itemCounts, validation, }; } /** * Extract relationships between different data types */ private extractRelationships( boards: PlotBoard[], views: SavedViewData[], _templates: any[], ): Relationship[] { const relationships: Relationship[] = []; // Board-View relationships for (const view of views) { relationships.push({ type: RelationType.BOARD_VIEW, sourceId: view.view.boardId, targetId: view.view.id, }); } // Card-Scene relationships for (const board of boards) { for (const column of board.columns) { for (const card of column.cards) { if (card.sceneId) { relationships.push({ type: RelationType.CARD_SCENE, sourceId: card.id, targetId: card.sceneId, metadata: { chapterId: card.chapterId }, }); } if (card.timelineEventIds && card.timelineEventIds.length > 0) { for (const eventId of card.timelineEventIds) { relationships.push({ type: RelationType.CARD_TIMELINE, sourceId: card.id, targetId: eventId, }); } } } } } return relationships; } /** * Extract settings from boards */ private extractSettings(boards: PlotBoard[]): any[] { return boards.map((board) => ({ boardId: board.id, _settings: board.settings, _columnSettings: board.columns.map((col) => ({ columnId: col.id, settings: col.settings, })), })); } /** * Utility methods */ private calculateChecksum(data: string): string { let hash = 0; for (let i = 0; i < data.length; i++) { const char = data.charCodeAt(i); hash = (hash << 5) - hash + char; hash = hash & hash; } return Math.abs(hash).toString(16); } private generatePortableFilename(portablePackage: PortablePackage): string { const timestamp = new Date().toISOString().slice(0, 10); const boardCount = portablePackage.data.boards.length; const sanitizedId = portablePackage.metadata.packageId.replace(/[^a-z0-9]/gi, '-'); return `inkwell-plotboards-${sanitizedId}-${boardCount}boards-${timestamp}.portable.json`; } private getInstanceIdentifier(): string { // Generate a simple instance identifier return `inkwell-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; } private readFileAsText(file: File): Promise<string> { return new Promise((resolve, _reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result as string); reader.onerror = () => reject(reader.error); reader.readAsText(file); }); } } // Export singleton instance export const plotBoardPortabilitySystem = new PlotBoardPortabilitySystem();
/Users/davehail/Developer/inkwell/src/services/professionalExportService.ts:1:// src/services/professionalExportService.ts import JSZip from 'jszip'; import type { EnhancedProject } from '@/types/project'; import type { Chapter } from '@/types/writing'; export interface ExportTemplate { name: string; description: string; format: 'docx' | 'epub'; settings: { fontSize: number; fontFamily: string; lineSpacing: number; margins: { top: number; bottom: number; left: number; right: number; }; pageSize: 'letter' | 'a4'; includeHeaders: boolean; includePageNumbers: boolean; chapterPageBreaks: boolean; sceneBreaks: string; // Manuscript-specific settings runningHeader?: boolean; headerFormat?: string; firstPageSpecial?: boolean; contactInfo?: boolean; indentFirstLine?: boolean; }; } export const EXPORT_TEMPLATES: Record<string, ExportTemplate> = { 'standard-manuscript': { name: 'Standard Manuscript', description: 'Industry-standard formatting for agent/editor submissions (Shunn format)', format: 'docx', settings: { fontSize: 12, fontFamily: 'Times New Roman', lineSpacing: 2.0, margins: { top: 1, bottom: 1, left: 1.25, right: 1.25 }, pageSize: 'letter', includeHeaders: true, includePageNumbers: true, chapterPageBreaks: true, sceneBreaks: '***', // Standard manuscript specific settings runningHeader: true, headerFormat: 'SURNAME / TITLE / PAGE', firstPageSpecial: true, contactInfo: true, indentFirstLine: true, }, }, 'paperback-novel': { name: 'Paperback Novel', description: 'Print-ready formatting for paperback books', format: 'docx', settings: { fontSize: 11, fontFamily: 'Garamond', lineSpacing: 1.2, margins: { top: 0.75, bottom: 0.75, left: 1, right: 0.75 }, pageSize: 'letter', includeHeaders: false, includePageNumbers: true, chapterPageBreaks: true, sceneBreaks: '***', }, }, 'ebook-epub': { name: 'Standard EPUB', description: 'Industry-standard EPUB for e-readers', format: 'epub', settings: { fontSize: 14, fontFamily: 'serif', lineSpacing: 1.4, margins: { top: 1, bottom: 1, left: 1, right: 1 }, pageSize: 'a4', includeHeaders: false, includePageNumbers: false, chapterPageBreaks: true, sceneBreaks: '* * *', }, }, }; export class ProfessionalExportService { /** * Export project as professional DOCX */ async exportDOCX( project: EnhancedProject, chapters: Chapter[], templateKey: string = 'standard-manuscript', ): Promise<{ success: boolean; filename: string; error?: string }> { try { const template = EXPORT_TEMPLATES[templateKey]; if (!template || template.format !== 'docx') { throw new Error('Invalid DOCX template'); } // Build DOCX payload const docxContent = await this.generateDOCXContent(project, chapters, template); const filename = `${this.sanitizeFilename(project.name)}_${templateKey}.docx`; const zip = new JSZip(); // Required DOCX structure zip.file('[Content_Types].xml', this.generateContentTypes(template.settings.runningHeader)); const relsFolder = zip.folder('_rels')!; relsFolder.file('.rels', this.generateMainRels()); const wordFolder = zip.folder('word')!; wordFolder.file('document.xml', docxContent); wordFolder.file('styles.xml', this.generateStyles(template)); wordFolder.file('settings.xml', this.generateSettings()); wordFolder.file('fontTable.xml', this.generateFontTable(template)); // Add header if needed for manuscript format if (template.settings.runningHeader) { wordFolder.file('header1.xml', this.generateManuscriptHeader(project, template)); } const wordRelsFolder = wordFolder.folder('_rels')!; wordRelsFolder.file('document.xml.rels', this.generateDocumentRels(template.settings.runningHeader)); const blob = await zip.generateAsync({ type: 'blob' }); this.downloadFile( blob, filename, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', ); return { success: true, filename }; } catch (error) { devLog.error('DOCX export failed:', error); return { success: false, filename: '', error: error instanceof Error ? error.message : 'Unknown error', }; } } /** * Export project as professional EPUB */ async exportEPUB( project: EnhancedProject, chapters: Chapter[], ): Promise<{ success: boolean; filename: string; error?: string }> { try { const template = EXPORT_TEMPLATES['ebook-epub']; if (!template || template.format !== 'epub') { throw new Error('Export template is required for EPUB generation'); } const filename = `${this.sanitizeFilename(project.name)}.epub`; const zip = new JSZip(); // EPUB structure zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' }); const metaInf = zip.folder('META-INF')!; metaInf.file('container.xml', this.generateContainer()); const oebps = zip.folder('OEBPS')!; // Generate core EPUB content (chapters are strings: one XHTML per chapter) const { opf, ncx, navXhtml, chapters: chapterFiles, } = await this.generateEPUBContent(project, chapters, template); // Core OEBPS files oebps.file('content.opf', opf); oebps.file('toc.ncx', ncx); oebps.file('nav.xhtml', navXhtml); oebps.file('styles.css', this.generateEPUBStyles()); oebps.file('title.xhtml', this.generateTitlePage(project)); // Chapter XHTML files: chapter1.xhtml, chapter2.xhtml, ... chapterFiles.forEach((chapterContent, _index) => { oebps.file(`chapter${index + 1}.xhtml`, chapterContent); }); const blob = await zip.generateAsync({ type: 'blob' }); this.downloadFile(blob, filename, 'application/epub+zip'); return { success: true, filename }; } catch (error) { devLog.error('EPUB export failed:', error); return { success: false, filename: '', error: error instanceof Error ? error.message : 'Unknown error', }; } } /* ========================= DOCX generation helpers ========================= */ private async generateDOCXContent( project: EnhancedProject, chapters: Chapter[], template: ExportTemplate, ): Promise<string> { const content: string[] = []; content.push(`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>`); content.push( `<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">`, ); content.push(`<w:body>`); // Title page content.push(this.generateDOCXTitlePage(project, template, chapters)); // Chapters chapters.forEach((chapter, _chapterIndex) => { if (chapterIndex > 0 && template.settings.chapterPageBreaks) { content.push(`<w:p><w:pPr><w:pageBreakBefore/></w:pPr></w:p>`); } content.push( `<w:p><w:pPr><w:pStyle w:val="Heading1"/></w:pPr><w:r><w:t>${this.escapeXML( chapter.title, )}</w:t></w:r></w:p>`, ); content.push(`<w:p><w:pPr><w:spacing w:after="240"/></w:pPr></w:p>`); chapter.scenes.forEach((scene, _sceneIndex) => { if (scene.content) { if (sceneIndex > 0) { content.push( `<w:p><w:pPr><w:jc w:val="center"/><w:spacing w:before="240" w:after="240"/></w:pPr><w:r><w:t>${template.settings.sceneBreaks}</w:t></w:r></w:p>`, ); } const paragraphs = this.htmlToDOCXParagraphs(scene.content); content.push(...paragraphs); } }); }); content.push(`<w:sectPr>`); // Add header reference if using manuscript format if (template.settings.runningHeader) { content.push(`<w:headerReference w:type="default" r:id="rId4"/>`); } content.push( `<w:pgSz w:w="${ template.settings.pageSize === 'letter' ? '12240' : '11906' }" w:h="${template.settings.pageSize === 'letter' ? '15840' : '16838'}"/>`, ); content.push( `<w:pgMar w:top="${Math.round(template.settings.margins.top * 1440)}" w:right="${Math.round( template.settings.margins.right * 1440, )}" w:bottom="${Math.round(template.settings.margins.bottom * 1440)}" w:left="${Math.round( template.settings.margins.left * 1440, )}"/>`, ); content.push(`</w:sectPr>`); content.push(`</w:body>`); content.push(`</w:document>`); return content.join('\n'); } private generateDOCXTitlePage( project: EnhancedProject, template: ExportTemplate, chapters: Chapter[], ): string { const content: string[] = []; const wordCount = chapters.reduce((sum, _ch) => sum + ch.totalWordCount, 0); if (template.settings.contactInfo && template.name === 'Standard Manuscript') { // Standard manuscript first page format (Shunn format) content.push( `<w:p><w:pPr><w:jc w:val="left"/></w:pPr><w:r><w:t>[Your Name]</w:t></w:r></w:p>` ); content.push( `<w:p><w:pPr><w:jc w:val="left"/></w:pPr><w:r><w:t>[Your Address]</w:t></w:r></w:p>` ); content.push( `<w:p><w:pPr><w:jc w:val="left"/></w:pPr><w:r><w:t>[City, State ZIP]</w:t></w:r></w:p>` ); content.push( `<w:p><w:pPr><w:jc w:val="left"/></w:pPr><w:r><w:t>[Phone Number]</w:t></w:r></w:p>` ); content.push( `<w:p><w:pPr><w:jc w:val="left"/></w:pPr><w:r><w:t>[Email Address]</w:t></w:r></w:p>` ); content.push(`<w:p><w:pPr><w:spacing w:after="240"/></w:pPr></w:p>`); // Word count and genre (right-aligned) content.push( `<w:p><w:pPr><w:jc w:val="right"/></w:pPr><w:r><w:t>About ${Math.round(wordCount / 250) * 250} words</w:t></w:r></w:p>` ); content.push( `<w:p><w:pPr><w:jc w:val="right"/></w:pPr><w:r><w:t>${project.genre || 'Fiction'}</w:t></w:r></w:p>` ); content.push(`<w:p><w:pPr><w:spacing w:after="720"/></w:pPr></w:p>`); // Centered title and author content.push( `<w:p><w:pPr><w:jc w:val="center"/><w:spacing w:before="1440" w:after="240"/></w:pPr><w:r><w:rPr><w:sz w:val="24"/><w:b/></w:rPr><w:t>${this.escapeXML( project.name.toUpperCase(), )}</w:t></w:r></w:p>`, ); content.push( `<w:p><w:pPr><w:jc w:val="center"/><w:spacing w:after="480"/></w:pPr><w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t>by</w:t></w:r></w:p>`, ); content.push( `<w:p><w:pPr><w:jc w:val="center"/><w:spacing w:after="720"/></w:pPr><w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t>[Your Name]</w:t></w:r></w:p>`, ); } else { // Standard title page format for other templates content.push( `<w:p><w:pPr><w:jc w:val="center"/><w:spacing w:before="720" w:after="360"/></w:pPr><w:r><w:rPr><w:sz w:val="36"/><w:b/></w:rPr><w:t>${this.escapeXML( project.name, )}</w:t></w:r></w:p>`, ); content.push( `<w:p><w:pPr><w:jc w:val="center"/><w:spacing w:after="720"/></w:pPr><w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t>by [Author Name]</w:t></w:r></w:p>`, ); if (project.description) { content.push( `<w:p><w:pPr><w:spacing w:before="720" w:after="240"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>Synopsis</w:t></w:r></w:p>`, ); content.push( `<w:p><w:pPr><w:spacing w:after="720"/></w:pPr><w:r><w:t>${this.escapeXML( project.description, )}</w:t></w:r></w:p>`, ); } content.push( `<w:p><w:pPr><w:spacing w:before="720"/></w:pPr><w:r><w:t>Word Count: ${wordCount.toLocaleString()}</w:t></w:r></w:p>`, ); content.push(`<w:p><w:r><w:t>Genre: ${project.genre || 'Fiction'}</w:t></w:r></w:p>`); } content.push(`<w:p><w:pPr><w:pageBreakBefore/></w:pPr></w:p>`); return content.join('\n'); } private htmlToDOCXParagraphs(html: string): string[] { const plainText = html .replace(/<br\s*\/?>/gi, '\n') .replace(/<\/p>/gi, '\n\n') .replace(/<[^>]*>/g, '') .replace(/&nbsp;/g, ' ') .replace(/&lt;/g, '<') .replace(/&gt;/g, '>') .replace(/&amp;/g, '&'); const paragraphs = plainText .split('\n\n') .map((p) => p.trim()) .filter((p) => p.length > 0); return paragraphs.map( (paragraph) => `<w:p><w:pPr><w:spacing w:after="240"/></w:pPr><w:r><w:t>${this.escapeXML( paragraph, )}</w:t></w:r></w:p>`, ); } /* ========================= EPUB generation helpers ========================= */ private async generateEPUBContent( project: EnhancedProject, chapters: Chapter[], template: ExportTemplate, ): Promise<{ opf: string; ncx: string; navXhtml: string; chapters: string[]; // each string is a full chapter XHTML }> { const bookId = `book-${Date.now()}`; const chapterFiles: string[] = []; chapters.forEach((chapter, _index) => { const chapterXhtml = this.generateChapterXHTML(chapter, index + 1, template); chapterFiles.push(chapterXhtml); }); const opf = this.generateOPF(project, chapters, bookId); const ncx = this.generateNCX(project, chapters, bookId); const navXhtml = this.generateNavXHTML(project, chapters); return { opf, ncx, navXhtml, chapters: chapterFiles }; } private generateContainer(): string { return `<?xml version="1.0" encoding="UTF-8"?> <container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container"> <rootfiles> <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/> </rootfiles> </container>`; } private generateOPF(project: EnhancedProject, chapters: Chapter[], bookId: string): string { return `<?xml version="1.0" encoding="UTF-8"?> <package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="3.0"> <metadata xmlns:dc="http://purl.org/dc/elements/1.1/"> <dc:identifier id="BookId">${bookId}</dc:identifier> <dc:title>${this.escapeXML(project.name)}</dc:title> <dc:creator>[Author Name]</dc:creator> <dc:language>en</dc:language> </metadata> <manifest> <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/> <item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/> <item id="styles" href="styles.css" media-type="text/css"/> <item id="title" href="title.xhtml" media-type="application/xhtml+xml"/> ${chapters .map( (_c, _index) => `<item id="chapter${index + 1}" href="chapter${index + 1}.xhtml" media-type="application/xhtml+xml"/>`, ) .join('\n')} </manifest> <spine toc="ncx"> <itemref idref="title"/> ${chapters.map((_c, _index) => `<itemref idref="chapter${index + 1}"/>`).join('\n')} </spine> </package>`; } private generateNCX(project: EnhancedProject, chapters: Chapter[], bookId: string): string { return `<?xml version="1.0" encoding="UTF-8"?> <ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1"> <head> <meta name="dtb:uid" content="${bookId}"/> </head> <docTitle><text>${this.escapeXML(project.name)}</text></docTitle> <navMap> ${chapters .map( (chapter, _index) => `<navPoint id="chapter${index + 1}" playOrder="${index + 1}"> <navLabel><text>${this.escapeXML(chapter.title)}</text></navLabel> <content src="chapter${index + 1}.xhtml"/> </navPoint>`, ) .join('\n')} </navMap> </ncx>`; } private generateNavXHTML(project: EnhancedProject, chapters: Chapter[]): string { return `<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head><title>Table of Contents</title></head> <body> <nav id="toc"> <h1>Table of Contents</h1> <ol> ${chapters .map( (chapter, _index) => `<li><a href="chapter${index + 1}.xhtml">${this.escapeXML(chapter.title)}</a></li>`, ) .join('\n')} </ol> </nav> </body> </html>`; } private generateTitlePage(project: EnhancedProject): string { return `<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <title>Title Page</title> <link rel="stylesheet" href="styles.css"/> </head> <body> <div class="title-page"> <h1>${this.escapeXML(project.name)}</h1> <p>by [Author Name]</p> </div> </body> </html>`; } private generateChapterXHTML( chapter: Chapter, chapterNum: number, template: ExportTemplate, ): string { return `<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <title>${this.escapeXML(chapter.title)}</title> <link rel="stylesheet" href="styles.css"/> </head> <body> <h1>${this.escapeXML(chapter.title)}</h1> ${chapter.scenes .map((scene, _index) => { let content = ''; if (index > 0) { content += `<div class="scene-break">${template.settings.sceneBreaks}</div>`; } content += `<div class="scene">${scene.content || ''}</div>`; return content; }) .join('\n')} </body> </html>`; } private generateEPUBStyles(): string { return ` body { font-family: serif; line-height: 1.6; margin: 1em; } h1 { text-align: center; margin: 2em 0; } .scene-break { text-align: center; margin: 2em 0; } .scene { margin: 1em 0; } p { text-indent: 1.5em; margin: 1em 0; } `; } /* ========================= Shared helpers ========================= */ private generateContentTypes(includeHeader: boolean = false): string { let content = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"> <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/> <Default Extension="xml" ContentType="application/xml"/> <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/> <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/> <Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/> <Override PartName="/word/fontTable.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"/>`; if (includeHeader) { content += ` <Override PartName="/word/header1.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml"/>`; } content += ` </Types>`; return content; } private generateMainRels(): string { return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"> <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/> </Relationships>`; } private generateDocumentRels(includeHeader: boolean = false): string { let relationships = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"> <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/> <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings" Target="settings.xml"/> <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable" Target="fontTable.xml"/>`; if (includeHeader) { relationships += ` <Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/header" Target="header1.xml"/>`; } relationships += ` </Relationships>`; return relationships; } private generateStyles(template: ExportTemplate): string { const fontSize = template.settings.fontSize * 2; const lineSpacing = Math.round(template.settings.lineSpacing * 240); return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"> <w:style w:type="paragraph" w:default="1" w:styleId="Normal"> <w:name w:val="Normal"/> <w:qFormat/> <w:pPr> <w:spacing w:line="${lineSpacing}" w:lineRule="auto"/> </w:pPr> <w:rPr> <w:rFonts w:ascii="${template.settings.fontFamily}" w:hAnsi="${template.settings.fontFamily}"/> <w:sz w:val="${fontSize}"/> </w:rPr> </w:style> <w:style w:type="paragraph" w:styleId="Heading1"> <w:name w:val="heading 1"/> <w:basedOn w:val="Normal"/> <w:pPr> <w:keepNext/> <w:spacing w:before="240" w:after="240"/> <w:jc w:val="center"/> </w:pPr> <w:rPr> <w:b/> <w:sz w:val="${fontSize + 4}"/> </w:rPr> </w:style> </w:styles>`; } private generateSettings(): string { return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"> <w:defaultTabStop w:val="708"/> </w:settings>`; } private generateFontTable(template: ExportTemplate): string { return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <w:fonts xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"> <w:font w:name="${template.settings.fontFamily}"> <w:family w:val="roman"/> </w:font> </w:fonts>`; } private escapeXML(text: string): string { return text .replace(/&/g, '&amp;') .replace(/</g, '&lt;') .replace(/>/g, '&gt;') .replace(/"/g, '&quot;') .replace(/'/g, '&apos;'); } private sanitizeFilename(filename: string): string { return filename .replace(/[^a-z0-9\s\-_]/gi, '') .replace(/\s+/g, '_') .toLowerCase(); } // Note: _mimeType is unused (download attribute covers it). Keep for API parity; prefix to please ESLint. private generateManuscriptHeader(project: EnhancedProject, template: ExportTemplate): string { // Generate manuscript running header: SURNAME / TITLE / PAGE const surname = "[SURNAME]"; const title = project.name.length > 50 ? project.name.substring(0, 47) + "..." : project.name; return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <w:hdr xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"> <w:p> <w:pPr> <w:tabs> <w:tab w:val="center" w:pos="4320"/> <w:tab w:val="right" w:pos="8640"/> </w:tabs> </w:pPr> <w:r> <w:rPr> <w:rFonts w:ascii="${template.settings.fontFamily}" w:hAnsi="${template.settings.fontFamily}"/> <w:sz w:val="${template.settings.fontSize * 2}"/> </w:rPr> <w:t>${surname}</w:t> </w:r> <w:r> <w:tab/> </w:r> <w:r> <w:rPr> <w:rFonts w:ascii="${template.settings.fontFamily}" w:hAnsi="${template.settings.fontFamily}"/> <w:sz w:val="${template.settings.fontSize * 2}"/> </w:rPr> <w:t>${this.escapeXML(title)}</w:t> </w:r> <w:r> <w:tab/> </w:r> <w:r> <w:rPr> <w:rFonts w:ascii="${template.settings.fontFamily}" w:hAnsi="${template.settings.fontFamily}"/> <w:sz w:val="${template.settings.fontSize * 2}"/> </w:rPr> <w:fldChar w:fldCharType="begin"/> </w:r> <w:r> <w:instrText> PAGE </w:instrText> </w:r> <w:r> <w:fldChar w:fldCharType="end"/> </w:r> </w:p> </w:hdr>`; } private downloadFile(blob: Blob, filename: string, _mimeType: string): void { const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); setTimeout(() => URL.revokeObjectURL(url), 1000); } } export const professionalExportService = new ProfessionalExportService(); export default professionalExportService;
/Users/davehail/Developer/inkwell/DOCUMENTATION_AUDIT_2025.md:275:- `docs/PR_TEMPLATE_TOUR_CHECKLIST.md` ❌ **DELETE** - One-time template
/Users/davehail/Developer/inkwell/DOCUMENTATION_AUDIT_2025.md:297:- `FEEDBACK_TEMPLATE.md` ❌ **DELETE** - Use GitHub issues
/Users/davehail/Developer/inkwell/src/features/plotboards/hooks/useKeyboardNavigation.ts:209:  // Declare announce function stub to be defined later
/Users/davehail/Developer/inkwell/SPOTLIGHT_TOUR_FINAL_INTEGRATION.md:29:// TODO: Replace with actual analytics service
/Users/davehail/Developer/inkwell/SPOTLIGHT_TOUR_FINAL_INTEGRATION.md:55:- Replaced placeholder gtag calls with `tourAnalytics` adapter
/Users/davehail/Developer/inkwell/src/features/plotboards/components/views/SavedViewsSelector.tsx:1:// Saved views selector component for Plot Boards // Allows users to switch between, create, and manage saved views import React, { useState, useRef, useEffect } from 'react'; import { SavedViewData, SavedViewManager } from '../../views/savedViews'; interface SavedViewsSelectorProps { viewManager: SavedViewManager; currentView: SavedViewData | null; onViewChange: (_viewId: string) => void; onCreateView: (_name: string) => Promise<void>; onUpdateView: (_viewId: string, _name: string) => Promise<void>; onDeleteView: (_viewId: string) => Promise<void>; onDuplicateView: (_viewId: string) => Promise<void>; className?: string; } export const SavedViewsSelector: React.FC<SavedViewsSelectorProps> = ({ viewManager, _currentView, _onViewChange, _onCreateView, _onUpdateView, _onDeleteView, _onDuplicateView, _className = '',  }) => { const [isOpen, setIsOpen] = useState(false); const [editingViewId, setEditingViewId] = useState<string | null>(null); const [editingName, setEditingName] = useState(''); const [isCreating, setIsCreating] = useState(false); const [newViewName, setNewViewName] = useState(''); const [showManagement, setShowManagement] = useState(false); const dropdownRef = useRef<HTMLDivElement>(null); const editInputRef = useRef<HTMLInputElement>(null); // Get all views const allViews = viewManager.getAllViews(); const defaultViews = allViews.filter((v) => v.view.isDefault); const customViews = allViews.filter((v) => !v.view.isDefault); // Close dropdown when clicking outside useEffect(() => { const handleClickOutside = (_event: MouseEvent) => { if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) { setIsOpen(false); setIsCreating(false); setEditingViewId(null); setShowManagement(false); } }; document.addEventListener('mousedown', handleClickOutside); return () => document.removeEventListener('mousedown', handleClickOutside); }, []); // Focus edit input when editing starts useEffect(() => { if (editingViewId && editInputRef.current) { editInputRef.current.focus(); editInputRef.current.select(); } }, [editingViewId]); const handleViewSelect = (_viewId: string) => { onViewChange(viewId); setIsOpen(false); setShowManagement(false); }; const handleStartEditing = (_viewId: string, _currentName: string) => { setEditingViewId(viewId); setEditingName(currentName); }; const handleSaveEdit = async () => { if (editingViewId && editingName.trim()) { try { await onUpdateView(editingViewId, editingName.trim()); setEditingViewId(null); setEditingName(''); } catch (error) { console.error('Failed to update view:', error); // Could show toast notification here } } }; const handleCancelEdit = () => { setEditingViewId(null); setEditingName(''); }; const handleCreateView = async () => { if (newViewName.trim()) { try { await onCreateView(newViewName.trim()); setIsCreating(false); setNewViewName(''); setShowManagement(false); } catch (error) { console.error('Failed to create view:', error); // Could show toast notification here } } }; const handleDeleteView = async (_viewId: string) => { if (window.confirm('Are you sure you want to delete this view?')) { try { await onDeleteView(viewId); } catch (error) { console.error('Failed to delete view:', error); } } }; const handleDuplicateView = async (_viewId: string) => { try { await onDuplicateView(viewId); setShowManagement(false); } catch (error) { console.error('Failed to duplicate view:', error); } }; const handleExportView = (_viewId: string) => { const exportData = viewManager.exportView(viewId); if (exportData) { const blob = new Blob([exportData], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `plot-view-${viewId}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); } }; return ( <div className={`relative ${className}`} ref={dropdownRef}> {/* View Selector Button */} <button onClick={() => setIsOpen(!isOpen)} className="flex items-center space-x-2 px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:ring-2 focus:ring-blue-500 focus:border-blue-500" > <svg className="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" > <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /> </svg> <span>{currentView?.view.name || 'Select View'}</span> <svg className={`w-4 h-4 text-gray-400 transition-transform ${isOpen ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" > <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /> </svg> </button> {/* Dropdown Menu */} {isOpen && ( <div className="absolute right-0 mt-1 w-80 bg-white border border-gray-200 rounded-md shadow-lg z-50"> {/* Header */} <div className="px-4 py-3 border-b border-gray-100"> <div className="flex items-center justify-between"> <h3 className="text-sm font-medium text-gray-900">Saved Views</h3> <div className="flex items-center space-x-2"> <button onClick={() => setShowManagement(!showManagement)} className={`text-xs px-2 py-1 rounded transition-colors ${ showManagement ? 'bg-blue-100 text-blue-700' : 'text-gray-500 hover:text-gray-700 hover:bg-gray-100' }`} > Manage </button> <button onClick={() => setIsCreating(true)} className="text-xs text-blue-600 hover:text-blue-800" > + New </button> </div> </div> </div> {/* Views List */} <div className="max-h-80 overflow-y-auto"> {/* Default Views */} {defaultViews.length > 0 && ( <div className="py-2"> <div className="px-4 py-1 text-xs font-medium text-gray-500 uppercase tracking-wide"> Default Views </div> {defaultViews.map((viewData) => ( <ViewItem key={viewData.view.id} viewData={viewData} isActive={currentView?.view.id === viewData.view.id} isEditing={editingViewId === viewData.view.id} editingName={editingName} showManagement={showManagement} onSelect={handleViewSelect} onStartEditing={handleStartEditing} onSaveEdit={handleSaveEdit} onCancelEdit={handleCancelEdit} onDelete={handleDeleteView} onDuplicate={handleDuplicateView} onExport={handleExportView} onEditNameChange={setEditingName} editInputRef={editInputRef} /> ))} </div> )} {/* Custom Views */} {customViews.length > 0 && ( <div className="py-2 border-t border-gray-100"> <div className="px-4 py-1 text-xs font-medium text-gray-500 uppercase tracking-wide"> Custom Views ({customViews.length}) </div> {customViews.map((viewData) => ( <ViewItem key={viewData.view.id} viewData={viewData} isActive={currentView?.view.id === viewData.view.id} isEditing={editingViewId === viewData.view.id} editingName={editingName} showManagement={showManagement} onSelect={handleViewSelect} onStartEditing={handleStartEditing} onSaveEdit={handleSaveEdit} onCancelEdit={handleCancelEdit} onDelete={handleDeleteView} onDuplicate={handleDuplicateView} onExport={handleExportView} onEditNameChange={setEditingName} editInputRef={editInputRef} /> ))} </div> )} {/* Create New View Form */} {isCreating && ( <div className="p-4 border-t border-gray-100 bg-gray-50"> <div className="space-y-3"> <div> <label className="block text-xs font-medium text-gray-700 mb-1"> View Name </label> <input type="text" value={newViewName} onChange={(e) => setNewViewName(e.target.value)} placeholder="Enter view name..." className="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" autoFocus onKeyDown={(_e) => { if (e.key === 'Enter') { handleCreateView(); } else if (e.key === 'Escape') { setIsCreating(false); setNewViewName(''); } }} /> <p className="mt-1 text-xs text-gray-500"> This will save the current filters and settings </p> </div> <div className="flex justify-end space-x-2"> <button onClick={() => { setIsCreating(false); setNewViewName(''); }} className="px-3 py-1 text-xs text-gray-600 hover:text-gray-800" > Cancel </button> <button onClick={handleCreateView} disabled={!newViewName.trim()} className="px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed" > Create </button> </div> </div> </div> )} {/* Empty State */} {customViews.length === 0 && !isCreating && ( <div className="px-4 py-6 text-center text-sm text-gray-500"> <p>No custom views yet</p> <button onClick={() => setIsCreating(true)} className="mt-2 text-blue-600 hover:text-blue-800" > Create your first view </button> </div> )} </div> {/* Footer */} <div className="px-4 py-2 border-t border-gray-100 bg-gray-50 text-xs text-gray-500"> Views save your current filters, search, and layout settings </div> </div> )} </div> ); }; // View Item Component interface ViewItemProps { viewData: SavedViewData; isActive: boolean; isEditing: boolean; editingName: string; showManagement: boolean; onSelect: (_viewId: string) => void; onStartEditing: (_viewId: string, _name: string) => void; onSaveEdit: () => void; onCancelEdit: () => void; onDelete: (_viewId: string) => void; onDuplicate: (_viewId: string) => void; onExport: (_viewId: string) => void; onEditNameChange: (_name: string) => void; editInputRef: React.RefObject<HTMLInputElement | null>; } const ViewItem: React.FC<ViewItemProps> = ({ viewData, _isActive, _isEditing, _editingName, _showManagement, _onSelect, _onStartEditing, _onSaveEdit, _onCancelEdit, _onDelete, _onDuplicate, _onExport, _onEditNameChange, _editInputRef,  }) => { // Count active filters const activeFilters = Object.values(viewData.view.filters).reduce((count, _filter) => { if (Array.isArray(filter)) return count + filter.length; if (filter) return count + 1; return count; }, 0) + (viewData.filterContext.searchTerm ? 1 : 0); return ( <div className={`group px-4 py-2 hover:bg-gray-50 ${ isActive ? 'bg-blue-50 border-r-2 border-blue-500' : '' }`} > <div className="flex items-center justify-between"> <div className="flex-1 min-w-0"> {isEditing ? ( <div className="flex items-center space-x-2"> <input ref={editInputRef} type="text" value={editingName} onChange={(e) => onEditNameChange(e.target.value)} className="flex-1 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-blue-500 focus:border-blue-500" onKeyDown={(_e) => { if (e.key === 'Enter') { onSaveEdit(); } else if (e.key === 'Escape') { onCancelEdit(); } }} /> <button onClick={onSaveEdit} className="text-green-600 hover:text-green-800 text-xs"> ✓ </button> <button onClick={onCancelEdit} className="text-red-600 hover:text-red-800 text-xs"> ✕ </button> </div> ) : ( <button onClick={() => onSelect(viewData.view.id)} className="text-left w-full"> <div className="text-sm font-medium text-gray-900 truncate"> {viewData.view.name} {isActive && <span className="ml-2 text-xs text-blue-600">✓</span>} </div> <div className="flex items-center space-x-2 text-xs text-gray-500"> {activeFilters > 0 && ( <span> {activeFilters} filter{activeFilters !== 1 ? 's' : ''} </span> )} {viewData.view.sorting && <span>Sort: {viewData.view.sorting.field}</span>} {viewData.view.grouping.enabled && ( <span>Group: {viewData.view.grouping.field}</span> )} {viewData.view.isDefault && ( <span className="px-1 bg-gray-200 rounded text-gray-600">Default</span> )} </div> </button> )} </div> {/* Management Actions */} {showManagement && !isEditing && ( <div className="flex items-center space-x-1 opacity-0 group-hover:opacity-100 transition-opacity"> {!viewData.view.isDefault && ( <button onClick={() => onStartEditing(viewData.view.id, viewData.view.name)} className="text-gray-400 hover:text-gray-600 text-xs p-1" title="Rename" > ✏️ </button> )} <button onClick={() => onDuplicate(viewData.view.id)} className="text-gray-400 hover:text-gray-600 text-xs p-1" title="Duplicate" > 📋 </button> <button onClick={() => onExport(viewData.view.id)} className="text-gray-400 hover:text-gray-600 text-xs p-1" title="Export" > 📤 </button> {!viewData.view.isDefault && ( <button onClick={() => onDelete(viewData.view.id)} className="text-gray-400 hover:text-red-600 text-xs p-1" title="Delete" > 🗑️ </button> )} </div> )} </div> </div> ); };
/Users/davehail/Developer/inkwell/package.json:16:    "hygiene": "git grep -nE 'TODO\\(>30d\\)' -- ':!node_modules' && exit 1 || exit 0",
/Users/davehail/Developer/inkwell/package.json:104:    "@tiptap/extension-placeholder": "^3.1.0",
/Users/davehail/Developer/inkwell/src/utils/exportFormats.ts:1:// src/utils/exportFormats.ts import { ExportFormat } from '../types/writing'; interface ExportConfig { ext: string; mime: string; formatter: (_title: string, _content: string) => string; } export const exportFormats: Record<ExportFormat, ExportConfig> = { markdown: { ext: 'md', mime: 'text/markdown', formatter: (_title, _content) => `# ${title}\n\n${content}`, }, txt: { ext: 'txt', mime: 'text/plain', formatter: (_title, _content) => { const underline = '='.repeat(title.length); return `${title}\n${underline}\n\n${content}`; }, }, docx: { ext: 'docx', mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', formatter: (_title, _content) => `${title}\n\n${content}`, }, html: { ext: 'html', mime: 'text/html', formatter: (_title, _content) => { return `<!DOCTYPE html> <html> <head> <title>${title}</title> <meta charset="utf-8"> </head> <body> <h1>${title}</h1> <div>${content.replace(/\n/g, '<br>')}</div> </body> </html>`; }, }, pdf: { ext: 'pdf', mime: 'application/pdf', formatter: (_title, _content) => { return `PDF Export not implemented - use print to PDF instead.\n\n${title}\n\n${content}`; }, }, };
/Users/davehail/Developer/inkwell/src/features/plotboards/components/VirtualizedColumn.tsx:283:            placeholder="Card title..."
/Users/davehail/Developer/inkwell/TOUR_BUTTON_FIXES_SUMMARY.md:153:**Root Cause:** `useSpotlightUI` had TODO comments and wasn't connected to TourService
/Users/davehail/Developer/inkwell/src/features/plotboards/components/PlotColumn.tsx:271:            placeholder="Card title..."
/Users/davehail/Developer/inkwell/src/services/plotAnalysis/llmAnalysis.ts:9:const USER_PROMPT_TEMPLATE = `BOOK_DATA:
/Users/davehail/Developer/inkwell/src/services/plotAnalysis/llmAnalysis.ts:99:  const userPrompt = USER_PROMPT_TEMPLATE.replace('{BOOK_JSON}', bookJson);
/Users/davehail/Developer/inkwell/src/test/syntheticCorpusGenerator.ts:403:    for (const [placeholder, replacement] of Object.entries(substitutions)) {
/Users/davehail/Developer/inkwell/src/test/syntheticCorpusGenerator.ts:406:          placeholder.replace(/[.*+?^${}()|\[\]\\]/g, (match) => '\\' + match),
/Users/davehail/Developer/inkwell/src/services/epubValidationService.ts:1:// src/services/epubValidationService.ts // EPUB validation service for quality checking import type { EnhancedProject } from '@/types/project'; import type { Chapter } from '@/types/writing'; export interface EPUBValidationIssue { type: 'error' | 'warning' | 'info'; code: string; message: string; location?: string; severity: 'critical' | 'major' | 'minor'; suggestion?: string; } export interface EPUBValidationReport { isValid: boolean; issues: EPUBValidationIssue[]; metadata: { hasTitle: boolean; hasAuthor: boolean; hasUniqueId: boolean; chaptersCount: number; totalWordCount: number; hasTableOfContents: boolean; }; qualityScore: number; // 0-100 readinessLevel: 'not-ready' | 'needs-work' | 'good' | 'excellent'; } export interface DOCXValidationReport { isValid: boolean; issues: EPUBValidationIssue[]; formatting: { hasProperMargins: boolean; hasCorrectFontSize: boolean; hasDoubleSpacing: boolean; hasRunningHeader: boolean; hasPageNumbers: boolean; wordCountEstimate: number; pageEstimate: number; }; manuscriptCompliance: number; // 0-100 readinessLevel: 'not-ready' | 'needs-work' | 'good' | 'excellent'; } class EPUBValidationService { /** * Validate EPUB readiness of a project */ validateEPUBProject(project: EnhancedProject, chapters: Chapter[]): EPUBValidationReport { const issues: EPUBValidationIssue[] = []; // Metadata validation const metadata = this.validateMetadata(project, issues); // Content validation this.validateContent(project, chapters, issues); // Structure validation this.validateStructure(chapters, issues); // Calculate quality score const qualityScore = this.calculateQualityScore(issues, metadata); const readinessLevel = this.determineReadinessLevel(qualityScore, issues); return { isValid: !issues.some((issue) => issue.type === 'error'), issues, metadata, qualityScore, readinessLevel, }; } /** * Validate DOCX/manuscript readiness of a project */ validateManuscriptProject(project: EnhancedProject, chapters: Chapter[]): DOCXValidationReport { const issues: EPUBValidationIssue[] = []; // Manuscript format validation const formatting = this.validateManuscriptFormatting(project, chapters, issues); // Content validation for manuscripts this.validateManuscriptContent(project, chapters, issues); // Calculate manuscript compliance score const manuscriptCompliance = this.calculateManuscriptCompliance(formatting, issues); const readinessLevel = this.determineReadinessLevel(manuscriptCompliance, issues); return { isValid: !issues.some((issue) => issue.type === 'error'), issues, formatting, manuscriptCompliance, readinessLevel, }; } private validateMetadata(project: EnhancedProject, issues: EPUBValidationIssue[]) { const metadata = { hasTitle: !!project.name?.trim(), hasAuthor: false, // We don't have author info in project yet hasUniqueId: !!project.id, chaptersCount: project.chapters?.length || 0, totalWordCount: project.currentWordCount || 0, hasTableOfContents: (project.chapters?.length || 0) > 1, }; // Validate title if (!metadata.hasTitle) { issues.push({ type: 'error', code: 'EPUB-001', message: 'Project title is required for EPUB export', severity: 'critical', suggestion: 'Add a title to your project in the project settings', }); } else if (project.name.length > 255) { issues.push({ type: 'warning', code: 'EPUB-002', message: 'Project title is very long and may be truncated in some readers', severity: 'minor', suggestion: 'Consider using a shorter title (under 255 characters)', }); } // Validate author if (!metadata.hasAuthor) { issues.push({ type: 'warning', code: 'EPUB-003', message: 'Author information is missing', severity: 'major', suggestion: 'Add author information for proper EPUB metadata', }); } // Validate content length if (metadata.totalWordCount < 1000) { issues.push({ type: 'warning', code: 'EPUB-004', message: 'Content is very short for an EPUB publication', severity: 'minor', suggestion: 'Consider expanding content or using a different format', }); } // Validate chapters if (metadata.chaptersCount === 0) { issues.push({ type: 'error', code: 'EPUB-005', message: 'No chapters found for EPUB export', severity: 'critical', suggestion: 'Create at least one chapter with content', }); } return metadata; } private validateContent( project: EnhancedProject, chapters: Chapter[], issues: EPUBValidationIssue[], ) { chapters.forEach((chapter, _index) => { const chapterNumber = index + 1; // Validate chapter title if (!chapter.title?.trim()) { issues.push({ type: 'warning', code: 'EPUB-101', message: `Chapter ${chapterNumber} is missing a title`, location: `Chapter ${chapterNumber}`, severity: 'minor', suggestion: 'Add a descriptive title to improve navigation', }); } // Validate chapter content if (!chapter.scenes?.length) { issues.push({ type: 'warning', code: 'EPUB-102', message: `Chapter ${chapterNumber} has no scenes or content`, location: `Chapter ${chapterNumber}`, severity: 'major', suggestion: 'Add content to this chapter or remove it', }); } else { // Check for empty scenes const emptyScenes = chapter.scenes.filter((scene) => !scene.content?.trim()).length; if (emptyScenes > 0) { issues.push({ type: 'warning', code: 'EPUB-103', message: `Chapter ${chapterNumber} has ${emptyScenes} empty scene(s)`, location: `Chapter ${chapterNumber}`, severity: 'minor', suggestion: 'Remove empty scenes or add content to them', }); } } // Check chapter length const wordCount = chapter.totalWordCount || 0; if (wordCount < 100) { issues.push({ type: 'info', code: 'EPUB-104', message: `Chapter ${chapterNumber} is very short (${wordCount} words)`, location: `Chapter ${chapterNumber}`, severity: 'minor', suggestion: 'Consider expanding this chapter or merging with another', }); } }); } private validateStructure(chapters: Chapter[], issues: EPUBValidationIssue[]) { // Check for logical chapter ordering const chapterOrders = chapters.map((ch) => ch.order).filter((order) => order !== undefined); if (chapterOrders.length > 0) { const sortedOrders = [...chapterOrders].sort((a, _b) => a - b); const hasGaps = sortedOrders.some((order, _index) => { const previousOrder = sortedOrders[index - 1]; return index > 0 && previousOrder !== undefined && order !== previousOrder + 1; }); if (hasGaps) { issues.push({ type: 'info', code: 'EPUB-201', message: 'Chapter ordering has gaps or inconsistencies', severity: 'minor', suggestion: 'Review chapter order for logical progression', }); } } // Check for very uneven chapter lengths if (chapters.length > 1) { const wordCounts = chapters.map((ch) => ch.totalWordCount || 0).filter((count) => count > 0); if (wordCounts.length > 1) { const avg = wordCounts.reduce((a, _b) => a + b, 0) / wordCounts.length; const hasExtremeLengths = wordCounts.some((count) => count < avg * 0.2 || count > avg * 5); if (hasExtremeLengths) { issues.push({ type: 'info', code: 'EPUB-202', message: 'Chapters have very uneven lengths', severity: 'minor', suggestion: 'Consider balancing chapter lengths for better reading experience', }); } } } } private validateManuscriptFormatting( project: EnhancedProject, chapters: Chapter[], issues: EPUBValidationIssue[], ) { const totalWordCount = chapters.reduce((sum, _ch) => sum + (ch.totalWordCount || 0), 0); const formatting = { hasProperMargins: true, // We assume template has proper margins hasCorrectFontSize: true, // Template enforces 12pt hasDoubleSpacing: true, // Template enforces 2.0 spacing hasRunningHeader: true, // Template includes header hasPageNumbers: true, // Template includes page numbers wordCountEstimate: totalWordCount, pageEstimate: Math.ceil(totalWordCount / 250), // Roughly 250 words per double-spaced page }; // Check word count for manuscript submissions if (totalWordCount < 50000) { issues.push({ type: 'info', code: 'MS-001', message: `Word count (${totalWordCount.toLocaleString()}) may be low for novel manuscript submissions`, severity: 'minor', suggestion: 'Most novels are 70,000-100,000 words. Verify this aligns with your target genre.', }); } else if (totalWordCount > 120000) { issues.push({ type: 'warning', code: 'MS-002', message: `Word count (${totalWordCount.toLocaleString()}) is high for first-time novel submissions`, severity: 'minor', suggestion: 'Consider if the manuscript could be tightened. Very long first novels are harder to sell.', }); } return formatting; } private validateManuscriptContent( project: EnhancedProject, chapters: Chapter[], issues: EPUBValidationIssue[], ) { // Check for placeholder text that should be replaced const placeholderPatterns = [ /\[your name\]/i, /\[author name\]/i, /\[insert.*\]/i, /\[todo.*\]/i, /\[surname\]/i, /\[address\]/i, /\[phone\]/i, /\[email\]/i, ]; chapters.forEach((chapter, _index) => { const chapterNumber = index + 1; chapter.scenes?.forEach((scene, _sceneIndex) => { if (scene.content) { placeholderPatterns.forEach((pattern) => { if (pattern.test(scene.content)) { issues.push({ type: 'warning', code: 'MS-101', message: `Placeholder text found in Chapter ${chapterNumber}, Scene ${sceneIndex + 1}`, location: `Chapter ${chapterNumber}, Scene ${sceneIndex + 1}`, severity: 'major', suggestion: 'Replace placeholder text with actual content before submission', }); } }); } }); }); // Check project-level placeholders if (project.description?.includes('[') || project.genre?.includes('[')) { issues.push({ type: 'warning', code: 'MS-102', message: 'Project description or genre contains placeholder text', severity: 'major', suggestion: 'Update project metadata with actual information', }); } } private calculateQualityScore(issues: EPUBValidationIssue[], metadata: any): number { let score = 100; // Deduct points based on issue severity issues.forEach((issue) => { switch (issue.severity) { case 'critical': score -= 25; break; case 'major': score -= 10; break; case 'minor': score -= 5; break; } }); // Bonus points for good metadata if (metadata.hasTitle) score += 5; if (metadata.hasAuthor) score += 5; if (metadata.hasTableOfContents) score += 5; if (metadata.totalWordCount > 10000) score += 5; return Math.max(0, Math.min(100, score)); } private calculateManuscriptCompliance(formatting: any, issues: EPUBValidationIssue[]): number { let score = 100; // Deduct for formatting issues if (!formatting.hasProperMargins) score -= 15; if (!formatting.hasCorrectFontSize) score -= 15; if (!formatting.hasDoubleSpacing) score -= 15; if (!formatting.hasRunningHeader) score -= 10; if (!formatting.hasPageNumbers) score -= 10; // Deduct for content issues issues.forEach((issue) => { switch (issue.severity) { case 'critical': score -= 20; break; case 'major': score -= 10; break; case 'minor': score -= 3; break; } }); return Math.max(0, Math.min(100, score)); } private determineReadinessLevel( score: number, issues: EPUBValidationIssue[], ): 'not-ready' | 'needs-work' | 'good' | 'excellent' { const hasCriticalIssues = issues.some((issue) => issue.severity === 'critical'); if (hasCriticalIssues || score < 50) { return 'not-ready'; } else if (score < 70) { return 'needs-work'; } else if (score < 90) { return 'good'; } else { return 'excellent'; } } /** * Get a pre-export checklist for manuscript submissions */ getManuscriptChecklist(project: EnhancedProject): Array<{ item: string; completed: boolean; required: boolean; suggestion?: string; }> { const totalWordCount = project.currentWordCount || 0; return [ { item: 'Project has a clear title', completed: !!project.name?.trim(), required: true, suggestion: 'Add a compelling title that represents your work', }, { item: 'Word count is appropriate for genre', completed: totalWordCount >= 50000 && totalWordCount <= 120000, required: false, suggestion: 'Novels typically range 70k-100k words for most genres', }, { item: 'All chapters have titles', completed: (project.chapters || []).every((ch) => !!ch.title?.trim()), required: false, suggestion: 'Clear chapter titles improve navigation and professional appearance', }, { item: 'No placeholder text remains', completed: !this.hasPlaceholderText(project), required: true, suggestion: 'Replace all [brackets] and placeholder text with actual content', }, { item: 'Genre is specified', completed: !!project.genre?.trim() && !project.genre.includes('['), required: true, suggestion: 'Specify the genre for proper categorization', }, { item: 'Project description/synopsis exists', completed: !!project.description?.trim() && project.description.length > 50, required: false, suggestion: 'A good synopsis is essential for submissions', }, ]; } private hasPlaceholderText(project: EnhancedProject): boolean { const placeholderPattern = /\[.*\]/; if (placeholderPattern.test(project.name || '')) return true; if (placeholderPattern.test(project.description || '')) return true; if (placeholderPattern.test(project.genre || '')) return true; return (project.chapters || []).some((chapter) => chapter.scenes?.some((scene: any) => placeholderPattern.test(scene.content || '')), ); } } export const epubValidationService = new EPUBValidationService(); export default epubValidationService;
/Users/davehail/Developer/inkwell/public/assets/brand/README.md:48:To quickly generate placeholder assets for development, you can use:
/Users/davehail/Developer/inkwell/src/features/plotboards/components/filters/FilterPanel.tsx:1:// Filter panel component for Plot Boards // Provides intuitive interface for filtering and searching cards import React, { useState, useCallback, useMemo } from 'react'; import { PlotCardFilterEngine, FilterContext, PRESET_FILTERS } from '../../filters/filtering'; import { PlotBoardFilters, PlotCardStatus, PlotCardPriority } from '../../types'; interface FilterPanelProps { filters: PlotBoardFilters; filterContext: FilterContext; filterStats: { availableStatuses: { value: PlotCardStatus; count: number; label: string }[]; availablePriorities: { value: PlotCardPriority; count: number; label: string }[]; availableTags: { value: string; count: number }[]; availableChapters: { value: string; count: number; title: string }[]; dateRange: { earliest: Date; latest: Date } | null; }; onFiltersChange: (_filters: PlotBoardFilters) => void; onContextChange: (_context: FilterContext) => void; onClearAll: () => void; isExpanded: boolean; onToggleExpanded: () => void; resultCount?: number; totalCount?: number; } export const FilterPanel: React.FC<FilterPanelProps> = ({ filters, _filterContext, _filterStats, _onFiltersChange, _onContextChange, _onClearAll, _isExpanded, _onToggleExpanded, _resultCount = 0, _totalCount = 0,  }) => { const [activeTab, setActiveTab] = useState<'filters' | 'search' | 'presets'>('filters'); // Calculate active filter count const activeFilterCount = useMemo(() => { const engine = new PlotCardFilterEngine(filters, filterContext); return engine.getActiveFilterCount(); }, [filters, filterContext]); // Handle status filter changes const handleStatusChange = useCallback( (status: PlotCardStatus, _checked: boolean) => { const currentStatuses = filters.statuses || []; const newStatuses = checked ? [...currentStatuses, status] : currentStatuses.filter((s) => s !== status); onFiltersChange({ ...filters, statuses: newStatuses }); }, [filters, onFiltersChange], ); // Handle priority filter changes const handlePriorityChange = useCallback( (priority: PlotCardPriority, _checked: boolean) => { const currentPriorities = filters.priorities || []; const newPriorities = checked ? [...currentPriorities, priority] : currentPriorities.filter((p) => p !== priority); onFiltersChange({ ...filters, priorities: newPriorities }); }, [filters, onFiltersChange], ); // Handle tag filter changes const handleTagChange = useCallback( (tag: string, _checked: boolean) => { const currentTags = filters.tags || []; const newTags = checked ? [...currentTags, tag] : currentTags.filter((t) => t !== tag); onFiltersChange({ ...filters, tags: newTags }); }, [filters, onFiltersChange], ); // Handle chapter filter changes const _handleChapterChange = useCallback( (chapterId: string, _checked: boolean) => { const currentChapters = filters.chapters || []; const newChapters = checked ? [...currentChapters, chapterId] : currentChapters.filter((c) => c !== chapterId); onFiltersChange({ ...filters, chapters: newChapters }); }, [filters, onFiltersChange], ); // Handle date range changes const handleDateRangeChange = useCallback( (from: string, _to: string) => { const dateRange = from && to ? { from: new Date(from), to: new Date(to), } : undefined; onFiltersChange({ ...filters, dateRange }); }, [filters, onFiltersChange], ); // Handle search term change const handleSearchChange = useCallback( (searchTerm: string) => { onContextChange({ ...filterContext, searchTerm }); }, [filterContext, onContextChange], ); // Handle preset filter application const handlePresetApply = useCallback( (presetKey: keyof typeof PRESET_FILTERS) => { const presetEngine = PRESET_FILTERS[presetKey](); const presetConfig = presetEngine.exportConfig(); onFiltersChange(presetConfig.filters); onContextChange(presetConfig.context); }, [onFiltersChange, onContextChange], ); // Handle clear specific filter const handleClearFilter = useCallback( (filterType: keyof PlotBoardFilters | 'search') => { if (filterType === 'search') { onContextChange({ ...filterContext, searchTerm: undefined }); } else if (filterType === 'dateRange') { onFiltersChange({ ...filters, dateRange: undefined }); } else if (Array.isArray(filters[filterType])) { onFiltersChange({ ...filters, [filterType]: [] }); } }, [filters, filterContext, onFiltersChange, onContextChange], ); return ( <div className="bg-white border-b border-gray-200"> {/* Filter Bar */} <div className="px-4 py-3 flex items-center justify-between"> <div className="flex items-center space-x-4"> <button onClick={onToggleExpanded} className="flex items-center space-x-2 text-sm font-medium text-gray-700 hover:text-gray-900" > <svg className={`w-4 h-4 transition-transform ${isExpanded ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" > <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /> </svg> <span>Filters</span> {activeFilterCount > 0 && ( <span className="bg-blue-600 text-white text-xs rounded-full px-2 py-1"> {activeFilterCount} </span> )} </button> {/* Quick Search */} <div className="relative"> <input type="text" placeholder="Search cards..." value={filterContext.searchTerm || ''} onChange={(_e) => handleSearchChange(e.target.value)} className="w-64 pl-8 pr-4 py-2 text-sm border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" /> <svg className="absolute left-2.5 top-2.5 h-3 w-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" > <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /> </svg> </div> </div> <div className="flex items-center space-x-4"> {/* Result Count */} <span className="text-sm text-gray-600"> {resultCount === totalCount ? `${totalCount} cards` : `${resultCount} of ${totalCount} cards`} </span> {/* Clear All */} {activeFilterCount > 0 && ( <button onClick={onClearAll} className="text-sm text-red-600 hover:text-red-800"> Clear all </button> )} </div> </div> {/* Expanded Filter Panel */} {isExpanded && ( <div className="px-4 pb-4 border-t border-gray-100"> {/* Tab Navigation */} <div className="flex space-x-1 mb-4 mt-4"> {[ { key: 'filters' as const, _label: 'Filters', _icon: '🔍' },  { key: 'search' as const, _label: 'Search', _icon: '📝' },  { key: 'presets' as const, _label: 'Presets', _icon: '⭐' },  ].map((tab) => ( <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`px-3 py-2 text-sm font-medium rounded-md transition-colors ${ activeTab === tab.key ? 'bg-blue-100 text-blue-700' : 'text-gray-600 hover:text-gray-900 hover:bg-gray-50' }`} > <span className="mr-1">{tab.icon}</span> {tab.label} </button> ))} </div> {/* Filter Content */} <div className="space-y-6"> {activeTab === 'filters' && ( <div className="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-4 gap-6"> {/* Status Filters */} {filterStats.availableStatuses.length > 0 && ( <div> <div className="flex items-center justify-between mb-3"> <label className="text-sm font-medium text-gray-900">Status</label> {(filters.statuses || []).length > 0 && ( <button onClick={() => handleClearFilter('statuses')} className="text-xs text-gray-500 hover:text-gray-700" > Clear </button> )} </div> <div className="space-y-2"> {filterStats.availableStatuses.map((status) => ( <label key={status.value} className="flex items-center"> <input type="checkbox" checked={(filters.statuses || []).includes(status.value)} onChange={(_e) => handleStatusChange(status.value, e.target.checked)} className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" /> <span className="ml-2 text-sm text-gray-700"> {status.label} ({status.count}) </span> </label> ))} </div> </div> )} {/* Priority Filters */} {filterStats.availablePriorities.length > 0 && ( <div> <div className="flex items-center justify-between mb-3"> <label className="text-sm font-medium text-gray-900">Priority</label> {(filters.priorities || []).length > 0 && ( <button onClick={() => handleClearFilter('priorities')} className="text-xs text-gray-500 hover:text-gray-700" > Clear </button> )} </div> <div className="space-y-2"> {filterStats.availablePriorities.map((priority) => ( <label key={priority.value} className="flex items-center"> <input type="checkbox" checked={(filters.priorities || []).includes(priority.value)} onChange={(_e) => handlePriorityChange(priority.value, e.target.checked)} className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" /> <span className="ml-2 text-sm text-gray-700 flex items-center"> <PriorityIndicator priority={priority.value} /> {priority.label} ({priority.count}) </span> </label> ))} </div> </div> )} {/* Tag Filters */} {filterStats.availableTags.length > 0 && ( <div> <div className="flex items-center justify-between mb-3"> <label className="text-sm font-medium text-gray-900">Tags</label> {(filters.tags || []).length > 0 && ( <button onClick={() => handleClearFilter('tags')} className="text-xs text-gray-500 hover:text-gray-700" > Clear </button> )} </div> <div className="max-h-32 overflow-y-auto space-y-2"> {filterStats.availableTags.slice(0, 10).map((tag) => ( <label key={tag.value} className="flex items-center"> <input type="checkbox" checked={(filters.tags || []).includes(tag.value)} onChange={(_e) => handleTagChange(tag.value, e.target.checked)} className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" /> <span className="ml-2 text-sm text-gray-700"> #{tag.value} ({tag.count}) </span> </label> ))} {filterStats.availableTags.length > 10 && ( <p className="text-xs text-gray-500 mt-2"> +{filterStats.availableTags.length - 10} more tags </p> )} </div> </div> )} {/* Date Range Filter */} {filterStats.dateRange && ( <div> <div className="flex items-center justify-between mb-3"> <label className="text-sm font-medium text-gray-900">Updated Date</label> {filters.dateRange && ( <button onClick={() => handleClearFilter('dateRange')} className="text-xs text-gray-500 hover:text-gray-700" > Clear </button> )} </div> <div className="space-y-2"> <input type="date" value={filters.dateRange?.from.toISOString().split('T')[0] || ''} min={filterStats.dateRange.earliest.toISOString().split('T')[0]} max={filterStats.dateRange.latest.toISOString().split('T')[0]} onChange={(_e) => handleDateRangeChange( e.target.value, filters.dateRange?.to.toISOString().split('T')[0] || e.target.value, ) } className="w-full px-3 py-1 text-sm border border-gray-300 rounded focus:ring-blue-500 focus:border-blue-500" placeholder="From" /> <input type="date" value={filters.dateRange?.to.toISOString().split('T')[0] || ''} min={ filters.dateRange?.from.toISOString().split('T')[0] || filterStats.dateRange.earliest.toISOString().split('T')[0] } max={filterStats.dateRange.latest.toISOString().split('T')[0]} onChange={(_e) => handleDateRangeChange( filters.dateRange?.from.toISOString().split('T')[0] || e.target.value, e.target.value, ) } className="w-full px-3 py-1 text-sm border border-gray-300 rounded focus:ring-blue-500 focus:border-blue-500" placeholder="To" /> </div> </div> )} </div> )} {activeTab === 'search' && ( <div className="max-w-lg space-y-4"> <div> <label className="block text-sm font-medium text-gray-900 mb-2"> Search Term </label> <input type="text" value={filterContext.searchTerm || ''} onChange={(e) => handleSearchChange(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="Enter search term..." /> <p className="mt-1 text-xs text-gray-500"> Search in card titles, descriptions, tags, and notes </p> </div> <div className="space-y-3"> <label className="flex items-center"> <input type="checkbox" checked={!filterContext.caseSensitive} onChange={(_e) => onContextChange({ ...filterContext, caseSensitive: !e.target.checked, }) } className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" /> <span className="ml-2 text-sm text-gray-700">Case insensitive</span> </label> <label className="flex items-center"> <input type="checkbox" checked={filterContext.includeDescriptions !== false} onChange={(_e) => onContextChange({ ...filterContext, includeDescriptions: e.target.checked, }) } className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" /> <span className="ml-2 text-sm text-gray-700">Search descriptions</span> </label> <label className="flex items-center"> <input type="checkbox" checked={filterContext.includeNotes !== false} onChange={(_e) => onContextChange({ ...filterContext, includeNotes: e.target.checked, }) } className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" /> <span className="ml-2 text-sm text-gray-700">Search notes</span> </label> </div> </div> )} {activeTab === 'presets' && ( <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4"> {Object.entries(PRESET_FILTERS).map(([key,  presetFn]) => { const presetEngine = presetFn(); const _presetConfig = presetEngine.exportConfig(); return ( <button key={key} onClick={() => handlePresetApply(key as keyof typeof PRESET_FILTERS)} className="p-4 text-left border border-gray-200 rounded-lg hover:border-blue-300 hover:bg-blue-50 transition-colors" > <div className="font-medium text-sm text-gray-900 mb-1 capitalize"> {key.replace(/([A-Z])/g, ' $1').trim()} </div> <div className="text-xs text-gray-600"> {presetEngine.getActiveFilterCount()} filters active </div> </button> ); })} </div> )} </div> </div> )} {/* Active Filters Summary */} {activeFilterCount > 0 && !isExpanded && ( <div className="px-4 py-2 bg-blue-50 border-t border-blue-100"> <div className="flex flex-wrap gap-2"> {(filters.statuses || []).map((status) => ( <FilterChip key={`status-${status}`} label={`Status: ${status.replace('_', ' ')}`} onRemove={() => handleStatusChange(status, false)} /> ))} {(filters.priorities || []).map((priority) => ( <FilterChip key={`priority-${priority}`} label={`Priority: ${priority}`} onRemove={() => handlePriorityChange(priority, false)} /> ))} {(filters.tags || []).slice(0, 3).map((tag) => ( <FilterChip key={`tag-${tag}`} label={`Tag: ${tag}`} onRemove={() => handleTagChange(tag, false)} /> ))} {(filters.tags || []).length > 3 && ( <span className="text-xs text-gray-600 px-2 py-1"> +{(filters.tags || []).length - 3} more tags </span> )} {filterContext.searchTerm && ( <FilterChip label={`Search: "${filterContext.searchTerm}"`} onRemove={() => handleSearchChange('')} /> )} </div> </div> )} </div> ); }; // Helper Components const PriorityIndicator: React.FC<{ priority: PlotCardPriority }> = ({ priority }) => { const colors = { low: 'text-gray-400', medium: 'text-blue-400', high: 'text-orange-400', critical: 'text-red-500', }; return <span className={`mr-1 ${colors[priority]}`}>●</span>; }; const FilterChip: React.FC<{ label: string; onRemove: () => void; }> = ({ label,  onRemove }) => ( <span className="inline-flex items-center px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800"> {label} <button onClick={onRemove} className="ml-1 text-blue-600 hover:text-blue-800"> × </button> </span> );
/Users/davehail/Developer/inkwell/src/workers/search.worker.ts:105:        // TODO: Implement document updates
/Users/davehail/Developer/inkwell/src/services/realTimeConsistencyCoordinator.ts:1:// src/services/realTimeConsistencyCoordinator.ts - Unified real-time consistency checking coordinator import type { EnhancedProject } from '@/types/project'; import type { Scene, Chapter } from '@/types/writing'; import { debounce } from '@/utils/debounce'; import { phraseAnalysisService } from '@/utils/textAnalysis'; import { characterConsistencyAnalyzer } from './characterConsistencyAnalyzer'; import { voiceConsistencyService } from './voiceConsistencyService'; import type { CharacterTraitIssue } from './characterConsistencyAnalyzer'; import type { VoiceConsistencyWarning } from './voiceConsistencyService'; // Unified issue type that includes all consistency issues export type UnifiedConsistencyIssue = { id: string; type: | 'character' | 'voice' | 'phrase' | 'timeline' | 'world' | 'plot' | 'voice-inconsistency' | 'personality-contradiction' | 'behavior-inconsistency' | 'voice-mismatch' | 'relationship-conflict'; severity: 'low' | 'medium' | 'high' | 'critical'; title: string; description: string; suggestion: string; startPos: number; endPos: number; text: string; source: 'character-analyzer' | 'voice-service' | 'phrase-analysis' | 'timeline-check'; metadata?: Record<string, any>; }; export interface ConsistencyAnalysisOptions { enableCharacterChecks: boolean; enableVoiceChecks: boolean; enablePhraseChecks: boolean; enableTimelineChecks: boolean; debounceMs: number; minWordCount: number; confidenceThreshold: number; } export interface ConsistencyAnalysisResult { issues: UnifiedConsistencyIssue[]; analysisTime: number; totalChecks: number; cacheHits: number; } class RealTimeConsistencyCoordinator { private readonly CACHE_DURATION = 3 * 60 * 1000; // 3 minutes private cache = new Map<string, { result: ConsistencyAnalysisResult; timestamp: number }>(); private analysisCallbacks: ((issues: UnifiedConsistencyIssue[]) => void)[] = []; private currentIssues: UnifiedConsistencyIssue[] = []; private defaultOptions: ConsistencyAnalysisOptions = { enableCharacterChecks: true, enableVoiceChecks: true, enablePhraseChecks: true, enableTimelineChecks: false, // More expensive, disabled by default debounceMs: 1500, minWordCount: 50, confidenceThreshold: 0.4, }; // Debounced analysis function private debouncedAnalyze = debounce( ( content: string, _project: EnhancedProject, _scene: Scene, _chapter: Chapter, _options: ConsistencyAnalysisOptions,  ) => { this.performComprehensiveAnalysis(content, project, scene, chapter, options); }, this.defaultOptions.debounceMs, ); /** * Register a callback to be notified when issues are updated */ onIssuesUpdated(_callback: (issues: UnifiedConsistencyIssue[]) => void): () => void { this.analysisCallbacks.push(callback); // Return unsubscribe function _return () => { const index = this.analysisCallbacks.indexOf(callback); if (index > -1) { this.analysisCallbacks.splice(index, 1); } }; } /** * Main entry point for real-time consistency analysis */ analyzeContent( content: string, project: EnhancedProject, scene: Scene, chapter: Chapter, options: Partial<ConsistencyAnalysisOptions> = {}, ): void { const mergedOptions = { ...this.defaultOptions, ...options }; // Update debounce timing if changed if (options.debounceMs && options.debounceMs !== this.defaultOptions.debounceMs) { this.debouncedAnalyze = debounce( ( content: string, _project: EnhancedProject, _scene: Scene, _chapter: Chapter, _options: ConsistencyAnalysisOptions,  ) => { this.performComprehensiveAnalysis(content, project, scene, chapter, options); }, options.debounceMs, ); } // Skip if content too short const wordCount = content.split(/\s+/).filter((word) => word.length > 0).length; if (wordCount < mergedOptions.minWordCount) { this.updateIssues([]); return; } this.debouncedAnalyze(content, project, scene, chapter, mergedOptions); } /** * Perform comprehensive real-time consistency analysis */ private async performComprehensiveAnalysis( content: string, project: EnhancedProject, scene: Scene, chapter: Chapter, options: ConsistencyAnalysisOptions, ): Promise<void> { const startTime = Date.now(); const cacheKey = `${project.id}-${scene.id}-${this.hashContent(content)}`; // Check cache first const cached = this.cache.get(cacheKey); if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) { this.updateIssues(cached.result.issues); return; } const allIssues: UnifiedConsistencyIssue[] = []; const plainText = this.stripHTML(content); let totalChecks = 0; let cacheHits = 0; try { // Run all enabled consistency checks in parallel const analysisPromises: Promise<UnifiedConsistencyIssue[]>[] = []; // 1. Character consistency analysis (AI-powered) if (options.enableCharacterChecks) { totalChecks++; analysisPromises.push( this.runCharacterConsistencyAnalysis(plainText, project, scene, chapter), ); } // 2. Voice consistency analysis (Pattern-based + AI) if (options.enableVoiceChecks) { totalChecks++; analysisPromises.push(this.runVoiceConsistencyAnalysis(plainText, project.id)); } // 3. Phrase hygiene analysis (Local pattern matching) if (options.enablePhraseChecks) { totalChecks++; analysisPromises.push(this.runPhraseHygieneAnalysis(plainText, project.id)); } // 4. Timeline consistency (Future enhancement - placeholder) if (options.enableTimelineChecks) { totalChecks++; analysisPromises.push( this.runTimelineConsistencyAnalysis(plainText, project, scene, chapter), ); } // Wait for all analyses to complete const results = await Promise.allSettled(analysisPromises); // Process results and collect issues results.forEach((result, _index) => { if (result.status === 'fulfilled') { allIssues.push(...result.value); } else { devLog.error(`Consistency check ${index} failed:`, result.reason); } }); // Sort issues by severity and position const sortedIssues = this.sortAndPrioritizeIssues(allIssues); const analysisResult: ConsistencyAnalysisResult = { issues: sortedIssues, analysisTime: Date.now() - startTime, totalChecks, cacheHits, }; // Cache the result this.cache.set(cacheKey, { result: analysisResult, timestamp: Date.now() }); // Update current issues and notify callbacks this.updateIssues(sortedIssues); } catch (error) { devLog.error('Comprehensive consistency analysis failed:', error); // Don't interrupt the user's writing flow this.updateIssues([]); } } /** * Run character consistency analysis */ private async runCharacterConsistencyAnalysis( text: string, project: EnhancedProject, scene: Scene, chapter: Chapter, ): Promise<UnifiedConsistencyIssue[]> { try { const result = await characterConsistencyAnalyzer.analyzeCharacterConsistency( text, project, scene, chapter, ); return result.issues.map((issue) => this.convertCharacterIssue(issue)); } catch (error) { devLog.error('Character consistency analysis failed:', error); return []; } } /** * Run voice consistency analysis */ private async runVoiceConsistencyAnalysis( text: string, projectId: string, ): Promise<UnifiedConsistencyIssue[]> { try { const warnings = await voiceConsistencyService.analyzeTextForVoiceIssues(text, projectId); return warnings.map((warning) => this.convertVoiceWarning(warning)); } catch (error) { devLog.error('Voice consistency analysis failed:', error); return []; } } /** * Run phrase hygiene analysis */ private async runPhraseHygieneAnalysis( text: string, projectId: string, ): Promise<UnifiedConsistencyIssue[]> { try { const analysis = await phraseAnalysisService.analyzeText(text, projectId); const issues: UnifiedConsistencyIssue[] = []; // Convert phrase analysis to unified issues analysis.phrases.forEach((phrase) => { phrase.positions.forEach((position, _index) => { if (phrase.severity === 'high' || phrase.severity === 'medium') { issues.push({ id: `phrase-${phrase.phrase}-${index}-${Date.now()}`, type: 'phrase', severity: phrase.severity === 'high' ? 'high' : 'medium', title: `Overused phrase: "${phrase.phrase}"`, description: `This phrase appears ${phrase.count} times (${phrase.ngramSize}-gram)`, suggestion: `Consider using synonyms or rephrasing to avoid repetition`, startPos: position.start, endPos: position.end, text: phrase.phrase, source: 'phrase-analysis', metadata: { count: phrase.count, ngramSize: phrase.ngramSize, allPositions: phrase.positions, }, }); } }); }); return issues; } catch (error) { devLog.error('Phrase hygiene analysis failed:', error); return []; } } /** * Run timeline consistency analysis (placeholder for future enhancement) */ private async runTimelineConsistencyAnalysis( _text: string, _project: EnhancedProject, _scene: Scene, _chapter: Chapter, ): Promise<UnifiedConsistencyIssue[]> { // Placeholder - would implement timeline/chronology checking return []; } /** * Convert character trait issue to unified format */ private convertCharacterIssue(issue: CharacterTraitIssue): UnifiedConsistencyIssue { return { id: issue.id, type: issue.type, severity: issue.severity, title: issue.title, description: issue.description, suggestion: issue.suggestion, startPos: issue.startPos, endPos: issue.endPos, text: issue.textSegment, source: 'character-analyzer', metadata: { characterId: issue.characterId, characterName: issue.characterName, evidence: issue.evidence, }, }; } /** * Convert voice warning to unified format */ private convertVoiceWarning(warning: VoiceConsistencyWarning): UnifiedConsistencyIssue { return { id: warning.id, type: warning.type, severity: warning.severity, title: warning.title, description: warning.description, suggestion: warning.suggestion, startPos: warning.startPos, endPos: warning.endPos, text: warning.textSample, source: 'voice-service', metadata: { characterId: warning.characterId, characterName: warning.characterName, matchScore: warning.matchScore, deviations: warning.deviations, }, }; } /** * Sort and prioritize issues by severity and position */ private sortAndPrioritizeIssues(issues: UnifiedConsistencyIssue[]): UnifiedConsistencyIssue[] { const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 }; return issues.sort((a, _b) => { // First sort by severity (critical first) const severityDiff = severityOrder[b.severity] - severityOrder[a.severity]; if (severityDiff !== 0) return severityDiff; // Then sort by position in text (earlier issues first) return a.startPos - b.startPos; }); } /** * Update current issues and notify callbacks */ private updateIssues(issues: UnifiedConsistencyIssue[]): void { this.currentIssues = issues; // Notify all registered callbacks this.analysisCallbacks.forEach((callback) => { try { callback(issues); } catch (error) { devLog.error('Error in consistency analysis callback:', error); } }); } /** * Get current issues */ getCurrentIssues(): UnifiedConsistencyIssue[] { return [...this.currentIssues]; } /** * Clear all current issues */ clearIssues(): void { this.updateIssues([]); } /** * Resolve an issue by ID */ resolveIssue(issueId: string): boolean { const newIssues = this.currentIssues.filter((issue) => issue.id !== issueId); if (newIssues.length !== this.currentIssues.length) { this.updateIssues(newIssues); return true; } return false; } /** * Helper methods */ private stripHTML(text: string): string { return text.replace(/<[^>]*>/g, ''); } private hashContent(content: string): string { let hash = 0; for (let i = 0; i < content.length; i++) { const char = content.charCodeAt(i); hash = (hash << 5) - hash + char; hash = hash & hash; // Convert to 32-bit integer } return Math.abs(hash).toString(); } /** * Clear cache (useful for testing or memory management) */ clearCache(): void { this.cache.clear(); } /** * Get cache statistics */ getCacheStats(): { size: number; oldestEntry: number | null } { let oldestTimestamp: number | null = null; for (const [, { timestamp }] of this.cache) { if (oldestTimestamp === null || timestamp < oldestTimestamp) { oldestTimestamp = timestamp; } } return { size: this.cache.size, oldestEntry: oldestTimestamp, }; } } export const realTimeConsistencyCoordinator = new RealTimeConsistencyCoordinator();
/Users/davehail/Developer/inkwell/src/features/plotboards/types.ts:209:export const DEFAULT_PLOT_TEMPLATES: PlotBoardTemplate[] = [
/Users/davehail/Developer/inkwell/src/utils/storageAccess.ts:11:  // 1) Prefer a globally-stubbed localStorage (what tests patch)
/Users/davehail/Developer/inkwell/src/utils/projectBundle.ts:238:      repairOptions.push('Create placeholder scenes for empty chapters');
/Users/davehail/Developer/inkwell/src/components/Writing/WritingToolbar.tsx:1:// src/components/Writing/WritingToolbar.tsx import { Save, Sparkles, FileText, FileDown, File } from 'lucide-react'; import React from 'react'; import { ExportFormat } from '../../types/writing'; export interface WritingToolbarProps { title: string; onTitleChange: (value: string) => void; onManualSave: () => void; onExport: () => void; exportFormat: ExportFormat; setExportFormat: (format: ExportFormat) => void; onClaudeAssist: () => void; isSaving?: boolean; isExporting?: boolean; lastSaved?: Date | null; } const WritingToolbar: React.FC<WritingToolbarProps> = ({ title, onTitleChange, onManualSave, onExport, exportFormat, setExportFormat, onClaudeAssist, isSaving = false, isExporting = false, lastSaved, }) => { const getExportIcon = () => { switch (exportFormat) { case 'markdown': return <FileText className="w-4 h-4" />; case 'docx': return <FileDown className="w-4 h-4" />; default: return <File className="w-4 h-4" />; } }; return ( <div className="flex flex-col gap-3 p-4 bg-white border-b border-gray-200"> {/* Title and Primary Actions */} <div className="flex items-center gap-3"> <input type="text" value={title} onChange={(e) => onTitleChange(e.target.value)} placeholder="Document title..." className="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm text-gray-600 bg-white text-gray-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors duration-200" /> <button onClick={onManualSave} disabled={isSaving} className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200" > <Save className="w-4 h-4" /> {isSaving ? 'Saving...' : 'Save'} </button> <button onClick={onClaudeAssist} className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors duration-200" > <Sparkles className="w-4 h-4" /> Claude Assist </button> </div> {/* Export Controls and Status */} <div className="flex items-center justify-between"> <div className="flex items-center gap-3"> <select value={exportFormat} onChange={(e) => setExportFormat(e.target.value as ExportFormat)} className="px-3 py-2 border border-gray-300 rounded-lg text-sm text-gray-600 bg-white text-gray-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors duration-200" > <option value="markdown">Markdown (.md)</option> <option value="txt">Plain Text (.txt)</option> <option value="docx">Word Document (.docx)</option> </select> <button onClick={onExport} disabled={isExporting} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200" > {getExportIcon()} {isExporting ? 'Exporting...' : 'Export'} </button> </div> {/* Last Saved Indicator */} {lastSaved && ( <div className="text-xs text-gray-500 text-gray-500"> Last saved: {lastSaved.toLocaleTimeString()} </div> )} </div> </div> ); }; export default WritingToolbar; 
/Users/davehail/Developer/inkwell/src/components/Writing/FallbackEditor.tsx:1:// src/components/Writing/FallbackEditor.tsx import React, { useState, useEffect, useRef } from 'react'; import { cn } from '../../utils/cn'; interface FallbackEditorProps { content: string; onChange: (content: string) => void; onWordCountChange?: (count: number) => void; placeholder?: string; className?: string; wordCountGoal?: number; } export const FallbackEditor: React.FC<FallbackEditorProps> = ({ content, onChange, onWordCountChange, placeholder = 'Start writing your scene...', className, wordCountGoal = 0, }) => { const [isFocusMode, setIsFocusMode] = useState(false); const [showWordCount, setShowWordCount] = useState(true); const textareaRef = useRef<HTMLTextAreaElement>(null); // Convert HTML content to plain text for textarea const htmlToText = (html: string): string => { const div = document.createElement('div'); div.innerHTML = html; return div.textContent || div.innerText || ''; }; // Convert plain text to simple HTML const textToHtml = (text: string): string => { return text .split('\n\n') .map((paragraph) => paragraph.trim()) .filter((paragraph) => paragraph.length > 0) .map((paragraph) => `<p>${paragraph.replace(/\n/g, '<br>')}</p>`) .join(''); }; const [textContent, setTextContent] = useState(htmlToText(content)); const countWords = (text: string): number => { return text .trim() .split(/\s+/) .filter((word) => word.length > 0).length; }; const wordCount = countWords(textContent); const characterCount = textContent.length; const goalProgress = wordCountGoal > 0 ? (wordCount / wordCountGoal) * 100 : 0; useEffect(() => { onWordCountChange?.(wordCount); }, [wordCount, onWordCountChange]); const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const newText = e.target.value; setTextContent(newText); onChange(textToHtml(newText)); }; // Auto-resize textarea useEffect(() => { if (textareaRef.current) { textareaRef.current.style.height = 'auto'; textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`; } }, [textContent]); // Keyboard shortcuts useEffect(() => { const handleKeyDown = (event: KeyboardEvent) => { if ( event.key === 'F11' || ((event.metaKey || event.ctrlKey) && event.shiftKey && event.key === 'F') ) { event.preventDefault(); setIsFocusMode((prev) => !prev); } if (event.key === 'Escape' && isFocusMode) { setIsFocusMode(false); } }; document.addEventListener('keydown', handleKeyDown); return () => document.removeEventListener('keydown', handleKeyDown); }, [isFocusMode]); // Format text functions const formatText = (type: 'bold' | 'italic' | 'heading') => { if (!textareaRef.current) return; const textarea = textareaRef.current; const start = textarea.selectionStart; const end = textarea.selectionEnd; const selectedText = textContent.substring(start, end); let replacement = ''; switch (type) { case 'bold': replacement = `**${selectedText}**`; break; case 'italic': replacement = `*${selectedText}*`; break; case 'heading': replacement = `## ${selectedText}`; break; } const newText = textContent.substring(0, start) + replacement + textContent.substring(end); setTextContent(newText); onChange(textToHtml(newText)); // Restore focus and cursor position setTimeout(() => { textarea.focus(); textarea.setSelectionRange(start + replacement.length, start + replacement.length); }, 0); }; return ( <div className={cn('relative', className)}> {/* Toolbar */} {!isFocusMode && ( <div className="flex items-center justify-between mb-4 p-3 bg-gray-50 rounded-lg border"> <div className="flex items-center space-x-4"> <div className="flex items-center space-x-2"> <button onClick={() => formatText('bold')} className="px-3 py-1 rounded text-sm font-bold bg-white hover:bg-gray-100 border transition-colors" title="Bold (add **text**)" > B </button> <button onClick={() => formatText('italic')} className="px-3 py-1 rounded text-sm italic bg-white hover:bg-gray-100 border transition-colors" title="Italic (add *text*)" > I </button> <button onClick={() => formatText('heading')} className="px-3 py-1 rounded text-sm font-medium bg-white hover:bg-gray-100 border transition-colors" title="Heading (add ## text)" > H2 </button> </div> <div className="text-xs text-gray-500 hidden lg:block"> Tip: Use **bold**, *italic*, ## heading for formatting </div> </div> <div className="flex items-center space-x-2"> <button onClick={() => setShowWordCount(!showWordCount)} className="px-3 py-1 text-xs bg-white border rounded hover:bg-gray-50 transition-colors" > 📊 {showWordCount ? 'Hide' : 'Show'} Stats </button> <button onClick={() => setIsFocusMode(!isFocusMode)} className="px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors" title="Focus mode (F11)" > 🎯 Focus Mode </button> </div> </div> )} {/* Focus Mode Exit Button */} {isFocusMode && ( <button onClick={() => setIsFocusMode(false)} className="absolute top-4 right-4 z-10 px-4 py-2 bg-gray-900/90 text-white rounded-lg text-sm hover:bg-gray-900 transition-colors backdrop-blur shadow-lg" title="Exit focus mode (Esc)" > ← Exit Focus </button> )} {/* Editor Container */} <div className={cn( 'transition-all duration-300', isFocusMode ? 'fixed inset-0 z-50 bg-white p-8 overflow-y-auto' : 'relative', )} > <textarea ref={textareaRef} value={textContent} onChange={handleTextChange} placeholder={placeholder} className={cn( 'w-full min-h-[400px] p-4 border rounded-lg resize-none', 'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent', 'bg-white text-gray-900', 'placeholder-gray-500', 'font-mono text-base leading-relaxed', isFocusMode && 'max-w-4xl mx-auto pt-16 border-none focus:ring-0 bg-transparent', )} style={{ lineHeight: '1.6', fontSize: isFocusMode ? '1.125rem' : '1rem', }} /> </div> {/* Word Count Display */} {showWordCount && !isFocusMode && ( <div className="mt-4 p-3 bg-gray-50 rounded-lg border"> <div className="flex items-center justify-between text-sm text-gray-600"> <div className="flex items-center space-x-4"> <div className="flex items-center space-x-1"> <span>📝</span> <span className="font-medium">{wordCount} words</span> </div> <div>{characterCount} characters</div> {wordCountGoal > 0 && ( <div className="flex items-center space-x-2"> <span>🎯 Goal: {wordCountGoal}</span> <div className="w-24 h-2 bg-gray-200 rounded-full overflow-hidden"> <div className={cn( 'h-full transition-all duration-300', goalProgress >= 100 ? 'bg-green-500' : 'bg-blue-500', )} style={{ width: `${Math.min(goalProgress, 100)}%` }} /> </div> <span className={cn( 'text-xs font-medium', goalProgress >= 100 ? 'text-green-600' : 'text-blue-600', )} > {Math.round(goalProgress)}%{goalProgress >= 100 && ' ✅'} </span> </div> )} </div> </div> </div> )} {/* Focus Mode Stats */} {showWordCount && isFocusMode && ( <div className="fixed bottom-6 right-6 z-60 bg-gray-900/90 text-white px-4 py-3 rounded-lg text-sm backdrop-blur shadow-lg"> <div className="flex items-center space-x-3"> <span>📝 {wordCount} words</span> {wordCountGoal > 0 && ( <> <span className="opacity-60">|</span> <span className="opacity-75"> 🎯 {Math.round(goalProgress)}% of goal {goalProgress >= 100 && ' ✅'} </span> </> )} </div> </div> )} {/* Formatting Help */} {!isFocusMode && ( <div className="mt-2 text-xs text-gray-500"> 💡 Temporary fallback editor while TipTap is being fixed. Use **bold**, *italic*, ## heading for basic formatting. </div> )} </div> ); }; 
/Users/davehail/Developer/inkwell/src/lib/__tests__/profileMemory.test.ts:15:    vi.stubGlobal('localStorage', {
/Users/davehail/Developer/inkwell/src/components/Writing/EnhancedWritingPanel.tsx:311:            placeholder={
/Users/davehail/Developer/inkwell/src/components/Writing/EnhancedWritingPanel.tsx:324:              placeholder:text-slate-400 dark:placeholder:text-slate-500
/Users/davehail/Developer/inkwell/src/components/Writing/SceneEditor.tsx:1:// src/components/Writing/SceneEditor.tsx import { Save, Settings, Target, Clock, FileText, ChevronDown } from 'lucide-react'; import React, { useCallback, useState } from 'react'; import { Scene, SceneStatus } from '../../types/writing'; import { cn } from '../../utils/cn'; import TipTapEditor from './TipTapEditor'; interface SceneEditorProps { scene: Scene; onSceneUpdate: (sceneId: string, updates: Partial<Scene>) => void; onSave?: () => void; className?: string; } export const SceneEditor: React.FC<SceneEditorProps> = ({ scene, onSceneUpdate, onSave, className, }) => { const [showSettings, setShowSettings] = useState(false); const [localTitle, setLocalTitle] = useState(scene.title); const [localSummary, setLocalSummary] = useState(scene.summary || ''); const [localGoal, setLocalGoal] = useState(scene.wordCountGoal || 0); const handleContentChange = useCallback( (content: string) => { onSceneUpdate(scene.id, { content, updatedAt: new Date(), }); }, [scene.id, onSceneUpdate], ); const handleWordCountChange = useCallback( (wordCount: number) => { onSceneUpdate(scene.id, { wordCount, updatedAt: new Date(), }); }, [scene.id, onSceneUpdate], ); const handleStatusChange = (status: SceneStatus) => { onSceneUpdate(scene.id, { status, updatedAt: new Date(), }); }; const handleTitleBlur = () => { if (localTitle !== scene.title) { onSceneUpdate(scene.id, { title: localTitle, updatedAt: new Date(), }); } }; const handleSummaryBlur = () => { if (localSummary !== scene.summary) { onSceneUpdate(scene.id, { summary: localSummary, updatedAt: new Date(), }); } }; const handleGoalUpdate = () => { if (localGoal !== scene.wordCountGoal) { onSceneUpdate(scene.id, { wordCountGoal: localGoal, updatedAt: new Date(), }); } }; const getStatusColor = (status: SceneStatus) => { switch (status) { case SceneStatus.DRAFT: return 'bg-yellow-100 text-yellow-800 border-yellow-200'; case SceneStatus.REVISION: return 'bg-blue-100 text-blue-800 border-blue-200'; case SceneStatus.COMPLETE: return 'bg-green-100 text-green-800 border-green-200'; default: return 'bg-gray-100 text-gray-800 border-gray-200'; } }; const getStatusIcon = (status: SceneStatus) => { switch (status) { case SceneStatus.DRAFT: return '✏️'; case SceneStatus.REVISION: return '🔄'; case SceneStatus.COMPLETE: return '✅'; default: return '📝'; } }; return ( <div className={cn('space-y-4', className)}> {/* Scene Header */} <div className="bg-white rounded-lg border p-4 space-y-4"> {/* Title and Status Row */} <div className="flex items-center justify-between"> <input type="text" value={localTitle} onChange={(e) => setLocalTitle(e.target.value)} onBlur={handleTitleBlur} className="text-xl font-bold bg-transparent border-none outline-none flex-1 mr-4" placeholder="Scene title..." /> <div className="flex items-center space-x-2"> {/* Status Selector */} <div className="relative"> <select value={scene.status} onChange={(e) => handleStatusChange(e.target.value as SceneStatus)} className={cn( 'appearance-none px-3 py-1 rounded-full text-sm font-medium border cursor-pointer', getStatusColor(scene.status), )} > <option value={SceneStatus.DRAFT}>{getStatusIcon(SceneStatus.DRAFT)} Draft</option> <option value={SceneStatus.REVISION}> {getStatusIcon(SceneStatus.REVISION)} Revision </option> <option value={SceneStatus.COMPLETE}> {getStatusIcon(SceneStatus.COMPLETE)} Complete </option> </select> <ChevronDown className="absolute right-1 top-1/2 transform -translate-y-1/2 w-3 h-3 pointer-events-none" /> </div> {/* Settings Toggle */} <button onClick={() => setShowSettings(!showSettings)} className="p-2 rounded hover:bg-gray-100 transition-colors" title="Scene settings" > <Settings className="w-4 h-4" /> </button> {/* Save Button */} <button onClick={onSave} className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors text-sm" > <Save className="w-4 h-4 inline mr-1" /> Save </button> </div> </div> {/* Scene Summary */} <div> <label className="block text-sm font-medium text-gray-700 mb-1"> Scene Summary (optional) </label> <textarea value={localSummary} onChange={(e) => setLocalSummary(e.target.value)} onBlur={handleSummaryBlur} placeholder="Brief summary of what happens in this scene..." className="w-full px-3 py-2 border rounded-md bg-gray-50 text-sm resize-none" rows={2} /> </div> {/* Scene Settings (Collapsible) */} {showSettings && ( <div className="border-t pt-4 space-y-3"> <div className="grid grid-cols-1 md:grid-cols-3 gap-4"> {/* Word Count Goal */} <div> <label className="block text-sm font-medium text-gray-700 mb-1"> <Target className="w-4 h-4 inline mr-1" /> Word Count Goal </label> <input type="number" value={localGoal} onChange={(e) => setLocalGoal(parseInt(e.target.value) || 0)} onBlur={handleGoalUpdate} className="w-full px-3 py-2 border rounded-md bg-gray-50 text-sm" min="0" placeholder="0" /> </div> {/* Current Stats */} <div> <label className="block text-sm font-medium text-gray-700 mb-1"> <FileText className="w-4 h-4 inline mr-1" /> Current Words </label> <div className="px-3 py-2 bg-gray-100 rounded-md text-sm"> {scene.wordCount} words </div> </div> {/* Last Updated */} <div> <label className="block text-sm font-medium text-gray-700 mb-1"> <Clock className="w-4 h-4 inline mr-1" /> Last Updated </label> <div className="px-3 py-2 bg-gray-100 rounded-md text-sm"> {scene.updatedAt.toLocaleDateString()} </div> </div> </div> </div> )} </div> {/* TipTap Editor */} <TipTapEditor value={scene.content} onChange={handleContentChange} onWordCountChange={handleWordCountChange} placeholder={`Start writing "${scene.title}"...`} className="bg-white text-gray-900" /> </div> ); }; 
/Users/davehail/Developer/inkwell/src/components/Writing/LazyTipTapEditor.tsx:1:// src/components/Writing/LazyTipTapEditor.tsx import React, { lazy, Suspense } from 'react'; // Lazy load the heavy TipTap editor const TipTapEditor = lazy(() => import('./TipTapEditor')); interface LazyTipTapEditorProps { content: string; onChange: (content: string) => void; placeholder?: string; wordCount?: number; onWordCountChange?: (count: number) => void; className?: string; autoFocus?: boolean; } function TipTapLoadingFallback() { return ( <div className="flex items-center justify-center h-64 bg-white border border-gray-200 rounded-lg"> <div className="flex flex-col items-center space-y-2"> <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div> <p className="text-sm text-gray-500">Loading editor...</p> </div> </div> ); } export default function LazyTipTapEditor({ content, ...props }: LazyTipTapEditorProps) { return ( <Suspense fallback={<TipTapLoadingFallback />}> <TipTapEditor value={content} {...props} /> </Suspense> ); } 
/Users/davehail/Developer/inkwell/src/components/ProjectModal.tsx:1:// src/components/ProjectModal.tsx import React, { useEffect, useRef, useState } from 'react'; interface ProjectModalProps { isOpen: boolean; initialName?: string; initialDescription?: string; onClose: () => void; onCreate: (name: string, description: string) => void; } const ProjectModal: React.FC<ProjectModalProps> = ({ isOpen, initialName = '', initialDescription = '', onClose, onCreate, }) => { const [name, setName] = useState(initialName); const [description, setDescription] = useState(initialDescription); const [error, setError] = useState<string | null>(null); const inputRef = useRef<HTMLInputElement>(null); // Reset form when modal opens useEffect(() => { if (isOpen) { setName(initialName); setDescription(initialDescription); setError(null); setTimeout(() => inputRef.current?.focus(), 0); } }, [isOpen, initialName, initialDescription]); const handleCreate = () => { if (!name.trim()) { setError('Project name is required'); return; } onCreate(name.trim(), description.trim()); }; if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"> <div className="bg-white rounded-lg shadow-lg max-w-md w-full p-6"> <h2 className="text-xl font-semibold leading-snug font-semibold mb-4 text-gray-900"> Start New Project </h2> <label className="block mb-4 text-gray-700"> Project Name <span className="text-red-500">*</span> <input ref={inputRef} type="text" value={name} onChange={(e) => { setName(e.target.value); if (error) setError(null); }} placeholder="Enter project name" className="mt-1 block w-full px-3 py-2 border rounded-md bg-white text-gray-900 focus:outline-none focus:ring-2 focus:ring-indigo-500" /> </label> <label className="block mb-4 text-gray-700"> Project Description (optional) <textarea value={description} onChange={(e) => setDescription(e.target.value)} rows={4} placeholder="Add a description" className="mt-1 block w-full px-3 py-2 border rounded-md bg-white text-gray-900 resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500" /> </label> {error && <p className="text-red-500 text-sm mb-4">{error}</p>} <div className="flex justify-end space-x-4 mt-6"> <button onClick={onClose} type="button" className="px-4 py-2 rounded bg-gray-300 text-gray-800 hover:bg-gray-400 transition" > Cancel </button> <button onClick={handleCreate} type="button" className="px-4 py-2 rounded bg-green-600 text-white hover:bg-green-700 transition" > Create </button> </div> </div> </div> ); }; export default ProjectModal; 
/Users/davehail/Developer/inkwell/src/components/ClaudeAssistant.tsx:228:                placeholder={
/Users/davehail/Developer/inkwell/src/components/ClaudeAssistant.tsx:351:                placeholder="Character name..."
/Users/davehail/Developer/inkwell/src/components/ClaudeAssistant.tsx:379:                placeholder="Topic to explore..."
/Users/davehail/Developer/inkwell/src/components/Writing/ChapterWritingPanel.tsx:299:              placeholder="Chapter title"
/Users/davehail/Developer/inkwell/src/components/Writing/ChapterWritingPanel.tsx:325:                  placeholder="Start writing…"
/Users/davehail/Developer/inkwell/src/components/Writing/EnhancedWritingEditor.tsx:3:import Placeholder from '@tiptap/extension-placeholder';
/Users/davehail/Developer/inkwell/src/components/Writing/EnhancedWritingEditor.tsx:90:        placeholder: ({ node }) => {
/Users/davehail/Developer/inkwell/src/components/Writing/TipTapEditor.tsx:4:import Placeholder from '@tiptap/extension-placeholder';
/Users/davehail/Developer/inkwell/src/components/Writing/TipTapEditor.tsx:18:  placeholder?: string;
/Users/davehail/Developer/inkwell/src/components/Writing/TipTapEditor.tsx:29:  placeholder = 'Start writing…',
/Users/davehail/Developer/inkwell/src/components/Writing/TipTapEditor.tsx:55:        placeholder:
/Users/davehail/Developer/inkwell/src/components/Writing/TipTapEditor.tsx:58:            : placeholder,
/Users/davehail/Developer/inkwell/src/components/Writing/WhiteEditor.tsx:1:// src/components/Writing/WhiteEditor.tsx import React, { forwardRef } from 'react'; import { cn } from '@/utils/cn'; export interface WhiteEditorProps { value: string; onChange: (val: string) => void; onTextSelect?: () => void; placeholder?: string; disabled?: boolean; className?: string; } const WhiteEditor = forwardRef<HTMLDivElement, WhiteEditorProps>( ( { value, onChange, onTextSelect, placeholder = 'Start writing...', disabled = false, className, }, ref, ) => { return ( <div className="rounded-xl border border-slate-200 bg-white p-4 shadow-sm"> <div ref={ref} contentEditable={!disabled} suppressContentEditableWarning={true} className={cn( 'prose max-w-none min-h-[60vh] bg-white text-slate-900 focus:outline-none', 'placeholder:text-slate-400', disabled && 'cursor-not-allowed opacity-50', className, )} style={{ // Force white background and black text regardless of theme backgroundColor: '#ffffff', color: '#0f172a', // slate-900 }} onInput={(e) => { const target = e.currentTarget; onChange(target.textContent || ''); }} onSelect={onTextSelect} data-placeholder={placeholder} > {value} </div> </div> ); }, ); WhiteEditor.displayName = 'WhiteEditor'; export default WhiteEditor; 
/Users/davehail/Developer/inkwell/src/components/Views/TimelineView.tsx:1:// src/components/Views/TimelineView.tsx import { Clock, MapPin, User, Tag, Plus, Edit3, Trash2, Save, X } from 'lucide-react'; import React, { useState, useMemo, useCallback } from 'react'; import { useAppContext } from '@/context/AppContext'; import { useToast } from '@/context/toast'; // Remove unused import - we're using useEnhancedTimeline instead // Enhanced Timeline Event type that integrates with your project structure export interface TimelineEvent { id: string; title: string; description: string; // Flexible time handling - can be date or order index when: { type: 'date' | 'order'; value: number; // Unix timestamp for date, or order index displayText?: string; // "Chapter 3" or "Day 2 of journey" }; // Story context sceneId?: string; // Links to actual scene chapterId?: string; // Links to chapter characterIds: string[]; // Characters involved pov?: string; // Point of view character location?: string; tags: string[]; // Event importance and type importance: 'major' | 'minor' | 'background'; eventType: 'plot' | 'character' | 'world' | 'relationship'; // Metadata createdAt: Date; updatedAt: Date; } export interface TimelineFilters { pov: string | 'all'; location: string | 'all'; tags: string[]; importance: string | 'all'; eventType: string | 'all'; dateRange?: { start: number; end: number }; } interface TimelineViewProps { className?: string; } const TimelineView: React.FC<TimelineViewProps> = ({ className = '' }) => { const { currentProject } = useAppContext(); const { showToast } = useToast(); // Timeline state const [events, setEvents] = useState<TimelineEvent[]>([]); const [selectedEvent, setSelectedEvent] = useState<TimelineEvent | null>(null); const [isEditing, setIsEditing] = useState(false); const [showNewEventForm, setShowNewEventForm] = useState(false); const [filters, setFilters] = useState<TimelineFilters>({ pov: 'all', location: 'all', tags: [], importance: 'all', eventType: 'all', }); const [viewMode, setViewMode] = useState<'timeline' | 'list'>('timeline'); const [timelineType, setTimelineType] = useState<'date' | 'order'>('order'); // Get unique filter options from current project and events const filterOptions = useMemo(() => { const characters = (currentProject?.characters || []) as Array<{ id?: string; name?: string }>; const locations = new Set<string>(); const tags = new Set<string>(); const povs = new Set<string>(); events.forEach((event) => { if (event.location) locations.add(event.location); event.tags.forEach((tag) => tags.add(tag)); if (event.pov) povs.add(event.pov); }); return { characters: characters.map((char) => ({ id: char.id || `char-${char.name || 'unnamed'}`, name: char.name || 'Unnamed Character', })), locations: Array.from(locations), tags: Array.from(tags), povs: Array.from(povs), }; }, [currentProject, events]); // Filter and sort events const filteredEvents = useMemo(() => { const filtered = events.filter((event) => { if (filters.pov !== 'all' && event.pov !== filters.pov) return false; if (filters.location !== 'all' && event.location !== filters.location) return false; if (filters.importance !== 'all' && event.importance !== filters.importance) return false; if (filters.eventType !== 'all' && event.eventType !== filters.eventType) return false; if (filters.tags.length > 0 && !filters.tags.some((tag) => event.tags.includes(tag))) return false; return true; }); // Sort by timeline type return filtered.sort((a, b) => a.when.value - b.when.value); }, [events, filters]); // Create new event const createNewEvent = useCallback(() => { const newEvent: TimelineEvent = { id: `event-${Date.now()}`, title: '', description: '', when: { type: timelineType, value: timelineType === 'date' ? Date.now() : events.length + 1, }, characterIds: [], tags: [], importance: 'minor', eventType: 'plot', createdAt: new Date(), updatedAt: new Date(), }; setSelectedEvent(newEvent); setIsEditing(true); setShowNewEventForm(true); }, [timelineType, events.length]); // Save event const saveEvent = useCallback(() => { if (!selectedEvent) return; if (showNewEventForm) { setEvents((prev) => [...prev, selectedEvent]); setShowNewEventForm(false); } else { setEvents((prev) => prev.map((event) => event.id === selectedEvent.id ? { ...selectedEvent, updatedAt: new Date() } : event, ), ); } setIsEditing(false); showToast(`Event "${selectedEvent.title || 'Untitled'}" saved`, 'success'); }, [selectedEvent, showNewEventForm, showToast]); // Delete event const deleteEvent = useCallback( (eventId: string) => { if (confirm('Delete this event? This cannot be undone.')) { setEvents((prev) => prev.filter((e) => e.id !== eventId)); if (selectedEvent?.id === eventId) { setSelectedEvent(null); } showToast('Event deleted', 'success'); } }, [selectedEvent, showToast], ); // Update selected event const updateSelectedEvent = useCallback( (updates: Partial<TimelineEvent>) => { if (!selectedEvent) return; setSelectedEvent((prev) => (prev ? { ...prev, ...updates } : null)); }, [selectedEvent], ); // Get event color based on type and importance const getEventColor = (event: TimelineEvent) => { const baseColors = { plot: 'blue', character: 'purple', world: 'green', relationship: 'pink', }; const intensity = event.importance === 'major' ? '600' : event.importance === 'minor' ? '500' : '400'; const color = baseColors[event.eventType]; return `bg-${color}-${intensity} border-${color}-${parseInt(intensity) + 100}`; }; // Generate POV lanes for timeline view const povLanes = useMemo(() => { const lanes = new Map<string, TimelineEvent[]>(); filteredEvents.forEach((event) => { const pov = event.pov || 'General'; if (!lanes.has(pov)) { lanes.set(pov, []); } lanes.get(pov)!.push(event); }); return Array.from(lanes.entries()).map(([pov, events]) => ({ pov, events })); }, [filteredEvents]); if (!currentProject) { return ( <div className="h-full flex items-center justify-center text-gray-500"> <div className="text-center"> <Clock className="w-12 h-12 mx-auto mb-4 opacity-50" /> <h3 className="text-lg font-medium mb-2">No Project Selected</h3> <p className="text-sm">Select a project to create your story timeline</p> </div> </div> ); } return ( <div className={`h-full flex flex-col bg-white ${className}`}> {/* Header */} <div className="p-6 border-b border-gray-200"> <div className="flex items-center justify-between"> <div> <h1 className="text-2xl font-bold text-gray-900">Story Timeline</h1> <p className="text-gray-600 mt-1"> Map events across your story's chronology </p> </div> <div className="flex items-center space-x-3"> {/* View Mode Toggle */} <div className="flex bg-gray-100 rounded-lg p-1"> <button onClick={() => setViewMode('timeline')} className={`px-3 py-1 rounded text-sm font-medium transition-colors ${ viewMode === 'timeline' ? 'bg-white text-gray-900 shadow' : 'text-gray-600' }`} > Timeline </button> <button onClick={() => setViewMode('list')} className={`px-3 py-1 rounded text-sm font-medium transition-colors ${ viewMode === 'list' ? 'bg-white text-gray-900 shadow' : 'text-gray-600' }`} > List </button> </div> {/* Timeline Type Toggle */} <div className="flex bg-gray-100 rounded-lg p-1"> <button onClick={() => setTimelineType('order')} className={`px-3 py-1 rounded text-sm font-medium transition-colors ${ timelineType === 'order' ? 'bg-white text-gray-900 shadow' : 'text-gray-600' }`} > Story Order </button> <button onClick={() => setTimelineType('date')} className={`px-3 py-1 rounded text-sm font-medium transition-colors ${ timelineType === 'date' ? 'bg-white text-gray-900 shadow' : 'text-gray-600' }`} > Chronological </button> </div> <button onClick={createNewEvent} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg flex items-center space-x-2" > <Plus className="w-4 h-4" /> <span>Add Event</span> </button> </div> </div> {/* Filters */} <div className="mt-4 flex items-center gap-4 flex-wrap"> {/* POV Filter */} <select value={filters.pov} onChange={(e) => setFilters((prev) => ({ ...prev, pov: e.target.value }))} className="px-3 py-2 bg-white border border-gray-300 rounded-lg text-sm" > <option value="all">All POVs</option> {filterOptions.povs.map((pov) => ( <option key={pov} value={pov}> {pov} </option> ))} </select> {/* Location Filter */} <select value={filters.location} onChange={(e) => setFilters((prev) => ({ ...prev, location: e.target.value }))} className="px-3 py-2 bg-white border border-gray-300 rounded-lg text-sm" > <option value="all">All Locations</option> {filterOptions.locations.map((location) => ( <option key={location} value={location}> {location} </option> ))} </select> {/* Event Type Filter */} <select value={filters.eventType} onChange={(e) => setFilters((prev) => ({ ...prev, eventType: e.target.value }))} className="px-3 py-2 bg-white border border-gray-300 rounded-lg text-sm" > <option value="all">All Types</option> <option value="plot">Plot Events</option> <option value="character">Character Moments</option> <option value="world">World Building</option> <option value="relationship">Relationships</option> </select> {/* Importance Filter */} <select value={filters.importance} onChange={(e) => setFilters((prev) => ({ ...prev, importance: e.target.value }))} className="px-3 py-2 bg-white border border-gray-300 rounded-lg text-sm" > <option value="all">All Importance</option> <option value="major">Major Events</option> <option value="minor">Minor Events</option> <option value="background">Background</option> </select> <span className="text-sm text-gray-600"> {filteredEvents.length} event{filteredEvents.length !== 1 ? 's' : ''} </span> </div> </div> {/* Main Content */} <div className="flex-1 overflow-hidden flex"> {/* Timeline/List View */} <div className="flex-1 overflow-y-auto"> {viewMode === 'timeline' ? ( <TimelineChart povLanes={povLanes} onSelectEvent={setSelectedEvent} selectedEvent={selectedEvent} getEventColor={getEventColor} onDeleteEvent={deleteEvent} /> ) : ( <EventList events={filteredEvents} onSelectEvent={setSelectedEvent} selectedEvent={selectedEvent} getEventColor={getEventColor} onDeleteEvent={deleteEvent} /> )} </div> {/* Event Details Panel */} {selectedEvent && ( <EventDetailsPanel event={selectedEvent} isEditing={isEditing} onStartEdit={() => setIsEditing(true)} onSave={saveEvent} onCancel={() => { setIsEditing(false); if (showNewEventForm) { setSelectedEvent(null); setShowNewEventForm(false); } }} onUpdate={updateSelectedEvent} onDelete={() => deleteEvent(selectedEvent.id)} filterOptions={filterOptions} timelineType={timelineType} /> )} </div> </div> ); }; // Timeline Chart Component (POV Lanes) const TimelineChart: React.FC<{ povLanes: Array<{ pov: string; events: TimelineEvent[] }>; onSelectEvent: (event: TimelineEvent) => void; selectedEvent: TimelineEvent | null; getEventColor: (event: TimelineEvent) => string; onDeleteEvent: (eventId: string) => void; }> = ({ povLanes, onSelectEvent, selectedEvent, getEventColor, onDeleteEvent }) => { if (povLanes.length === 0) { return ( <div className="flex-1 flex items-center justify-center text-gray-500"> <div className="text-center"> <Clock className="w-12 h-12 mx-auto mb-4 opacity-50" /> <h3 className="text-lg font-medium mb-2">No Events Yet</h3> <p className="text-sm">Add your first timeline event to get started</p> </div> </div> ); } return ( <div className="p-6"> <div className="space-y-8"> {povLanes.map(({ pov, events }) => ( <div key={pov} className="relative"> {/* POV Lane Header */} <div className="flex items-center gap-3 mb-4"> <div className="w-4 h-4 bg-gray-400 rounded-full"></div> <h3 className="font-medium text-gray-900">{pov}</h3> <div className="h-px bg-gray-300 flex-1"></div> </div> {/* Events in this lane */} <div className="ml-8 space-y-3"> {events.map((event, index) => ( <div key={event.id} className={`relative cursor-pointer transition-all duration-200 hover:scale-105 ${ selectedEvent?.id === event.id ? 'ring-2 ring-blue-500' : '' }`} onClick={() => onSelectEvent(event)} > {/* Timeline connector */} {index < events.length - 1 && ( <div className="absolute left-6 top-8 w-px h-12 bg-gray-300"></div> )} {/* Event card */} <div className={`relative flex items-start gap-4 p-4 rounded-lg border-2 ${getEventColor(event)} bg-opacity-10`} > <div className={`w-3 h-3 rounded-full ${getEventColor(event)} mt-2`}></div> <div className="flex-1 min-w-0"> <div className="flex items-start justify-between"> <div> <h4 className="font-medium text-gray-900"> {event.title || 'Untitled Event'} </h4> <p className="text-sm text-gray-600 mt-1"> {event.when.displayText || `Position ${event.when.value}`} </p> </div> <button onClick={(e) => { e.stopPropagation(); onDeleteEvent(event.id); }} className="p-1 text-gray-400 hover:text-red-600 transition-colors" > <Trash2 className="w-4 h-4" /> </button> </div> {event.description && ( <p className="text-sm text-gray-700 mt-2 line-clamp-2"> {event.description} </p> )} {/* Event metadata */} <div className="flex items-center gap-4 mt-3 text-xs text-gray-500"> {event.location && ( <span className="flex items-center gap-1"> <MapPin className="w-3 h-3" /> {event.location} </span> )} {event.characterIds.length > 0 && ( <span className="flex items-center gap-1"> <User className="w-3 h-3" /> {event.characterIds.length} character {event.characterIds.length !== 1 ? 's' : ''} </span> )} {event.tags.length > 0 && ( <span className="flex items-center gap-1"> <Tag className="w-3 h-3" /> {event.tags.slice(0, 2).join(', ')} {event.tags.length > 2 && '...'} </span> )} </div> </div> </div> </div> ))} </div> </div> ))} </div> </div> ); }; // Event List Component const EventList: React.FC<{ events: TimelineEvent[]; onSelectEvent: (event: TimelineEvent) => void; selectedEvent: TimelineEvent | null; getEventColor: (event: TimelineEvent) => string; onDeleteEvent: (eventId: string) => void; }> = ({ events, onSelectEvent, selectedEvent, getEventColor, onDeleteEvent }) => { if (events.length === 0) { return ( <div className="flex-1 flex items-center justify-center text-gray-500"> <div className="text-center"> <Clock className="w-12 h-12 mx-auto mb-4 opacity-50" /> <h3 className="text-lg font-medium mb-2">No Events Match Filters</h3> <p className="text-sm">Adjust your filters or add new timeline events</p> </div> </div> ); } return ( <div className="p-6"> <div className="space-y-4"> {events.map((event) => ( <div key={event.id} className={`p-4 rounded-lg border cursor-pointer transition-all duration-200 hover:shadow-md ${ selectedEvent?.id === event.id ? 'ring-2 ring-blue-500 border-blue-300' : 'border-gray-200' } bg-white`} onClick={() => onSelectEvent(event)} > <div className="flex items-start justify-between"> <div className="flex items-start gap-4 flex-1"> <div className={`w-4 h-4 rounded-full ${getEventColor(event)} mt-1`}></div> <div className="flex-1 min-w-0"> <div className="flex items-start justify-between"> <h3 className="font-medium text-gray-900"> {event.title || 'Untitled Event'} </h3> <span className="text-sm text-gray-500 ml-2"> {event.when.displayText || `Position ${event.when.value}`} </span> </div> {event.description && ( <p className="text-gray-600 text-sm mt-1 line-clamp-2"> {event.description} </p> )} <div className="flex items-center gap-4 mt-2 text-xs text-gray-500"> {event.pov && ( <span className="flex items-center gap-1"> <User className="w-3 h-3" /> {event.pov} </span> )} {event.location && ( <span className="flex items-center gap-1"> <MapPin className="w-3 h-3" /> {event.location} </span> )} <span className="px-2 py-1 bg-gray-100 rounded text-xs"> {event.eventType} </span> <span className={`px-2 py-1 rounded text-xs ${ event.importance === 'major' ? 'bg-red-100 text-red-700' : event.importance === 'minor' ? 'bg-yellow-100 text-yellow-700' : 'bg-gray-100 text-gray-700' }`} > {event.importance} </span> </div> </div> </div> <button onClick={(e) => { e.stopPropagation(); onDeleteEvent(event.id); }} className="p-1 text-gray-400 hover:text-red-600 transition-colors ml-2" > <Trash2 className="w-4 h-4" /> </button> </div> </div> ))} </div> </div> ); }; // Event Details Panel const EventDetailsPanel: React.FC<{ event: TimelineEvent; isEditing: boolean; onStartEdit: () => void; onSave: () => void; onCancel: () => void; onUpdate: (updates: Partial<TimelineEvent>) => void; onDelete: () => void; filterOptions: { characters: Array<{ id: string; name: string }>; locations: string[]; tags: string[]; povs: string[]; }; timelineType: 'date' | 'order'; }> = ({ event, isEditing, onStartEdit, onSave, onCancel, onUpdate, onDelete, filterOptions, timelineType, }) => { return ( <div className="w-96 border-l border-gray-200 bg-white flex flex-col"> {/* Header */} <div className="p-4 border-b border-gray-200"> <div className="flex items-center justify-between"> <h2 className="text-lg font-semibold text-gray-900">Event Details</h2> <div className="flex items-center space-x-2"> {isEditing ? ( <> <button onClick={onSave} className="p-2 bg-green-600 hover:bg-green-700 text-white rounded-lg" title="Save Event" > <Save className="w-4 h-4" /> </button> <button onClick={onCancel} className="p-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg" title="Cancel" > <X className="w-4 h-4" /> </button> </> ) : ( <> <button onClick={onStartEdit} className="p-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg" title="Edit Event" > <Edit3 className="w-4 h-4" /> </button> <button onClick={onDelete} className="p-2 bg-red-600 hover:bg-red-700 text-white rounded-lg" title="Delete Event" > <Trash2 className="w-4 h-4" /> </button> </> )} </div> </div> </div> {/* Form */} <div className="flex-1 overflow-y-auto p-4 space-y-4"> {/* Title */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Event Title </label> <input type="text" value={event.title} onChange={(e) => onUpdate({ title: e.target.value })} disabled={!isEditing} placeholder="What happens in this event?" className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" /> </div> {/* When */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> When </label> {timelineType === 'order' ? ( <input type="number" value={event.when.value || 1} onChange={(e) => onUpdate({ when: { ...event.when, value: Math.max(1, parseInt(e.target.value) || 1), }, }) } disabled={!isEditing} placeholder="Story order (1, 2, 3...)" min="1" className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" /> ) : ( <input type="datetime-local" value={event.when.value ? new Date(event.when.value).toISOString().slice(0, 16) : ''} onChange={(e) => onUpdate({ when: { ...event.when, value: e.target.value ? new Date(e.target.value).getTime() : Date.now(), }, }) } disabled={!isEditing} className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" /> )} </div> {/* Display Text */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Display Text (Optional) </label> <input type="text" value={event.when.displayText || ''} onChange={(e) => onUpdate({ when: { ...event.when, displayText: e.target.value, }, }) } disabled={!isEditing} placeholder="e.g., 'Chapter 3', 'Day 2 of journey'" className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" /> </div> {/* Description */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Description </label> <textarea value={event.description} onChange={(e) => onUpdate({ description: e.target.value })} disabled={!isEditing} placeholder="Describe what happens in this event..." rows={4} className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50 resize-none" /> </div> {/* Event Type and Importance */} <div className="grid grid-cols-2 gap-3"> <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Type </label> <select value={event.eventType} onChange={(e) => onUpdate({ eventType: e.target.value as TimelineEvent['eventType'] }) } disabled={!isEditing} className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" > <option value="plot">Plot Event</option> <option value="character">Character Moment</option> <option value="world">World Building</option> <option value="relationship">Relationship</option> </select> </div> <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Importance </label> <select value={event.importance} onChange={(e) => onUpdate({ importance: e.target.value as TimelineEvent['importance'] }) } disabled={!isEditing} className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" > <option value="major">Major</option> <option value="minor">Minor</option> <option value="background">Background</option> </select> </div> </div> {/* POV Character */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Point of View </label> <select value={event.pov || ''} onChange={(e) => onUpdate({ pov: e.target.value || undefined })} disabled={!isEditing} className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" > <option value="">Select POV character...</option> {filterOptions.characters.map((char) => ( <option key={char.id} value={char.name}> {char.name} </option> ))} </select> </div> {/* Location */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Location </label> <input type="text" value={event.location || ''} onChange={(e) => onUpdate({ location: e.target.value || undefined })} disabled={!isEditing} placeholder="Where does this event take place?" className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" /> </div> {/* Characters Involved */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Characters Involved </label> <div className="max-h-32 overflow-y-auto border border-gray-300 rounded-lg p-2 bg-white"> {filterOptions.characters.length === 0 ? ( <p className="text-gray-500 text-sm">No characters available</p> ) : ( filterOptions.characters.map((char) => ( <label key={char.id} className="flex items-center gap-2 py-1"> <input type="checkbox" checked={event.characterIds.includes(char.id)} onChange={(e) => { if (e.target.checked) { onUpdate({ characterIds: [...event.characterIds, char.id] }); } else { onUpdate({ characterIds: event.characterIds.filter((id) => id !== char.id), }); } }} disabled={!isEditing} className="rounded border-gray-300 text-blue-600" /> <span className="text-gray-900 text-sm">{char.name}</span> </label> )) )} </div> </div> {/* Tags */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Tags </label> <input type="text" value={event.tags.join(', ')} onChange={(e) => onUpdate({ tags: e.target.value .split(',') .map((tag) => tag.trim()) .filter(Boolean), }) } disabled={!isEditing} placeholder="battle, revelation, turning-point (separate with commas)" className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" /> </div> {/* Scene Link */} <div> <label className="block text-sm font-medium text-gray-700 mb-2"> Linked Scene (Optional) </label> <input type="text" value={event.sceneId || ''} onChange={(e) => onUpdate({ sceneId: e.target.value || undefined })} disabled={!isEditing} placeholder="Scene ID to link this event" className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-900 disabled:bg-gray-50" /> {event.sceneId && ( <p className="text-xs text-blue-600 mt-1"> This event will be linked to scene {event.sceneId} </p> )} </div> {/* Metadata */} {!isEditing && ( <div className="pt-4 border-t border-gray-200"> <h3 className="text-sm font-medium text-gray-700 mb-2">Metadata</h3> <div className="space-y-1 text-xs text-gray-500"> <div>Created: {new Date(event.createdAt).toLocaleDateString()}</div> <div>Updated: {new Date(event.updatedAt).toLocaleDateString()}</div> <div>ID: {event.id}</div> </div> </div> )} </div> </div> ); }; export default TimelineView; 
/Users/davehail/Developer/inkwell/src/components/Writing/SceneHeader.tsx:27:        placeholder="Scene title"
/Users/davehail/Developer/inkwell/src/components/Writing/SceneHeader.tsx:46:        placeholder="Goal"
/Users/davehail/Developer/inkwell/src/components/ViewSwitcher.tsx:151:                // TODO: Implement setActiveChapter(chapterIndex) via ChapterContext
/Users/davehail/Developer/inkwell/src/components/Auth/AuthForm.tsx:234:              placeholder="Enter your full name"
/Users/davehail/Developer/inkwell/src/components/Auth/AuthForm.tsx:252:            placeholder={emailPlaceholder}
/Users/davehail/Developer/inkwell/src/components/Auth/AuthForm.tsx:270:                placeholder={passwordPlaceholder}
/Users/davehail/Developer/inkwell/src/components/Auth/AuthForm.tsx:301:                  placeholder="Confirm your password"
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:6:import { PROJECT_TEMPLATES } from '@/data/sampleProject';
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:24:const TEMPLATE_OPTIONS: ProjectTemplate[] = [
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:49:    chapters: PROJECT_TEMPLATES.mystery.chapters,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:50:    characters: PROJECT_TEMPLATES.mystery.characters,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:51:    beatSheet: PROJECT_TEMPLATES.mystery.beatSheet,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:63:    chapters: PROJECT_TEMPLATES.romance.chapters,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:64:    characters: PROJECT_TEMPLATES.romance.characters,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:65:    beatSheet: PROJECT_TEMPLATES.romance.beatSheet,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:77:    chapters: PROJECT_TEMPLATES.scifi.chapters,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:78:    characters: PROJECT_TEMPLATES.scifi.characters,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:79:    beatSheet: PROJECT_TEMPLATES.scifi.beatSheet,
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:209:              {TEMPLATE_OPTIONS.map((template) => {
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:365:                    placeholder="Enter project name"
/Users/davehail/Developer/inkwell/src/components/ProjectTemplates/TemplateSelector.tsx:378:                    placeholder="Brief description of your story"
/Users/davehail/Developer/inkwell/src/components/Writing/Chapters/NewChapterDialog.tsx:108:              placeholder="e.g., The Beginning"
/Users/davehail/Developer/inkwell/src/components/Writing/Chapters/NewChapterDialog.tsx:128:              placeholder="Brief description of what happens in this chapter..."
/Users/davehail/Developer/inkwell/src/components/Writing/Chapters/NewChapterDialog.tsx:170:              placeholder="e.g., 3000"
/Users/davehail/Developer/inkwell/src/components/Writing/Chapters/ChapterListItem.tsx:149:                placeholder="Chapter title"
/Users/davehail/Developer/inkwell/src/components/ProjectBrowser/EnhancedProjectBrowser.tsx:1:// src/components/ProjectBrowser/EnhancedProjectBrowser.tsx import { useVirtualizer } from '@tanstack/react-virtual'; import { Search, Filter, Star, StarOff, Heart, Clock, FileText, MoreVertical, Copy, Edit3, Trash2, Download, Tag, Plus, X, Calendar, BarChart3, BookOpen, Zap, } from 'lucide-react'; import React, { useState, useRef, useEffect } from 'react'; import { useAppContext, View } from '@/context/AppContext'; import { useDebouncedSearch } from '@/hooks/useDebounced'; import { useVirtualListPerformance } from '@/hooks/usePerformanceMonitor'; import { useProjectMetadata, formatTimeSpent, getRelativeTimeString, getProjectColorClass, } from '@/hooks/useProjectMetadata'; import { useProjectSearch } from '@/hooks/useProjectSearch'; import { Project } from '../../domain/types'; interface EnhancedProjectBrowserProps { onProjectSelect?: (project: Project) => void; compact?: boolean; } const EnhancedProjectBrowser: React.FC<EnhancedProjectBrowserProps> = ({ onProjectSelect, compact = false, }) => { const { state, currentProject, setCurrentProjectId, updateProject, deleteProject, dispatch } = useAppContext(); const { getProjectMetadata, toggleFavorite, addTag, removeTag, getAllTags: _getAllTags, recordProjectOpen, } = useProjectMetadata(); // Debounced search for better performance const { query, debouncedQuery, isSearching, setQuery } = useDebouncedSearch('', 300); const { results, filters, filterOptions, setQuery: setSearchQuery, toggleTag: toggleFilterTag, toggleGenre, toggleFavorites, clearFilters, setSorting, applyQuickFilter, searchStats, } = useProjectSearch(state.projects as any); const [showFilters, setShowFilters] = useState(false); const [contextMenu, setContextMenu] = useState<{ project: Project; x: number; y: number; } | null>(null); const [tagInput, setTagInput] = useState(''); const [editingTags, setEditingTags] = useState<string | null>(null); const contextMenuRef = useRef<HTMLDivElement>(null); const tagInputRef = useRef<HTMLInputElement>(null); const parentRef = useRef<HTMLDivElement>(null); // Calculate columns and rows for virtualization const columnsCount = compact ? 1 : 3; // For grid layout const rowCount = Math.ceil(results.length / columnsCount); const estimatedRowHeight = compact ? 200 : 300; // Estimated height per row // Performance monitoring const { startRenderMeasure, endRenderMeasure, measureVirtualScroll, getVirtualListSummary: _getVirtualListSummary, } = useVirtualListPerformance(results.length, rowCount, { enabled: process.env.NODE_ENV === 'development', logToConsole: false, sampleRate: 0.2, }); // Virtualizer for project grid const rowVirtualizer = useVirtualizer({ count: rowCount, getScrollElement: () => parentRef.current, estimateSize: () => estimatedRowHeight, overscan: 2, }); // Sync debounced query with search service useEffect(() => { setSearchQuery(debouncedQuery); }, [debouncedQuery, setSearchQuery]); // Setup scroll performance monitoring useEffect(() => { const cleanup = measureVirtualScroll(parentRef.current); return cleanup; }, [measureVirtualScroll]); // Close context menu when clicking outside useEffect(() => { const handleClickOutside = (event: MouseEvent) => { if (contextMenuRef.current && !contextMenuRef.current.contains(event.target as Node)) { setContextMenu(null); } }; if (contextMenu) { document.addEventListener('mousedown', handleClickOutside); } return () => { document.removeEventListener('mousedown', handleClickOutside); }; }, [contextMenu]); // Focus tag input when editing starts useEffect(() => { if (editingTags && tagInputRef.current) { tagInputRef.current.focus(); } }, [editingTags]); const handleProjectClick = (project: Project) => { recordProjectOpen(project.id); setCurrentProjectId(project.id); onProjectSelect?.(project); dispatch({ type: 'SET_VIEW', payload: View.Writing }); }; const handleContextMenu = (e: React.MouseEvent, project: Project) => { e.preventDefault(); e.stopPropagation(); setContextMenu({ project, x: e.clientX, y: e.clientY, }); }; const handleProjectAction = (action: string, project: Project) => { setContextMenu(null); switch (action) { case 'favorite': toggleFavorite(project.id); break; case 'duplicate': // TODO: Implement duplicate functionality console.log('Duplicate project:', project.name); break; case 'rename': const newName = prompt('Enter new project name:', project.name); if (newName && newName.trim() && newName !== project.name) { updateProject({ ...project, name: newName.trim(), updatedAt: new Date(), } as any); } break; case 'delete': const confirmed = confirm( `Are you sure you want to delete "${project.name}"? This cannot be undone.`, ); if (confirmed) { deleteProject(project.id); } break; case 'export': // TODO: Implement export functionality console.log('Export project:', project.name); break; case 'edit-tags': setEditingTags(project.id); break; } }; const handleAddTag = (projectId: string, tag: string) => { if (tag.trim()) { addTag(projectId, tag.trim()); } setTagInput(''); setEditingTags(null); }; const handleTagKeyPress = (e: React.KeyboardEvent, projectId: string) => { if (e.key === 'Enter') { handleAddTag(projectId, tagInput); } else if (e.key === 'Escape') { setTagInput(''); setEditingTags(null); } }; const getProjectWordCount = (project: Project): number => { return project.metadata?.totalWordCount || 0; }; const getGenreIcon = (genre: string) => { const genreIcons: Record<string, React.ElementType> = { Mystery: Zap, Romance: Heart, 'Science Fiction': BookOpen, Fantasy: Star, Thriller: FileText, }; return genreIcons[genre] || FileText; }; const renderProjectCard = (result: { project: Project; relevanceScore: number; matchedFields: string[]; }) => { startRenderMeasure(); const { project, matchedFields } = result; const metadata = getProjectMetadata(project.id); const wordCount = getProjectWordCount(project); const genre = project.metadata?.genre; const GenreIcon = genre ? getGenreIcon(genre) : FileText; const cardElement = ( <div key={project.id} className={`group card card-interactive p-4 ${ currentProject?.id === project.id ? 'ring-2 ring-primary-500' : '' }`} onClick={() => handleProjectClick(project)} onContextMenu={(e) => handleContextMenu(e, project)} > {/* Header */} <div className="flex items-start justify-between mb-3"> <div className="flex items-start gap-3 flex-1 min-w-0"> {/* Project Icon/Color */} <div className={`w-10 h-10 rounded-lg flex items-center justify-center flex-shrink-0 ${getProjectColorClass(metadata.customColor)}`} > <GenreIcon className="w-5 h-5 text-slate-600" /> </div> {/* Project Info */} <div className="flex-1 min-w-0"> <div className="flex items-center gap-2 mb-1"> <h3 className="font-semibold text-slate-900 truncate"> {project.name} </h3> {metadata.isFavorite && ( <Star className="w-4 h-4 text-yellow-500 fill-current flex-shrink-0" /> )} </div> {project.description && ( <p className="text-sm text-slate-600 line-clamp-2 mb-2"> {project.description} </p> )} {/* Tags */} {metadata.tags.length > 0 && ( <div className="flex flex-wrap gap-1 mb-2"> {metadata.tags.slice(0, 3).map((tag) => ( <span key={tag} className="inline-flex items-center px-2 py-1 rounded-full text-xs bg-primary-100 text-primary-700" > {tag} </span> ))} {metadata.tags.length > 3 && ( <span className="text-xs text-slate-500">+{metadata.tags.length - 3}</span> )} </div> )} </div> </div> {/* Actions */} <div className="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity"> <button onClick={(e) => { e.stopPropagation(); toggleFavorite(project.id); }} className="p-1 text-slate-400 hover:text-yellow-500 transition-colors" title={metadata.isFavorite ? 'Remove from favorites' : 'Add to favorites'} > {metadata.isFavorite ? ( <Star className="w-4 h-4 fill-current" /> ) : ( <StarOff className="w-4 h-4" /> )} </button> <button onClick={(e) => handleContextMenu(e, project)} className="p-1 text-slate-400 hover:text-slate-600 transition-colors" > <MoreVertical className="w-4 h-4" /> </button> </div> </div> {/* Stats */} <div className="grid grid-cols-2 gap-4 text-xs text-slate-500 mb-3"> <div className="flex items-center gap-2"> <FileText className="w-3 h-3" /> <span>{wordCount.toLocaleString()} words</span> </div> <div className="flex items-center gap-2"> <Clock className="w-3 h-3" /> <span>{getRelativeTimeString(project.updatedAt.getTime())}</span> </div> {metadata.totalTimeSpent > 0 && ( <> <div className="flex items-center gap-2"> <BarChart3 className="w-3 h-3" /> <span>{formatTimeSpent(metadata.totalTimeSpent)} writing</span> </div> <div className="flex items-center gap-2"> <Calendar className="w-3 h-3" /> <span>{metadata.openCount} sessions</span> </div> </> )} </div> {/* Match highlights */} {matchedFields.length > 0 && ( <div className="text-xs text-primary-600 border-t border-slate-200 pt-2"> Matched: {matchedFields.join(', ')} </div> )} {/* Tag editing */} {editingTags === project.id && ( <div className="border-t border-slate-200 pt-3 mt-3"> <div className="flex items-center gap-2"> <input ref={tagInputRef} type="text" value={tagInput} onChange={(e) => setTagInput(e.target.value)} onKeyDown={(e) => handleTagKeyPress(e, project.id)} placeholder="Add a tag..." className="flex-1 text-sm px-2 py-1 border border-slate-300 rounded bg-white text-slate-900" /> <button onClick={() => handleAddTag(project.id, tagInput)} className="p-1 text-primary-600 hover:text-primary-700" disabled={!tagInput.trim()} > <Plus className="w-4 h-4" /> </button> <button onClick={() => { setTagInput(''); setEditingTags(null); }} className="p-1 text-slate-400 hover:text-slate-600" > <X className="w-4 h-4" /> </button> </div> {metadata.tags.length > 0 && ( <div className="flex flex-wrap gap-1 mt-2"> {metadata.tags.map((tag) => ( <span key={tag} className="inline-flex items-center px-2 py-1 rounded-full text-xs bg-slate-100 text-slate-700 group/tag" > {tag} <button onClick={() => removeTag(project.id, tag)} className="ml-1 text-slate-400 hover:text-red-500 opacity-0 group-hover/tag:opacity-100 transition-opacity" > <X className="w-3 h-3" /> </button> </span> ))} </div> )} </div> )} </div> ); endRenderMeasure(); return cardElement; }; return ( <div className="enhanced-project-browser"> {/* Search and Filters Header */} <div className="mb-6"> {/* Search Bar */} <div className="relative mb-4"> <Search className={`absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 transition-colors ${ isSearching ? 'text-blue-500 animate-pulse' : 'text-slate-400' }`} /> <input type="text" placeholder="Search projects by name, content, tags..." value={query} onChange={(e) => setQuery(e.target.value)} className="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg bg-white text-slate-900 placeholder-slate-500" /> {isSearching && ( <div className="absolute right-3 top-1/2 -translate-y-1/2"> <div className="w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full animate-spin" /> </div> )} </div> {/* Filter Controls */} <div className="flex items-center gap-3 flex-wrap"> <button onClick={() => setShowFilters(!showFilters)} className={`btn btn-sm ${showFilters ? 'btn-primary' : 'btn-secondary'}`} > <Filter className="w-4 h-4" /> Filters {searchStats.hasActiveFilters && ( <span className="ml-1 px-1.5 py-0.5 bg-primary-500 text-white text-xs rounded-full"> {[filters.tags.length, filters.genres.length, filters.favorites ? 1 : 0].reduce( (sum, count) => sum + count, 0, )} </span> )} </button> <div className="flex items-center gap-2"> <label className="text-sm text-slate-600">Sort:</label> <select value={`${filters.sortBy}-${filters.sortOrder}`} onChange={(e) => { const [sortBy, sortOrder] = e.target.value.split('-') as [ typeof filters.sortBy, typeof filters.sortOrder, ]; setSorting(sortBy, sortOrder); }} className="text-sm border border-slate-300 rounded px-2 py-1 bg-white text-slate-900" > <option value="updated-desc">Recently Updated</option> <option value="name-asc">Name A-Z</option> <option value="name-desc">Name Z-A</option> <option value="created-desc">Newest First</option> <option value="created-asc">Oldest First</option> <option value="wordCount-desc">Most Words</option> <option value="wordCount-asc">Least Words</option> <option value="lastOpened-desc">Recently Opened</option> <option value="timeSpent-desc">Most Time Spent</option> </select> </div> {/* Quick Filters */} <div className="flex items-center gap-2"> <button onClick={() => applyQuickFilter('recent')} className="btn btn-ghost btn-sm"> <Clock className="w-4 h-4" /> Recent </button> <button onClick={() => applyQuickFilter('favorites')} className="btn btn-ghost btn-sm"> <Star className="w-4 h-4" /> Favorites </button> <button onClick={() => applyQuickFilter('mostWorked')} className="btn btn-ghost btn-sm"> <BarChart3 className="w-4 h-4" /> Most Worked </button> </div> {searchStats.hasActiveFilters && ( <button onClick={clearFilters} className="btn btn-ghost btn-sm text-red-600 hover:text-red-700" > Clear All </button> )} </div> {/* Expanded Filters */} {showFilters && ( <div className="mt-4 p-4 bg-slate-50 rounded-lg space-y-4"> {/* Tags Filter */} {filterOptions.tags.length > 0 && ( <div> <label className="block text-sm font-medium text-slate-700 mb-2"> Tags </label> <div className="flex flex-wrap gap-2"> {filterOptions.tags.map((tag) => ( <button key={tag} onClick={() => toggleFilterTag(tag)} className={`px-3 py-1 text-sm rounded-full transition-colors ${ filters.tags.includes(tag) ? 'bg-primary-500 text-white' : 'bg-slate-200 text-slate-700 hover:bg-slate-300' }`} > {tag} </button> ))} </div> </div> )} {/* Genres Filter */} {filterOptions.genres.length > 0 && ( <div> <label className="block text-sm font-medium text-slate-700 mb-2"> Genres </label> <div className="flex flex-wrap gap-2"> {filterOptions.genres.map((genre) => ( <button key={genre} onClick={() => toggleGenre(genre)} className={`px-3 py-1 text-sm rounded-full transition-colors ${ filters.genres.includes(genre) ? 'bg-primary-500 text-white' : 'bg-slate-200 text-slate-700 hover:bg-slate-300' }`} > {genre} </button> ))} </div> </div> )} {/* Favorites Toggle */} <div> <label className="flex items-center gap-2"> <input type="checkbox" checked={filters.favorites} onChange={toggleFavorites} className="rounded border-slate-300" /> <span className="text-sm text-slate-700"> Show only favorites </span> </label> </div> </div> )} {/* Search Stats */} <div className="mt-4 text-sm text-slate-600"> Showing {searchStats.totalResults} of {searchStats.totalProjects} projects {searchStats.filteredOut > 0 && <span> ({searchStats.filteredOut} filtered out)</span>} </div> </div> {/* Project Grid - Virtualized */} <div ref={parentRef} className="h-[600px] overflow-auto" style={{ contain: 'strict', }} > <div style={{ height: `${rowVirtualizer.getTotalSize()}px`, width: '100%', position: 'relative', }} > {rowVirtualizer.getVirtualItems().map((virtualRow) => { const startIndex = virtualRow.index * columnsCount; const endIndex = Math.min(startIndex + columnsCount, results.length); const rowItems = results.slice(startIndex, endIndex); return ( <div key={virtualRow.key} style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: `${virtualRow.size}px`, transform: `translateY(${virtualRow.start}px)`, }} > <div className={`grid gap-4 h-full ${compact ? 'grid-cols-1' : 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3'}`} > {rowItems.map(renderProjectCard)} </div> </div> ); })} </div> </div> {/* Empty State */} {results.length === 0 && ( <div className="text-center py-12"> <FileText className="w-16 h-16 mx-auto mb-4 text-slate-400" /> <h3 className="text-lg font-medium text-slate-600 mb-2"> {searchStats.hasActiveFilters ? 'No projects found' : 'No projects yet'} </h3> <p className="text-slate-500"> {searchStats.hasActiveFilters ? 'Try adjusting your search terms or filters' : 'Create your first project to get started'} </p> </div> )} {/* Context Menu */} {contextMenu && ( <div ref={contextMenuRef} className="fixed z-50 bg-white rounded-lg shadow-lg border border-slate-200 py-1 min-w-[160px]" style={{ left: contextMenu.x, top: contextMenu.y, }} > <button onClick={() => handleProjectAction('favorite', contextMenu.project)} className="w-full px-3 py-2 text-left text-sm hover:bg-slate-100 flex items-center gap-2" > {getProjectMetadata(contextMenu.project.id).isFavorite ? ( <> <StarOff className="w-4 h-4" /> Remove from Favorites </> ) : ( <> <Star className="w-4 h-4" /> Add to Favorites </> )} </button> <button onClick={() => handleProjectAction('edit-tags', contextMenu.project)} className="w-full px-3 py-2 text-left text-sm hover:bg-slate-100 flex items-center gap-2" > <Tag className="w-4 h-4" /> Edit Tags </button> <div className="h-px bg-slate-200 my-1" /> <button onClick={() => handleProjectAction('duplicate', contextMenu.project)} className="w-full px-3 py-2 text-left text-sm hover:bg-slate-100 flex items-center gap-2" > <Copy className="w-4 h-4" /> Duplicate </button> <button onClick={() => handleProjectAction('rename', contextMenu.project)} className="w-full px-3 py-2 text-left text-sm hover:bg-slate-100 flex items-center gap-2" > <Edit3 className="w-4 h-4" /> Rename </button> <button onClick={() => handleProjectAction('export', contextMenu.project)} className="w-full px-3 py-2 text-left text-sm hover:bg-slate-100 flex items-center gap-2" > <Download className="w-4 h-4" /> Export </button> <div className="h-px bg-slate-200 my-1" /> <button onClick={() => handleProjectAction('delete', contextMenu.project)} className="w-full px-3 py-2 text-left text-sm hover:bg-red-50 text-red-600 flex items-center gap-2" > <Trash2 className="w-4 h-4" /> Delete </button> </div> )} </div> ); }; export default EnhancedProjectBrowser; 
/Users/davehail/Developer/inkwell/src/components/CommandPalette/CommandPaletteUI.tsx:107:            placeholder="Search commands..."
/Users/davehail/Developer/inkwell/src/components/CommandPalette/CommandPaletteUI.tsx:110:            className="flex-1 bg-transparent text-gray-900 dark:text-gray-100 placeholder-gray-500 focus:outline-none text-lg"
/Users/davehail/Developer/inkwell/src/components/Writing/WritingEditor.tsx:1:// src/components/Writing/WritingEditor.tsx import React, { forwardRef } from 'react'; export interface WritingEditorProps { value: string; onChange: (val: string) => void; onTextSelect: () => void; placeholder?: string; disabled?: boolean; className?: string; } const WritingEditor = forwardRef<HTMLTextAreaElement, WritingEditorProps>( ( { value, onChange, onTextSelect, placeholder = 'Start writing...', disabled = false, className, }, ref, ) => { return ( <textarea ref={ref} value={value} onChange={(e) => onChange(e.target.value)} onSelect={onTextSelect} placeholder={placeholder} disabled={disabled} className={`w-full h-full p-4 border border-gray-300 rounded-lg resize-none bg-white text-gray-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200 ${className || ''}`} style={{ minHeight: '400px' }} /> ); }, ); WritingEditor.displayName = 'WritingEditor'; export default WritingEditor; 
/Users/davehail/Developer/inkwell/src/components/CommandPalette/CommandPalette.tsx:11:  placeholder?: string;
/Users/davehail/Developer/inkwell/src/components/CommandPalette/CommandPalette.tsx:18:  placeholder = 'Search commands...',
/Users/davehail/Developer/inkwell/src/components/CommandPalette/CommandPalette.tsx:170:            placeholder={placeholder}
/Users/davehail/Developer/inkwell/src/components/CommandPalette/CommandPalette.tsx:171:            className="w-full px-4 py-2 text-lg font-semibold bg-transparent border-0 outline-none text-gray-900 dark:text-gray-100 placeholder-gray-500"
/Users/davehail/Developer/inkwell/src/components/BackupPanel.tsx:90:        placeholder="Type here to auto-save..."
/Users/davehail/Developer/inkwell/src/components/editor/ConsistencyIssuesPanel.tsx:355:            placeholder="Search issues..."
/Users/davehail/Developer/inkwell/src/components/editor/ConsistencyIssuesPanel.tsx:363:                <SelectValue placeholder="Type" />
/Users/davehail/Developer/inkwell/src/components/editor/ConsistencyIssuesPanel.tsx:379:                <SelectValue placeholder="Severity" />
/Users/davehail/Developer/inkwell/src/components/ExportDialog.tsx:214:                    placeholder="Custom title for export"
/Users/davehail/Developer/inkwell/src/components/Navigation/PowerToolsMenu.tsx:116:                placeholder="Search tools..."
/Users/davehail/Developer/inkwell/src/components/Projects/NewProjectDialog.tsx:92:              placeholder="e.g., Henry Hail — Roosevelt Code"
/Users/davehail/Developer/inkwell/src/components/Projects/NewProjectDialog.tsx:105:              placeholder="Short note about this project"
/Users/davehail/Developer/inkwell/src/components/Planning/StoryStructureVisualizer.tsx:280:            {/* Show placeholders if fewer than 5 chapters */}
/Users/davehail/Developer/inkwell/src/components/Planning/StoryStructureVisualizer.tsx:283:                key={`placeholder-${index}`}
/Users/davehail/Developer/inkwell/src/components/Onboarding/_archive/TourOverlay.tsx:28:  const profileId = ''; // TODO: Get this from context/props if needed
/Users/davehail/Developer/inkwell/src/components/ui/Input.tsx:33:            'block w-full rounded-lg border px-3 py-2 text-sm text-gray-600 placeholder-gray-400 shadow-sm transition-colors duration-200',
/Users/davehail/Developer/inkwell/src/components/Layout/MainLayout.tsx:498:                    // TODO: Implement create project
/Users/davehail/Developer/inkwell/src/components/Layout/MainLayout.tsx:527:                  // TODO: Implement create project
/Users/davehail/Developer/inkwell/src/components/Layout/MainLayout.tsx:762:                placeholder="Search your projects and content..."
/Users/davehail/Developer/inkwell/src/components/Claude/ChatPanel.tsx:66:            placeholder={
/Users/davehail/Developer/inkwell/src/components/Onboarding/tourRegistry.ts:323:  // New tour variants - use placeholder for now to satisfy type
/Users/davehail/Developer/inkwell/src/components/Claude/AnalysisPanel.tsx:31:            placeholder="Character name..."
/Users/davehail/Developer/inkwell/src/components/Claude/AnalysisPanel.tsx:55:            placeholder="Topic to explore..."
/Users/davehail/Developer/inkwell/src/components/ui/select.tsx:10:  placeholder?: string;
/Users/davehail/Developer/inkwell/src/components/ui/select.tsx:30:  placeholder?: string;
/Users/davehail/Developer/inkwell/src/components/ui/select.tsx:68:const SelectValue: React.FC<SelectValueProps> = ({ placeholder }) => {
/Users/davehail/Developer/inkwell/src/components/ui/select.tsx:69:  return <span className="text-gray-500">{placeholder}</span>;
/Users/davehail/Developer/inkwell/src/components/Planning/CharacterManager.tsx:314:                      placeholder="Character name"
/Users/davehail/Developer/inkwell/src/components/Planning/CharacterManager.tsx:351:                      placeholder="Physical appearance, personality traits, background..."
/Users/davehail/Developer/inkwell/src/components/Planning/CharacterManager.tsx:366:                      placeholder="What does this character want? What drives them?"
/Users/davehail/Developer/inkwell/src/components/Planning/CharacterManager.tsx:381:                      placeholder="What's stopping them? Internal/external obstacles?"
/Users/davehail/Developer/inkwell/src/components/Planning/CharacterManager.tsx:396:                      placeholder="How does this character change throughout the story?"
/Users/davehail/Developer/inkwell/src/components/Planning/CharacterManager.tsx:411:                      placeholder="Backstory, relationships, quirks, speech patterns, etc."
/Users/davehail/Developer/inkwell/src/components/Planning/CharacterGoalTracker.tsx:1:// src/components/Planning/CharacterGoalTracker.tsx - Define and track character development goals across the story import { Target, Flag, CheckCircle2, Circle, AlertCircle, Calendar, Plus, Trash2, TrendingUp, Clock, } from 'lucide-react'; import React, { useMemo, useState } from 'react'; import type { GeneratedCharacter } from '../../services/storyArchitectService'; export interface CharacterGoal { id: string; title: string; description?: string; owner: string; // character name type: 'internal' | 'external' | 'relationship' | 'skill'; priority: 'low' | 'medium' | 'high' | 'critical'; targetChapter?: number; status: 'not_started' | 'in_progress' | 'at_risk' | 'completed' | 'deferred'; milestones: { id: string; title: string; chapter?: number; done: boolean; }[]; } interface CharacterGoalTrackerProps { characters: GeneratedCharacter[]; totalChapters: number; goals?: CharacterGoal[]; onGoalsChange?: (goals: CharacterGoal[]) => void; className?: string; } export default function CharacterGoalTracker({ characters = [], totalChapters = 20, goals = [], onGoalsChange, className = '', }: CharacterGoalTrackerProps) { const [filterCharacter, setFilterCharacter] = useState<string>('all'); const [filterStatus, setFilterStatus] = useState<string>('all'); const [showNewGoal, setShowNewGoal] = useState(false); const filteredGoals = useMemo(() => { return goals.filter((g) => { const charOk = filterCharacter === 'all' || g.owner === filterCharacter; const statusOk = filterStatus === 'all' || g.status === filterStatus; return charOk && statusOk; }); }, [goals, filterCharacter, filterStatus]); const goalStats = useMemo(() => { const byStatus: Record<string, number> = { not_started: 0, in_progress: 0, at_risk: 0, completed: 0, deferred: 0, }; goals.forEach((g) => (byStatus[g.status] = (byStatus[g.status] || 0) + 1)); const completion = goals.length ? Math.round(((byStatus.completed || 0) / goals.length) * 100) : 0; return { byStatus, completion }; }, [goals]); const _addGoal = () => { const owner = filterCharacter === 'all' ? characters[0]?.name || '' : filterCharacter; const newGoal: CharacterGoal = { id: `goal-${Date.now()}`, title: 'New Goal', owner, type: 'internal', priority: 'medium', status: 'not_started', milestones: [], }; onGoalsChange?.([newGoal, ...goals]); setShowNewGoal(false); }; const removeGoal = (id: string) => { onGoalsChange?.(goals.filter((g) => g.id !== id)); }; const updateGoal = (id: string, patch: Partial<CharacterGoal>) => { onGoalsChange?.(goals.map((g) => (g.id === id ? { ...g, ...patch } : g))); }; const addMilestone = (goal: CharacterGoal) => { const ms = { id: `ms-${Date.now()}`, title: 'New milestone', done: false }; updateGoal(goal.id, { milestones: [ms, ...goal.milestones] }); }; const updateMilestone = ( goal: CharacterGoal, msId: string, patch: Partial<CharacterGoal['milestones'][number]>, ) => { updateGoal(goal.id, { milestones: goal.milestones.map((m) => (m.id === msId ? { ...m, ...patch } : m)), }); }; const removeMilestone = (goal: CharacterGoal, msId: string) => { updateGoal(goal.id, { milestones: goal.milestones.filter((m) => m.id !== msId) }); }; const getStatusBadge = (status: CharacterGoal['status']) => { const map: Record<CharacterGoal['status'], string> = { not_started: 'bg-gray-100 text-gray-700', in_progress: 'bg-blue-100 text-blue-700', at_risk: 'bg-amber-100 text-amber-700', completed: 'bg-green-100 text-green-700', deferred: 'bg-purple-100 text-purple-700', }; return map[status]; }; const getPriorityBadge = (p: CharacterGoal['priority']) => { const map: Record<CharacterGoal['priority'], string> = { low: 'border-gray-300 text-gray-600', medium: 'border-blue-300 text-blue-600', high: 'border-amber-300 text-amber-600', critical: 'border-red-300 text-red-600', }; return map[p]; }; const suggestedGoals = useMemo(() => { // Suggest goals from character data return characters.flatMap((char) => { const suggestions: CharacterGoal[] = []; if (char.internalConflict) { suggestions.push({ id: `sugg-${char.name}-internal`, title: `Resolve internal conflict: ${char.internalConflict}`, owner: char.name, type: 'internal', priority: 'high', status: 'not_started', targetChapter: Math.ceil(totalChapters * 0.75), milestones: [], }); } if (char.externalConflict) { suggestions.push({ id: `sugg-${char.name}-external`, title: `Overcome: ${char.externalConflict}`, owner: char.name, type: 'external', priority: 'critical', status: 'not_started', targetChapter: totalChapters, milestones: [], }); } if (char.relationships?.length) { suggestions.push({ id: `sugg-${char.name}-relationship`, title: `Define relationship turning point`, owner: char.name, type: 'relationship', priority: 'medium', status: 'not_started', targetChapter: Math.ceil(totalChapters / 2), milestones: [], }); } return suggestions; }); }, [characters, totalChapters]); return ( <div className={`bg-white rounded-lg shadow-sm border border-gray-200 ${className}`} > {/* Header */} <div className="p-4 border-b border-gray-200"> <div className="flex items-center justify-between"> <div> <h2 className="text-lg font-semibold text-gray-900"> Character Development Goals </h2> <p className="text-sm text-gray-600"> Define objectives and track progress through chapters </p> </div> <div className="text-sm text-gray-500"> {goals.length} goals • {goalStats.completion}% complete </div> </div> </div> {/* Filters and actions */} <div className="p-4 border-b border-gray-200 bg-gray-50"> <div className="flex flex-wrap items-center gap-3"> <div className="flex items-center gap-2"> <Target className="w-4 h-4 text-gray-500" /> <select value={filterCharacter} onChange={(e) => setFilterCharacter(e.target.value)} className="bg-white border border-gray-300 rounded px-3 py-1 text-sm" > <option value="all">All Characters</option> {characters.map((c) => ( <option key={c.name} value={c.name}> {c.name} </option> ))} </select> </div> <div className="flex items-center gap-2"> <Flag className="w-4 h-4 text-gray-500" /> <select value={filterStatus} onChange={(e) => setFilterStatus(e.target.value)} className="bg-white border border-gray-300 rounded px-3 py-1 text-sm" > <option value="all">All Statuses</option> <option value="not_started">Not Started</option> <option value="in_progress">In Progress</option> <option value="at_risk">At Risk</option> <option value="completed">Completed</option> <option value="deferred">Deferred</option> </select> </div> <button onClick={() => setShowNewGoal(true)} className="ml-auto px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700 flex items-center gap-2" > <Plus className="w-4 h-4" /> New Goal </button> </div> </div> {/* Goals list */} <div className="p-6 space-y-3"> {filteredGoals.length === 0 ? ( <div className="text-center text-gray-500 py-8"> <AlertCircle className="w-10 h-10 mx-auto mb-2 opacity-60" /> <p>No goals yet. Use "New Goal" or add a suggested goal below.</p> </div> ) : ( filteredGoals.map((goal) => ( <div key={goal.id} className="p-4 border border-gray-200 rounded-lg" > <div className="flex items-start justify-between"> <div className="flex-1"> <div className="flex items-center gap-2 mb-1"> <h3 className="font-medium text-gray-900">{goal.title}</h3> <span className={`px-2 py-0.5 rounded-full text-xs border ${getPriorityBadge(goal.priority)}`} > {goal.priority} </span> <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${getStatusBadge(goal.status)}`} > {goal.status.replace('_', ' ')} </span> </div> {goal.description && ( <p className="text-sm text-gray-600 mb-2"> {goal.description} </p> )} <div className="flex items-center gap-4 text-xs text-gray-500"> <div className="flex items-center gap-1"> <Target className="w-3 h-3" /> {goal.owner} </div> {goal.targetChapter && ( <div className="flex items-center gap-1"> <Calendar className="w-3 h-3" /> Target: Ch {goal.targetChapter} </div> )} <div className="flex items-center gap-1"> <TrendingUp className="w-3 h-3" /> {goal.milestones.filter((m) => m.done).length}/{goal.milestones.length}{' '} milestones </div> </div> </div> <div className="flex items-center gap-2"> <button onClick={() => updateGoal(goal.id, { status: goal.status === 'completed' ? 'in_progress' : 'completed', }) } className="p-2 text-gray-500 hover:text-gray-700" title={goal.status === 'completed' ? 'Mark In Progress' : 'Mark Complete'} > {goal.status === 'completed' ? ( <Circle className="w-4 h-4" /> ) : ( <CheckCircle2 className="w-4 h-4" /> )} </button> <button onClick={() => removeGoal(goal.id)} className="p-2 text-gray-500 hover:text-red-600" title="Delete Goal" > <Trash2 className="w-4 h-4" /> </button> </div> </div> {/* Milestones */} <div className="mt-3 pt-3 border-t border-gray-200"> <div className="flex items-center justify-between mb-2"> <h4 className="text-sm font-medium text-gray-700"> Milestones </h4> <button onClick={() => addMilestone(goal)} className="text-xs px-2 py-1 border border-gray-300 rounded hover:bg-gray-50" > Add milestone </button> </div> {goal.milestones.length === 0 ? ( <p className="text-xs text-gray-500">No milestones yet.</p> ) : ( <div className="space-y-2"> {goal.milestones.map((m) => ( <div key={m.id} className="flex items-center justify-between p-2 bg-gray-50 rounded" > <div className="flex items-center gap-2"> <button onClick={() => updateMilestone(goal, m.id, { done: !m.done })} className="p-1 text-gray-500 hover:text-gray-700" > {m.done ? ( <CheckCircle2 className="w-4 h-4 text-green-600" /> ) : ( <Circle className="w-4 h-4" /> )} </button> <input className="bg-transparent text-sm text-gray-800 focus:outline-none" value={m.title} onChange={(e) => updateMilestone(goal, m.id, { title: e.target.value })} /> </div> <div className="flex items-center gap-2 text-xs text-gray-500"> <Clock className="w-3 h-3" /> <select value={m.chapter || ''} onChange={(e) => updateMilestone(goal, m.id, { chapter: e.target.value ? Number(e.target.value) : undefined, }) } className="bg-white border border-gray-300 rounded px-2 py-0.5" > <option value="">Chapter</option> {Array.from({ length: totalChapters }, (_, i) => ( <option key={i + 1} value={i + 1}> Ch {i + 1} </option> ))} </select> <button onClick={() => removeMilestone(goal, m.id)} className="p-1 text-gray-500 hover:text-red-600" > <Trash2 className="w-4 h-4" /> </button> </div> </div> ))} </div> )} </div> </div> )) )} </div> {/* Suggested goals */} <div className="p-6 border-t border-gray-200 bg-gray-50"> <h3 className="font-medium text-gray-900 mb-3">Suggested Goals</h3> {suggestedGoals.length === 0 ? ( <p className="text-sm text-gray-600">No suggestions available.</p> ) : ( <div className="grid grid-cols-1 md:grid-cols-2 gap-3"> {suggestedGoals.slice(0, 6).map((sg) => ( <div key={sg.id} className="p-3 border border-gray-200 rounded-lg bg-white" > <div className="flex items-start justify-between"> <div> <div className="flex items-center gap-2 mb-1"> <h4 className="text-sm font-medium text-gray-900"> {sg.title} </h4> <span className={`px-2 py-0.5 rounded-full text-xs border ${getPriorityBadge(sg.priority)}`} > {sg.priority} </span> </div> <div className="text-xs text-gray-500"> {sg.owner} • target Ch {sg.targetChapter} </div> </div> <button onClick={() => onGoalsChange?.([sg, ...goals])} className="text-xs px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700" > Add </button> </div> </div> ))} </div> )} </div> {/* New goal inline form */} {showNewGoal && ( <div className="p-6 border-t border-gray-200"> <div className="p-4 border border-gray-200 rounded-lg"> <h3 className="font-medium text-gray-900 mb-3">Create Goal</h3> <NewGoalForm characters={characters} totalChapters={totalChapters} onCancel={() => setShowNewGoal(false)} onCreate={(goal) => { onGoalsChange?.([goal, ...goals]); setShowNewGoal(false); }} /> </div> </div> )} </div> ); } function NewGoalForm({ characters, totalChapters, onCreate, onCancel, }: { characters: GeneratedCharacter[]; totalChapters: number; onCreate: (goal: CharacterGoal) => void; onCancel: () => void; }) { const [title, setTitle] = useState(''); const [owner, setOwner] = useState(characters[0]?.name || ''); const [type, setType] = useState<CharacterGoal['type']>('internal'); const [priority, setPriority] = useState<CharacterGoal['priority']>('medium'); const [status, setStatus] = useState<CharacterGoal['status']>('not_started'); const [targetChapter, setTargetChapter] = useState<number | undefined>(undefined); const [description, setDescription] = useState(''); const create = () => { if (!title || !owner) return; onCreate({ id: `goal-${Date.now()}`, title, description, owner, type, priority, status, targetChapter, milestones: [], }); }; return ( <div className="space-y-3"> <div className="grid grid-cols-1 md:grid-cols-2 gap-3"> <div> <label className="block text-xs text-gray-500 mb-1">Title</label> <input className="w-full border border-gray-300 rounded px-3 py-2 bg-white text-sm" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., Confront past trauma" /> </div> <div> <label className="block text-xs text-gray-500 mb-1">Owner</label> <select className="w-full border border-gray-300 rounded px-3 py-2 bg-white text-sm" value={owner} onChange={(e) => setOwner(e.target.value)} > {characters.map((c) => ( <option key={c.name} value={c.name}> {c.name} </option> ))} </select> </div> </div> <div className="grid grid-cols-1 md:grid-cols-3 gap-3"> <div> <label className="block text-xs text-gray-500 mb-1">Type</label> <select className="w-full border border-gray-300 rounded px-3 py-2 bg-white text-sm" value={type} onChange={(e) => setType(e.target.value as any)} > <option value="internal">Internal</option> <option value="external">External</option> <option value="relationship">Relationship</option> <option value="skill">Skill</option> </select> </div> <div> <label className="block text-xs text-gray-500 mb-1">Priority</label> <select className="w-full border border-gray-300 rounded px-3 py-2 bg-white text-sm" value={priority} onChange={(e) => setPriority(e.target.value as any)} > <option value="low">Low</option> <option value="medium">Medium</option> <option value="high">High</option> <option value="critical">Critical</option> </select> </div> <div> <label className="block text-xs text-gray-500 mb-1">Status</label> <select className="w-full border border-gray-300 rounded px-3 py-2 bg-white text-sm" value={status} onChange={(e) => setStatus(e.target.value as any)} > <option value="not_started">Not Started</option> <option value="in_progress">In Progress</option> <option value="at_risk">At Risk</option> <option value="completed">Completed</option> <option value="deferred">Deferred</option> </select> </div> </div> <div className="grid grid-cols-1 md:grid-cols-2 gap-3"> <div> <label className="block text-xs text-gray-500 mb-1">Target Chapter (optional)</label> <select className="w-full border border-gray-300 rounded px-3 py-2 bg-white text-sm" value={targetChapter || ''} onChange={(e) => setTargetChapter(e.target.value ? Number(e.target.value) : undefined)} > <option value="">None</option> {Array.from({ length: totalChapters }, (_, i) => ( <option key={i + 1} value={i + 1}> Chapter {i + 1} </option> ))} </select> </div> <div> <label className="block text-xs text-gray-500 mb-1">Description (optional)</label> <textarea className="w-full border border-gray-300 rounded px-3 py-2 bg-white text-sm" value={description} onChange={(e) => setDescription(e.target.value)} rows={2} placeholder="What does success look like?" /> </div> </div> <div className="flex items-center justify-end gap-2"> <button onClick={onCancel} className="px-3 py-1 text-sm border border-gray-300 rounded" > Cancel </button> <button onClick={create} className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700" > Create Goal </button> </div> </div> ); } 
/Users/davehail/Developer/inkwell/src/components/Planning/StoryArchitectMode.tsx:1:// src/components/Planning/StoryArchitectMode.tsx import { Wand2, BookOpen, Target, Palette, MapPin, Lightbulb } from 'lucide-react'; import React, { useState } from 'react'; import { useToast } from '@/context/toast'; import { useLoading } from '../../hooks/useLoading'; import { storyArchitectService, type StoryPremise, type GeneratedOutline, } from '../../services/storyArchitectService'; interface StoryArchitectModeProps { onOutlineGenerated: (outline: GeneratedOutline) => void; onClose: () => void; } export const StoryArchitectMode: React.FC<StoryArchitectModeProps> = ({ onOutlineGenerated, onClose, }) => { const [premise, setPremise] = useState<StoryPremise>({ title: '', genre: '', premise: '', targetLength: 'novel', tone: '', themes: [], setting: '', // Enhanced character-driven options focusType: 'balanced', povStyle: 'single-pov', characterCount: 'moderate', relationshipFocus: [], characterDevelopmentDepth: 'moderate', narrativePerspective: 'third-limited', }); const [currentTheme, setCurrentTheme] = useState(''); const { showToast } = useToast(); const { isLoading: _isLoading } = useLoading(); // Local loading state since useLoading doesn't have setIsLoading const [isGenerating, setIsGenerating] = useState(false); // Simple loading wrapper const withLoading = async (fn: () => Promise<void>) => { setIsGenerating(true); try { await fn(); } finally { setIsGenerating(false); } }; const genres = [ 'Fantasy', 'Science Fiction', 'Mystery', 'Thriller', 'Romance', 'Literary Fiction', 'Historical Fiction', 'Horror', 'Adventure', 'Young Adult', 'Contemporary Fiction', 'Dystopian', 'Urban Fantasy', ]; const tones = [ 'Dark and Gritty', 'Light and Humorous', 'Epic and Grand', 'Intimate and Personal', 'Fast-paced and Action-packed', 'Contemplative and Philosophical', 'Romantic and Emotional', 'Mysterious and Suspenseful', 'Satirical and Witty', ]; const addTheme = () => { if (currentTheme.trim() && !premise.themes?.includes(currentTheme.trim())) { setPremise((prev) => ({ ...prev, themes: [...(prev.themes || []), currentTheme.trim()], })); setCurrentTheme(''); } }; const removeTheme = (theme: string) => { setPremise((prev) => ({ ...prev, themes: prev.themes?.filter((t) => t !== theme) || [], })); }; const handleGenerate = async () => { if (!premise.title.trim() || !premise.genre || !premise.premise.trim()) { showToast('Please fill in title, genre, and premise', 'error'); return; } await withLoading(async () => { try { const outline = await storyArchitectService.generateOutline(premise); onOutlineGenerated(outline); showToast('Story outline generated successfully!', 'success'); } catch (error) { console.error('Generation failed:', error); showToast('Failed to generate outline. Please try again.', 'error'); } }); }; return ( <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50"> <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto"> <div className="p-6"> {/* Header */} <div className="flex items-center justify-between mb-6"> <div className="flex items-center gap-3"> <div className="p-2 bg-purple-100 rounded-lg"> <Wand2 className="w-6 h-6 text-purple-600" /> </div> <div> <h2 className="text-xl font-semibold text-gray-900"> Story Architect Mode </h2> <p className="text-sm text-gray-600"> Generate a complete story outline from your premise </p> </div> </div> <button onClick={onClose} className="text-gray-400 hover:text-gray-600" > <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /> </svg> </button> </div> <div className="space-y-6"> {/* Title */} <div className="space-y-2"> <label className="flex items-center gap-2 text-sm font-medium text-gray-900"> <BookOpen className="w-4 h-4" /> Story Title </label> <input type="text" value={premise.title} onChange={(e) => setPremise((prev) => ({ ...prev, title: e.target.value }))} placeholder="Enter your story title..." className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" /> </div> {/* Genre and Length */} <div className="grid grid-cols-2 gap-4"> <div className="space-y-2"> <label className="flex items-center gap-2 text-sm font-medium text-gray-900"> <Target className="w-4 h-4" /> Genre </label> <select value={premise.genre} onChange={(e) => setPremise((prev) => ({ ...prev, genre: e.target.value }))} className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" > <option value="">Select genre...</option> {genres.map((genre) => ( <option key={genre} value={genre}> {genre} </option> ))} </select> </div> <div className="space-y-2"> <label className="text-sm font-medium text-gray-900"> Target Length </label> <select value={premise.targetLength} onChange={(e) => setPremise((prev) => ({ ...prev, targetLength: e.target.value as any })) } className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" > <option value="short">Short Story (10-40k words)</option> <option value="novella">Novella (40-70k words)</option> <option value="novel">Novel (70-120k words)</option> <option value="epic">Epic (120k+ words)</option> </select> </div> </div> {/* Premise */} <div className="space-y-2"> <label className="flex items-center gap-2 text-sm font-medium text-gray-900"> <Lightbulb className="w-4 h-4" /> Story Premise </label> <textarea value={premise.premise} onChange={(e) => setPremise((prev) => ({ ...prev, premise: e.target.value }))} placeholder="Describe your story idea in 2-3 sentences. What happens? Who are the main characters? What's at stake?" rows={4} className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent resize-none" /> </div> {/* Tone and Setting */} <div className="grid grid-cols-2 gap-4"> <div className="space-y-2"> <label className="flex items-center gap-2 text-sm font-medium text-gray-900"> <Palette className="w-4 h-4" /> Tone </label> <select value={premise.tone} onChange={(e) => setPremise((prev) => ({ ...prev, tone: e.target.value }))} className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" > <option value="">Select tone...</option> {tones.map((tone) => ( <option key={tone} value={tone}> {tone} </option> ))} </select> </div> <div className="space-y-2"> <label className="flex items-center gap-2 text-sm font-medium text-gray-900"> <MapPin className="w-4 h-4" /> Setting (Optional) </label> <input type="text" value={premise.setting} onChange={(e) => setPremise((prev) => ({ ...prev, setting: e.target.value }))} placeholder="e.g., Medieval England, Future Mars, Modern NYC..." className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" /> </div> </div> {/* Themes */} <div className="space-y-2"> <label className="text-sm font-medium text-gray-900"> Themes (Optional) </label> <div className="flex gap-2"> <input type="text" value={currentTheme} onChange={(e) => setCurrentTheme(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && (e.preventDefault(), addTheme())} placeholder="Add themes like 'redemption', 'power', 'love'..." className="flex-1 px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" /> <button onClick={addTheme} className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300" > Add </button> </div> {premise.themes && premise.themes.length > 0 && ( <div className="flex flex-wrap gap-2 mt-2"> {premise.themes.map((theme) => ( <span key={theme} className="inline-flex items-center gap-1 px-2 py-1 bg-purple-100 text-purple-700 rounded-md text-sm" > {theme} <button onClick={() => removeTheme(theme)} className="hover:text-purple-900" > × </button> </span> ))} </div> )} </div> {/* Advanced Character & POV Options */} <div className="space-y-4 pt-4 border-t border-gray-200"> <h3 className="text-lg font-medium text-gray-900 flex items-center gap-2"> <svg className="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" > <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5 0a4.002 4.002 0 01-8 0 4.002 4.002 0 018 0z" /> </svg> Character & POV Settings </h3> {/* Story Focus & Character Count */} <div className="grid grid-cols-2 gap-4"> <div className="space-y-2"> <label className="text-sm font-medium text-gray-900"> Story Focus </label> <select value={premise.focusType || 'balanced'} onChange={(e) => setPremise((prev) => ({ ...prev, focusType: e.target.value as any })) } className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" > <option value="plot-driven">Plot-Driven (Action & Events)</option> <option value="character-driven">Character-Driven (Internal Growth)</option> <option value="balanced">Balanced (Both Plot & Character)</option> </select> </div> <div className="space-y-2"> <label className="text-sm font-medium text-gray-900"> Character Count </label> <select value={premise.characterCount || 'moderate'} onChange={(e) => setPremise((prev) => ({ ...prev, characterCount: e.target.value as any })) } className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" > <option value="minimal">Minimal (2-3 characters)</option> <option value="moderate">Moderate (4-6 characters)</option> <option value="ensemble">Ensemble (6+ characters)</option> </select> </div> </div> {/* POV Style & Narrative Perspective */} <div className="grid grid-cols-2 gap-4"> <div className="space-y-2"> <label className="text-sm font-medium text-gray-900"> POV Style </label> <select value={premise.povStyle || 'single-pov'} onChange={(e) => setPremise((prev) => ({ ...prev, povStyle: e.target.value as any })) } className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" > <option value="single-pov">Single POV (One Character)</option> <option value="dual-pov">Dual POV (Two Characters)</option> <option value="multi-pov">Multi POV (3-4 Characters)</option> <option value="alternating-pov">Alternating POV (Systematic)</option> </select> </div> <div className="space-y-2"> <label className="text-sm font-medium text-gray-900"> Narrative Perspective </label> <select value={premise.narrativePerspective || 'third-limited'} onChange={(e) => setPremise((prev) => ({ ...prev, narrativePerspective: e.target.value as any, })) } className="w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900 focus:ring-2 focus:ring-purple-500 focus:border-transparent" > <option value="first-person">First Person (I, me)</option> <option value="third-limited">Third Limited (He/she, limited)</option> <option value="third-omniscient">Third Omniscient (He/she, all-knowing)</option> <option value="mixed">Mixed (Varies by character)</option> </select> </div> </div> {/* Character Development Depth */} <div className="space-y-2"> <label className="text-sm font-medium text-gray-900"> Character Development Depth </label> <div className="grid grid-cols-3 gap-2"> {['light', 'moderate', 'deep'].map((depth) => ( <button key={depth} onClick={() => setPremise((prev) => ({ ...prev, characterDevelopmentDepth: depth as any })) } className={`p-2 text-sm rounded-md border transition-colors ${ premise.characterDevelopmentDepth === depth ? 'border-purple-500 bg-purple-50 text-purple-700' : 'border-gray-300 hover:border-gray-400' }`} > <div className="font-medium capitalize">{depth}</div> <div className="text-xs text-gray-500 mt-1"> {depth === 'light' && 'Basic arcs'} {depth === 'moderate' && 'Full development'} {depth === 'deep' && 'Complex psychology'} </div> </button> ))} </div> </div> </div> </div> {/* Actions */} <div className="flex items-center justify-between mt-8 pt-6 border-t border-gray-200"> <button onClick={onClose} className="px-4 py-2 text-gray-600 hover:text-gray-800" > Cancel </button> <button onClick={handleGenerate} disabled={ isGenerating || !premise.title.trim() || !premise.genre || !premise.premise.trim() } className="flex items-center gap-2 px-6 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400 text-white rounded-md font-medium transition-colors" > {isGenerating ? ( <> <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" /> Generating... </> ) : ( <> <Wand2 className="w-4 h-4" /> Generate Outline </> )} </button> </div> </div> </div> </div> ); }; 
/Users/davehail/Developer/inkwell/src/components/Onboarding/useTour.ts:81:// Export stub for ONBOARDING_STEPS for backward compatibility
/Users/davehail/Developer/inkwell/src/components/Onboarding/useTour.ts:84:// Add updateChecklist stub
/Users/davehail/Developer/inkwell/src/components/Onboarding/tourAnalytics.ts:104:  // TODO: Wire to your analytics service
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:201:                  placeholder="Enter name"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:213:                  placeholder="Describe this element"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:218:                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-400"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:228:                      placeholder="Mountains, valleys, coastlines..."
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:236:                      placeholder="Tropical, temperate, arctic..."
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:244:                      placeholder="~10,000 residents"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:252:                      placeholder="Why is this location important?"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:262:                      placeholder="Major events that happened here..."
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:266:                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-400"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:278:                      placeholder="Primary language spoken"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:286:                      placeholder="Important cultural traditions"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:294:                      placeholder="How is society organized?"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:302:                      placeholder="Honor, loyalty, freedom..."
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:312:                      placeholder="Cultural practices and customs..."
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:316:                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-400"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:344:                      placeholder="How is this rule enforced?"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:352:                      placeholder="Are there any exceptions to this rule?"
/Users/davehail/Developer/inkwell/src/components/Planning/WorldBuilding/WorldFormModal.tsx:360:                      placeholder="What happens if this rule is broken?"
/Users/davehail/Developer/inkwell/src/components/Planning/StoryArchitectFlow.tsx:501:              placeholder="Enter your story title"
/Users/davehail/Developer/inkwell/src/components/Planning/StoryArchitectFlow.tsx:561:              placeholder="e.g., Dark and mysterious, Light-hearted adventure, Romantic comedy"
/Users/davehail/Developer/inkwell/src/components/Planning/StoryArchitectFlow.tsx:576:            placeholder="Describe your story premise in 2-3 sentences. What is the main conflict? Who is the protagonist? What's at stake?"
/Users/davehail/Developer/inkwell/src/components/Panels/SettingsPanel.tsx:301:                    placeholder={
/Users/davehail/Developer/inkwell/src/components/Panels/SettingsPanel.tsx:664:                          placeholder="Enter phrase to ignore..."
/Users/davehail/Developer/inkwell/src/components/Panels/WritingPanel.tsx:2: * @deprecated This component uses the legacy scene-based writing model.
/Users/davehail/Developer/inkwell/src/components/Panels/WritingPanel.tsx:529:                  placeholder={`Start writing "${currentScene.title}"...`}
/Users/davehail/Developer/inkwell/src/components/Onboarding/hooks/__tests__/TourController.test.ts:13:    vi.stubGlobal('localStorage', {
/Users/davehail/Developer/inkwell/src/components/Planning/BeatSheetPlanner.tsx:366:                        placeholder="Describe what happens in this beat..."
/Users/davehail/Developer/inkwell/src/components/Onboarding/hooks/__tests__/useSpotlightAutostartHardened.test.tsx:39:    vi.stubGlobal('requestAnimationFrame', (cb: FrameRequestCallback) => {
/Users/davehail/Developer/inkwell/src/components/Onboarding/hooks/__tests__/useSpotlightAutostartHardened.test.tsx:43:    vi.stubGlobal('cancelAnimationFrame', vi.fn());
/Users/davehail/Developer/inkwell/src/components/Onboarding/hooks/__tests__/useSpotlightAutostartHardened.test.tsx:47:    vi.unstubAllGlobals();
/Users/davehail/Developer/inkwell/src/components/Onboarding/hooks/__tests__/useSpotlightAutostartHardened.test.tsx:211:    vi.stubGlobal('cancelAnimationFrame', cancelAnimationFrame);
/Users/davehail/Developer/inkwell/src/components/AI/JustInTimeAI.tsx:1:// src/components/AI/JustInTimeAI.tsx import { Sparkles, Key, Zap, Info, ExternalLink, CheckCircle, AlertCircle } from 'lucide-react'; import React, { useState } from 'react'; import { aiConfigService } from '../../services/aiConfigService'; import { analyticsService } from '../../services/analyticsService'; import { featureFlagService } from '../../services/featureFlagService'; import { Badge } from '../ui/badge'; import { Button } from '../ui/Button'; import { Dialog } from '../ui/dialog'; import { Input } from '../ui/Input'; import { Label } from '../ui/label'; interface JustInTimeAIProps { isOpen: boolean; onClose: () => void; onConfigured: () => void; requestedAction: string; selectedText?: string; projectId?: string; } interface AIConfigStep { step: 'intro' | 'provider' | 'apikey' | 'testing' | 'complete'; } export function JustInTimeAI({ isOpen, onClose, onConfigured, requestedAction, selectedText, projectId, }: JustInTimeAIProps) { const [currentStep, setCurrentStep] = useState<AIConfigStep['step']>('intro'); const [selectedProvider, setSelectedProvider] = useState<'claude' | 'openai' | 'mock'>('claude'); const [apiKey, setApiKey] = useState(''); const [isValidating, setIsValidating] = useState(false); const [validationError, setValidationError] = useState<string | null>(null); const [showMockOption, setShowMockOption] = useState(false); const handleClose = () => { // Track abandonment analyticsService.track('ai_setup_abandoned', { projectId, requestedAction, step: currentStep, reason: 'user_closed', }); setCurrentStep('intro'); setApiKey(''); setValidationError(null); onClose(); }; const handleUseMock = () => { // Enable mock mode featureFlagService.setEnabled('ai_mock_mode', true); analyticsService.track('ai_setup_mock_selected', { projectId, requestedAction, reason: 'user_choice', }); onConfigured(); onClose(); }; const handleProviderSelect = (provider: 'claude' | 'openai' | 'mock') => { setSelectedProvider(provider); if (provider === 'mock') { handleUseMock(); return; } analyticsService.track('ai_provider_selected', { provider, projectId, requestedAction, }); setCurrentStep('apikey'); }; const handleApiKeySubmit = async () => { if (!apiKey.trim()) return; setIsValidating(true); setValidationError(null); try { const result = await aiConfigService.initialize(apiKey, selectedProvider); if (result.isValid) { analyticsService.track('ai_setup_completed', { provider: selectedProvider, projectId, requestedAction, setupDuration: Date.now() - Date.now(), // Would track actual duration }); setCurrentStep('complete'); setTimeout(() => { onConfigured(); onClose(); }, 2000); } else { setValidationError(result.error || 'Configuration failed'); // Show mock option as fallback if (!showMockOption) { setShowMockOption(true); } } } catch { setValidationError('Failed to connect to AI service'); setShowMockOption(true); } finally { setIsValidating(false); } }; const getProviderInfo = (provider: 'claude' | 'openai' | 'mock') => { switch (provider) { case 'claude': return { name: 'Anthropic Claude', description: 'Advanced AI assistant optimized for creative writing', keyFormat: 'sk-ant-api03-...', signupUrl: 'https://console.anthropic.com/', recommended: true, }; case 'openai': return { name: 'OpenAI GPT', description: 'Popular AI model with broad capabilities', keyFormat: 'sk-...', signupUrl: 'https://platform.openai.com/', recommended: false, }; case 'mock': return { name: 'Demo Mode', description: 'Mock AI responses for testing', keyFormat: 'demo-key', signupUrl: '#', recommended: false, }; } }; const renderIntroStep = () => ( <div className="space-y-6"> <div className="text-center"> <Sparkles className="w-12 h-12 mx-auto text-blue-600 mb-4" /> <h3 className="text-lg font-semibold mb-2">Try AI-powered writing assistance</h3> <p className="text-gray-600"> You wanted to "{requestedAction}". Let's set up AI to help with that. </p> </div> {selectedText && ( <div className="bg-gray-50 rounded-lg p-4"> <p className="text-sm text-gray-600 mb-2">Your selected text:</p> <p className="text-gray-800 italic"> "{selectedText.substring(0, 100)} {selectedText.length > 100 ? '...' : ''}" </p> </div> )} <div className="space-y-3"> <Button onClick={() => setCurrentStep('provider')} className="w-full" size="lg"> <Key className="w-4 h-4 mr-2" /> Set up AI (2 minutes) </Button> <Button variant="outline" onClick={handleUseMock} className="w-full"> <Zap className="w-4 h-4 mr-2" /> Try demo mode instead </Button> </div> <div className="text-center"> <button onClick={handleClose} className="text-sm text-gray-500 hover:text-gray-700"> Maybe later </button> </div> </div> ); const renderProviderStep = () => ( <div className="space-y-6"> <div> <h3 className="text-lg font-semibold mb-2">Choose your AI provider</h3> <p className="text-gray-600"> Select the AI service you'd like to use for writing assistance. </p> </div> <div className="space-y-3"> {(['claude', 'openai'] as const).map((provider) => { const info = getProviderInfo(provider); return ( <button key={provider} onClick={() => handleProviderSelect(provider)} className="w-full p-4 border-2 border-gray-200 rounded-lg hover:border-blue-500 focus:border-blue-500 focus:outline-none transition-colors text-left" > <div className="flex items-center justify-between"> <div> <div className="flex items-center space-x-2 mb-1"> <span className="font-medium">{info.name}</span> {info.recommended && ( <Badge variant="default" className="text-xs"> Recommended </Badge> )} </div> <p className="text-sm text-gray-600">{info.description}</p> </div> <ExternalLink className="w-4 h-4 text-gray-400" /> </div> </button> ); })} {/* Mock option */} <button onClick={() => handleProviderSelect('mock')} className="w-full p-4 border-2 border-gray-200 rounded-lg hover:border-green-500 focus:border-green-500 focus:outline-none transition-colors text-left" > <div className="flex items-center justify-between"> <div> <div className="flex items-center space-x-2 mb-1"> <span className="font-medium">Demo Mode</span> <Badge variant="secondary" className="text-xs"> No setup required </Badge> </div> <p className="text-sm text-gray-600">Try AI features with realistic mock responses</p> </div> <Zap className="w-4 h-4 text-green-600" /> </div> </button> </div> <div className="text-center"> <button onClick={() => setCurrentStep('intro')} className="text-sm text-gray-500 hover:text-gray-700" > ← Back </button> </div> </div> ); const renderApiKeyStep = () => { const info = getProviderInfo(selectedProvider); return ( <div className="space-y-6"> <div> <h3 className="text-lg font-semibold mb-2">Connect to {info.name}</h3> <p className="text-gray-600">Enter your API key to enable AI assistance.</p> </div> <div className="space-y-4"> <div> <Label htmlFor="apiKey">API Key</Label> <Input id="apiKey" type="password" placeholder={info.keyFormat} value={apiKey} onChange={(e) => setApiKey(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && handleApiKeySubmit()} className="mt-1" /> <p className="text-xs text-gray-500 mt-1"> Your key is stored securely and never shared. </p> </div> {validationError && ( <div className="rounded-md bg-red-50 p-4"> <div className="flex"> <AlertCircle className="h-5 w-5 text-red-400" /> <div className="ml-3"> <p className="text-sm text-red-800">{validationError}</p> </div> </div> </div> )} {showMockOption && ( <div className="rounded-md bg-blue-50 p-4"> <div className="flex"> <Info className="h-5 w-5 text-blue-400" /> <div className="ml-3"> <p className="text-sm text-blue-800"> Having trouble? You can{' '} <button onClick={handleUseMock} className="font-medium text-blue-600 hover:text-blue-700 underline" > try demo mode instead </button> . </p> </div> </div> </div> )} </div> <div className="space-y-3"> <Button onClick={handleApiKeySubmit} disabled={!apiKey.trim() || isValidating} className="w-full" size="lg" > {isValidating ? 'Testing connection...' : 'Connect AI'} </Button> <div className="text-center text-sm text-gray-600"> Don't have an API key?{' '} <a href={info.signupUrl} target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:text-blue-700" > Sign up for {info.name} → </a> </div> </div> <div className="text-center"> <button onClick={() => setCurrentStep('provider')} className="text-sm text-gray-500 hover:text-gray-700" > ← Back </button> </div> </div> ); }; const renderCompleteStep = () => ( <div className="text-center space-y-6"> <CheckCircle className="w-16 h-16 mx-auto text-green-600" /> <div> <h3 className="text-lg font-semibold mb-2">AI is ready!</h3> <p className="text-gray-600">Returning to your text to "{requestedAction}"</p> </div> </div> ); const getStepContent = () => { switch (currentStep) { case 'intro': return renderIntroStep(); case 'provider': return renderProviderStep(); case 'apikey': return renderApiKeyStep(); case 'complete': return renderCompleteStep(); default: return renderIntroStep(); } }; return ( <Dialog open={isOpen} onOpenChange={handleClose}> <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50"> <div className="bg-white rounded-lg shadow-xl max-w-md w-full p-6"> <div className="mb-4"> <h2 className="text-lg font-semibold"> {currentStep === 'complete' ? 'Setup Complete!' : 'AI Writing Assistant'} </h2> {currentStep !== 'complete' && ( <p className="text-sm text-gray-600 mt-1"> Quick setup to enable "{requestedAction}" and other AI features. </p> )} </div> {getStepContent()} </div> </div> </Dialog> ); } // Hook for managing just-in-time AI flow export function useJustInTimeAI() { const [isOpen, setIsOpen] = useState(false); const [pendingRequest, setPendingRequest] = useState<{ action: string; selectedText?: string; resolve: () => void; reject: (error: Error) => void; } | null>(null); const requestAIAction = async (action: string, selectedText?: string, projectId?: string) => { // Check if AI is already configured if (aiConfigService.isConfigured() || featureFlagService.isEnabled('ai_mock_mode')) { return Promise.resolve(); } // Track the request analyticsService.track('ai_action_requested', { action, hasSelectedText: !!selectedText, projectId, }); return new Promise<void>((resolve, reject) => { setPendingRequest({ action, selectedText, resolve, reject }); setIsOpen(true); }); }; const handleConfigured = () => { if (pendingRequest) { pendingRequest.resolve(); setPendingRequest(null); } setIsOpen(false); }; const handleClose = () => { if (pendingRequest) { pendingRequest.reject(new Error('AI setup cancelled')); setPendingRequest(null); } setIsOpen(false); }; const JustInTimeDialog = pendingRequest ? ( <JustInTimeAI isOpen={isOpen} onClose={handleClose} onConfigured={handleConfigured} requestedAction={pendingRequest.action} selectedText={pendingRequest.selectedText} /> ) : null; return { requestAIAction, JustInTimeDialog, }; } 
/Users/davehail/Developer/inkwell/src/components/AI/AiSettingsPanel.tsx:143:              className="w-full rounded-lg border border-inkwell-border bg-inkwell-card px-3 py-2 text-inkwell-text placeholder:text-inkwell-muted focus:border-inkwell-accent focus:outline-none disabled:opacity-50"
/Users/davehail/Developer/inkwell/src/components/AI/AiSettingsPanel.tsx:144:              placeholder="sk-ant-..., sk-..., AIza..."
/Users/davehail/Developer/inkwell/src/components/Search/SmartSearchModal.tsx:135:          contextProject: currentProject as any, // TODO: Fix type conversion from Project to EnhancedProject
/Users/davehail/Developer/inkwell/src/components/Search/SmartSearchModal.tsx:301:              placeholder={`Search your ${currentProject?.name || 'project'}...`}
/Users/davehail/Developer/inkwell/src/components/Search/SmartSearchModal.tsx:302:              className="flex-1 bg-transparent border-none outline-none text-lg placeholder-gray-500"
/Users/davehail/Developer/inkwell/src/components/Dashboard/Welcome.tsx:1:// Minimal stub for Welcome component
/Users/davehail/Developer/inkwell/src/components/Search/SearchBar.tsx:9:  placeholder?: string;
/Users/davehail/Developer/inkwell/src/components/Search/SearchBar.tsx:16:  placeholder = 'Search scenes, characters, plot notes...',
/Users/davehail/Developer/inkwell/src/components/Search/SearchBar.tsx:45:          placeholder={placeholder}
/Users/davehail/Developer/inkwell/src/components/Search/SmartSearchTrigger.tsx:1:// src/components/Search/SmartSearchTrigger.tsx import { Search, Sparkles } from 'lucide-react'; import React from 'react'; import { cn } from '@/utils/cn'; interface SmartSearchTriggerProps { onClick: () => void; variant?: 'button' | 'input' | 'minimal'; size?: 'sm' | 'md' | 'lg'; placeholder?: string; shortcut?: string[]; disabled?: boolean; className?: string; showAI?: boolean; } export const SmartSearchTrigger: React.FC<SmartSearchTriggerProps> = ({ onClick, variant = 'input', size = 'md', placeholder = 'Search your project...', shortcut = ['⌘', '⇧', 'F'], disabled = false, className = '', showAI = true, }) => { const baseClasses = cn( 'transition-all duration-200 focus:outline-none', disabled && 'opacity-50 cursor-not-allowed', ); if (variant === 'button') { return ( <button onClick={onClick} disabled={disabled} className={cn( baseClasses, 'inline-flex items-center gap-2 px-4 py-2 rounded-lg border border-gray-300', 'bg-white text-gray-700', 'hover:bg-gray-50 hover:border-gray-400', 'focus:ring-2 focus:ring-blue-500 focus:ring-offset-2', size === 'sm' && 'text-sm px-3 py-1.5', size === 'lg' && 'text-lg px-6 py-3', className, )} > <Search className={cn( 'text-gray-400', size === 'sm' && 'w-3 h-3', size === 'md' && 'w-4 h-4', size === 'lg' && 'w-5 h-5', )} /> <span>Search</span> {showAI && ( <Sparkles className={cn( 'text-blue-500', size === 'sm' && 'w-3 h-3', size === 'md' && 'w-3 h-3', size === 'lg' && 'w-4 h-4', )} /> )} {shortcut && shortcut.length > 0 && ( <div className="flex items-center gap-1 ml-auto"> {shortcut.map((key, index) => ( <kbd key={index} className={cn( 'px-1.5 py-0.5 text-xs font-mono bg-gray-100 text-gray-600 rounded border border-gray-200', size === 'sm' && 'px-1 py-0.5 text-[10px]', size === 'lg' && 'px-2 py-1 text-sm', )} > {key} </kbd> ))} </div> )} </button> ); } if (variant === 'minimal') { return ( <button onClick={onClick} disabled={disabled} className={cn( baseClasses, 'p-2 rounded-lg hover:bg-gray-100', 'text-gray-500 hover:text-gray-700', className, )} title={`Search (${shortcut.join('')})`} > <Search className={cn( size === 'sm' && 'w-4 h-4', size === 'md' && 'w-5 h-5', size === 'lg' && 'w-6 h-6', )} /> </button> ); } // Default: input variant return ( <button onClick={onClick} disabled={disabled} className={cn( baseClasses, 'w-full flex items-center gap-3 px-4 py-2.5 rounded-lg border border-gray-300', 'bg-white text-left', 'hover:bg-gray-50 hover:border-gray-400', 'focus:ring-2 focus:ring-blue-500 focus:ring-offset-2', size === 'sm' && 'px-3 py-2 text-sm', size === 'lg' && 'px-5 py-3 text-lg', className, )} > <div className="flex items-center gap-2"> <Search className={cn( 'text-gray-400', size === 'sm' && 'w-3 h-3', size === 'md' && 'w-4 h-4', size === 'lg' && 'w-5 h-5', )} /> {showAI && ( <Sparkles className={cn( 'text-blue-500', size === 'sm' && 'w-3 h-3', size === 'md' && 'w-3 h-3', size === 'lg' && 'w-4 h-4', )} /> )} </div> <span className="flex-1 text-gray-500">{placeholder}</span> {shortcut && shortcut.length > 0 && ( <div className="flex items-center gap-1"> {shortcut.map((key, index) => ( <kbd key={index} className={cn( 'px-1.5 py-0.5 text-xs font-mono bg-gray-100 text-gray-600 rounded border border-gray-200', size === 'sm' && 'px-1 py-0.5 text-[10px]', size === 'lg' && 'px-2 py-1 text-sm', )} > {key === '⌘' && '⌘'} {key === '⇧' && '⇧'} {key === '⌃' && '⌃'} {key === '⌥' && '⌥'} {!['⌘', '⇧', '⌃', '⌥'].includes(key) && key} </kbd> ))} </div> )} </button> ); }; // Quick search button with command palette style export const QuickSearchButton: React.FC<{ onClick: () => void; disabled?: boolean; className?: string; }> = ({ onClick, disabled = false, className = '' }) => { return ( <button onClick={onClick} disabled={disabled} className={cn( 'flex items-center gap-2 px-3 py-1.5 text-sm rounded-md', 'bg-gray-100 text-gray-600', 'border border-gray-200', 'hover:bg-gray-200 hover:text-gray-800', 'transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500', disabled && 'opacity-50 cursor-not-allowed', className, )} title="Smart Search" > <Search className="w-4 h-4" /> <span className="hidden sm:inline">Search</span> <Sparkles className="w-3 h-3 text-blue-500" /> </button> ); }; // Search shortcut hint for empty states export const SearchHint: React.FC<{ onClick: () => void; className?: string; }> = ({ onClick, className = '' }) => { return ( <button onClick={onClick} className={cn( 'inline-flex items-center gap-2 px-4 py-2 text-sm text-gray-500', 'hover:text-gray-700 transition-colors', 'focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-lg', className, )} > <Search className="w-4 h-4" /> <span>Press</span> <kbd className="px-1.5 py-0.5 text-xs font-mono bg-gray-100 text-gray-600 rounded border border-gray-200"> ⌘⇧F </kbd> <span>to search</span> <Sparkles className="w-3 h-3 text-blue-500" /> </button> ); }; export default SmartSearchTrigger; 
/Users/davehail/Developer/inkwell/src/components/Onboarding/README.md:288:export const PROJECT_TEMPLATES = {
/Users/davehail/Developer/inkwell/src/components/ui/ConfirmationDialog.tsx:1:// src/components/ui/ConfirmationDialog.tsx import { AlertTriangle, Trash2, X, Save, Download, RefreshCw, Archive } from 'lucide-react'; import React, { useState } from 'react'; // ========================================== // BASE CONFIRMATION DIALOG // ========================================== interface ConfirmationDialogProps { isOpen: boolean; onClose: () => void; onConfirm: () => void; title: string; message: string; confirmText?: string; cancelText?: string; variant?: 'danger' | 'warning' | 'info' | 'success'; icon?: React.ComponentType<{ className?: string }>; requiresTyping?: string; // Require typing this text to confirm isLoading?: boolean; details?: string[]; } export const ConfirmationDialog: React.FC<ConfirmationDialogProps> = ({ isOpen, _onClose, _onConfirm, _title, _message, _confirmText = 'Confirm', _cancelText = 'Cancel', _variant = 'danger', _icon: CustomIcon, _requiresTyping, _isLoading = false, _details,  }) => { const [typedText, setTypedText] = useState(''); const [isConfirmEnabled, setIsConfirmEnabled] = useState(!requiresTyping); React.useEffect(() => { if (requiresTyping) { setIsConfirmEnabled(typedText.toLowerCase() === requiresTyping.toLowerCase()); } else { setIsConfirmEnabled(true); } }, [typedText, requiresTyping]); React.useEffect(() => { if (isOpen) { setTypedText(''); } }, [isOpen]); // Handle escape key React.useEffect(() => { const handleEscape = (_e: KeyboardEvent) => { if (e.key === 'Escape' && isOpen && !isLoading) { onClose(); } }; document.addEventListener('keydown', handleEscape); return () => document.removeEventListener('keydown', handleEscape); }, [isOpen, isLoading, onClose]); if (!isOpen) return null; const variantConfig = { danger: { bgColor: 'bg-red-50', iconColor: 'text-red-600', buttonColor: 'bg-red-600 hover:bg-red-700 focus:ring-red-500', icon: AlertTriangle, }, warning: { bgColor: 'bg-amber-50', iconColor: 'text-amber-600', buttonColor: 'bg-amber-600 hover:bg-amber-700 focus:ring-amber-500', icon: AlertTriangle, }, info: { bgColor: 'bg-blue-50', iconColor: 'text-blue-600', buttonColor: 'bg-blue-600 hover:bg-blue-700 focus:ring-blue-500', icon: AlertTriangle, }, success: { bgColor: 'bg-green-50', iconColor: 'text-green-600', buttonColor: 'bg-green-600 hover:bg-green-700 focus:ring-green-500', icon: AlertTriangle, }, }; const config = variantConfig[variant]; const Icon = CustomIcon || config.icon; const handleConfirm = () => { if (isConfirmEnabled && !isLoading) { onConfirm(); } }; return ( <div className="fixed inset-0 z-50 grid place-items-center"> <div className="absolute inset-0 bg-black/40" /> <div className="relative w-full max-w-lg rounded-2xl bg-white p-6 shadow-xl ring-1 ring-black/5" role="dialog" aria-modal="true" > {/* Header */} <div className="flex items-center justify-between pb-4"> <div className="flex items-center gap-3"> <div className={`p-2 rounded-lg ${config.bgColor}`}> <Icon className={`w-6 h-6 ${config.iconColor}`} /> </div> <h3 className="text-lg font-semibold text-inkwell-navy">{title}</h3> </div> <button onClick={onClose} disabled={isLoading} className="text-slate-500 hover:text-inkwell-navy disabled:opacity-50" > <X className="w-5 h-5" /> </button> </div> {/* Content */} <div className="pb-6"> <p className="text-slate-700 mb-4">{message}</p> {/* Details */} {details && details.length > 0 && ( <div className="mb-4 p-3 bg-slate-50 rounded-lg"> <div className="text-sm text-slate-700"> <strong>This will:</strong> <ul className="mt-1 list-disc list-inside space-y-1"> {details.map((detail, _index) => ( <li key={index}>{detail}</li> ))} </ul> </div> </div> )} {/* Typing confirmation */} {requiresTyping && ( <div className="mb-4"> <label className="block text-sm font-medium text-slate-700 mb-2"> Type "{requiresTyping}" to confirm: </label> <input type="text" value={typedText} onChange={(e) => setTypedText(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg bg-white text-slate-900 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder={requiresTyping} disabled={isLoading} autoFocus /> </div> )} {/* Actions */} <div className="flex items-center gap-3 mt-6"> <button className="ink-btn ink-btn-primary">OK</button> <button onClick={onClose} disabled={isLoading} className="ink-btn ink-btn-ghost text-[color:var(--ink-fg-muted)]" > {cancelText} </button> <button onClick={handleConfirm} disabled={!isConfirmEnabled || isLoading} className={` px-4 py-2 text-white rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed ${config.buttonColor} `} > {isLoading ? ( <div className="flex items-center gap-2"> <RefreshCw className="w-4 h-4 animate-spin" /> <span>Processing...</span> </div> ) : ( confirmText )} </button> </div> </div> </div> </div> ); }; // ========================================== // SPECIALIZED CONFIRMATION DIALOGS // ========================================== // Delete confirmation dialog export const DeleteConfirmationDialog: React.FC<{ isOpen: boolean; onClose: () => void; onConfirm: () => void; itemType: string; itemName?: string; isLoading?: boolean; requiresTyping?: boolean; }> = ({ isOpen, _onClose, _onConfirm, _itemType, _itemName, _isLoading = false, _requiresTyping = false,  }) => ( <ConfirmationDialog isOpen={isOpen} onClose={onClose} onConfirm={onConfirm} title={`Delete ${itemType}`} message={`Are you sure you want to delete ${itemName ? `"${itemName}"` : `this ${itemType.toLowerCase()}`}? This action cannot be undone.`} confirmText="Delete" cancelText="Cancel" variant="danger" icon={Trash2} requiresTyping={requiresTyping ? 'DELETE' : undefined} isLoading={isLoading} details={[ `The ${itemType.toLowerCase()} will be permanently removed`, 'All associated data will be lost', 'This action cannot be undone', ]} /> ); // Save confirmation dialog (for unsaved changes) export const SaveConfirmationDialog: React.FC<{ isOpen: boolean; onClose: () => void; onSave: () => void; onDiscard: () => void; isLoading?: boolean; }> = ({ isOpen, _onClose, _onSave, _onDiscard, _isLoading = false }) => { if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"> <div className="bg-white rounded-lg shadow-xl max-w-md w-full"> <div className="p-6"> <div className="flex items-center gap-3 mb-4"> <div className="p-2 rounded-lg bg-amber-50"> <Save className="w-6 h-6 text-amber-600" /> </div> <h3 className="text-lg font-semibold text-slate-900"> Unsaved Changes </h3> </div> <p className="text-slate-600 mb-6"> You have unsaved changes. What would you like to do? </p> <div className="flex gap-3 justify-end"> <button onClick={onDiscard} disabled={isLoading} className="px-4 py-2 text-slate-700 bg-slate-100 rounded-lg hover:bg-slate-200 transition-colors disabled:opacity-50" > Discard Changes </button> <button onClick={onClose} disabled={isLoading} className="px-4 py-2 text-slate-700 border border-slate-300 rounded-lg hover:bg-slate-50 transition-colors disabled:opacity-50" > Cancel </button> <button onClick={onSave} disabled={isLoading} className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50" > {isLoading ? ( <div className="flex items-center gap-2"> <RefreshCw className="w-4 h-4 animate-spin" /> <span>Saving...</span> </div> ) : ( 'Save Changes' )} </button> </div> </div> </div> </div> ); }; // Export confirmation dialog export const ExportConfirmationDialog: React.FC<{ isOpen: boolean; onClose: () => void; onConfirm: () => void; exportType: string; fileName?: string; isLoading?: boolean; }> = ({ isOpen, _onClose, _onConfirm, _exportType, _fileName, _isLoading = false }) => ( <ConfirmationDialog isOpen={isOpen} onClose={onClose} onConfirm={onConfirm} title={`Export as ${exportType.toUpperCase()}`} message={`Export your project${fileName ? ` as "${fileName}"` : ''} in ${exportType.toUpperCase()} format?`} confirmText="Export" cancelText="Cancel" variant="info" icon={Download} isLoading={isLoading} details={[ `Export format: ${exportType.toUpperCase()}`, 'Include all chapters and content', 'Professional formatting applied', ]} /> ); // Archive confirmation dialog export const ArchiveConfirmationDialog: React.FC<{ isOpen: boolean; onClose: () => void; onConfirm: () => void; itemType: string; itemName?: string; isLoading?: boolean; }> = ({ isOpen, _onClose, _onConfirm, _itemType, _itemName, _isLoading = false }) => ( <ConfirmationDialog isOpen={isOpen} onClose={onClose} onConfirm={onConfirm} title={`Archive ${itemType}`} message={`Archive ${itemName ? `"${itemName}"` : `this ${itemType.toLowerCase()}`}? It will be moved to your archived items and hidden from the main view.`} confirmText="Archive" cancelText="Cancel" variant="warning" icon={Archive} isLoading={isLoading} details={[ `The ${itemType.toLowerCase()} will be archived`, 'You can restore it later from archived items', 'It will be hidden from the main view', ]} /> ); // ========================================== // CONFIRMATION HOOK // ========================================== interface UseConfirmationReturn { isOpen: boolean; open: (_config?: Partial<ConfirmationConfig>) => void; close: () => void; config: ConfirmationConfig; } interface ConfirmationConfig { title: string; message: string; confirmText: string; cancelText: string; variant: 'danger' | 'warning' | 'info' | 'success'; onConfirm: () => void; requiresTyping?: string; details?: string[]; } export const useConfirmation = ( defaultConfig: Partial<ConfirmationConfig> = {}, ): UseConfirmationReturn => { const [isOpen, setIsOpen] = useState(false); const [config, setConfig] = useState<ConfirmationConfig>({ title: 'Confirm Action', _message: 'Are you sure you want to continue?', _confirmText: 'Confirm', _cancelText: 'Cancel', _variant: 'info', _onConfirm: () => {}, ...defaultConfig, }); const open = (_newConfig: Partial<ConfirmationConfig> = {}) => { setConfig((prev) => ({ ...prev, ...newConfig })); setIsOpen(true); }; const close = () => { setIsOpen(false); }; return { isOpen, open, close, config, }; };
/Users/davehail/Developer/inkwell/src/components/Onboarding/steps/StepFeedback.tsx:16:        placeholder="Optional feedback"
/Users/davehail/Developer/inkwell/src/components/Onboarding/TourProvider.tsx:30:      console.warn('TourProvider stub: startTour called but not implemented');
/Users/davehail/Developer/inkwell/src/components/Onboarding/TourProvider.tsx:38:      console.warn('TourProvider stub: completeTour called but not implemented');
/Users/davehail/Developer/inkwell/src/components/Onboarding/TourProvider.tsx:41:      console.warn('TourProvider stub: resetTour called but not implemented');
