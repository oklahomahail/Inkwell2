// src/services/aiStatusMonitor.ts import { aiConfigService } from './aiConfigService'; import { aiRetryService } from './aiRetryService'; import { analyticsService } from './analyticsService'; import { featureFlagService } from './featureFlagService'; import { mockAIService } from './mockAIService'; interface APIHealthMetrics { responseTime: number; successRate: number; errorRate: number; availabilityScore: number; lastCheck: number; } interface RateLimitInfo { requestsRemaining: number; resetTime: number; requestsPerMinute: number; currentUsage: number; } interface ServiceStatus { isHealthy: boolean; statusCode: 'operational' | 'degraded' | 'outage' | 'maintenance' | 'unknown'; message: string; lastUpdated: number; details: { provider: string; model: string; configuration: 'valid' | 'invalid' | 'missing'; connectivity: 'connected' | 'disconnected' | 'testing'; authentication: 'valid' | 'invalid' | 'expired'; }; } interface UserFeedback { type: 'info' | 'warning' | 'error' | 'success'; title: string; message: string; actions?: Array<{ label: string; action: () => void; primary?: boolean; }>; persistent?: boolean; timestamp: number; } class AIStatusMonitor { private readonly CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes private readonly HISTORY_RETENTION = 24 * 60 * 60 * 1000; // 24 hours private status: ServiceStatus; private healthMetrics: APIHealthMetrics; private rateLimitInfo: RateLimitInfo; private healthHistory: Array<{ timestamp: number; isHealthy: boolean; responseTime: number }> = []; private listeners: Array<(_status: ServiceStatus) => void> = []; private feedbackListeners: Array<(_feedback: UserFeedback) => void> = []; private intervalId: NodeJS.Timeout | null = null; constructor() { this.status = this.getInitialStatus(); this.healthMetrics = this.getInitialMetrics(); this.rateLimitInfo = this.getInitialRateLimit(); this.startMonitoring(); this.subscribeToConfigChanges(); this.subscribeToFeatureFlags(); } /** * Get current service status */ getStatus(): ServiceStatus { return { ...this.status }; } /** * Get current health metrics */ getHealthMetrics(): APIHealthMetrics { return { ...this.healthMetrics }; } /** * Get rate limit information */ getRateLimitInfo(): RateLimitInfo { return { ...this.rateLimitInfo }; } /** * Get health history for charts/graphs */ getHealthHistory( hours: number = 24, ): Array<{ timestamp: number; isHealthy: boolean; responseTime: number }> { const cutoff = Date.now() - hours * 60 * 60 * 1000; return this.healthHistory.filter((entry) => entry.timestamp >= cutoff); } /** * Force a health check */ async forceHealthCheck(): Promise<ServiceStatus> { await this.performHealthCheck(); return this.getStatus(); } /** * Subscribe to status changes */ subscribe(_callback: (status: ServiceStatus) => void): () => void { this.listeners.push(callback); // Immediately notify with current status callback(this.status); return () => { const index = this.listeners.indexOf(callback); if (index > -1) { this.listeners.splice(index, 1); } }; } /** * Subscribe to user feedback notifications */ subscribeFeedback(_callback: (feedback: UserFeedback) => void): () => void { this.feedbackListeners.push(callback); return () => { const index = this.feedbackListeners.indexOf(callback); if (index > -1) { this.feedbackListeners.splice(index, 1); } }; } /** * Generate user-friendly status message */ getUserFriendlyStatus(): { icon: string; color: string; message: string; description: string; } { switch (this.status.statusCode) { case 'operational': return { icon: '‚úÖ', color: 'green', message: 'AI Assistant is ready', description: 'All systems operating normally', }; case 'degraded': return { icon: '‚ö†Ô∏è', color: 'yellow', message: 'AI service running with issues', description: 'Some features may be slower than usual', }; case 'outage': return { icon: '‚ùå', color: 'red', message: 'AI service unavailable', description: 'Service is temporarily down. Using fallback modes.', }; case 'maintenance': return { icon: 'üîß', color: 'blue', message: 'AI service under maintenance', description: 'Scheduled maintenance in progress', }; default: return { icon: '‚ùì', color: 'gray', message: 'AI service status unknown', description: 'Checking service availability...', }; } } /** * Get recommendations based on current status */ getRecommendations(): Array<{ type: 'action' | 'info' | 'warning'; title: string; description: string; action?: () => void; }> { const recommendations = []; if (!aiConfigService.isConfigured()) { recommendations.push({ type: 'action' as const, _title: 'Configure AI Assistant', _description: 'Set up your API key to enable AI writing assistance', _action: () => this.notifyFeedback({ type: 'info', title: 'AI Configuration Required', message: 'Go to Settings > AI Assistant to configure your API key', timestamp: Date.now(), }), }); } if (this.status.statusCode === 'outage') { recommendations.push({ type: 'info' as const, _title: 'Use Mock Mode', _description: 'Enable mock mode for demo functionality while service is down', _action: () => featureFlagService.enableDemoMode(), }); } if (this.healthMetrics.successRate < 0.8 && this.healthMetrics.successRate > 0) { recommendations.push({ type: 'warning' as const, title: 'Service Experiencing Issues', description: `Success rate is ${Math.round(this.healthMetrics.successRate * 100)}%. Consider trying again later.`, }); } if (this.rateLimitInfo.requestsRemaining < 10) { recommendations.push({ type: 'warning' as const, title: 'Rate Limit Approaching', description: `Only ${this.rateLimitInfo.requestsRemaining} requests remaining. Resets at ${new Date(this.rateLimitInfo.resetTime).toLocaleTimeString()}`, }); } return recommendations; } /** * Dispose of the monitor */ dispose(): void { if (this.intervalId) { clearInterval(this.intervalId); this.intervalId = null; } } // Private methods private startMonitoring(): void { // Perform initial health check this.performHealthCheck(); // Set up periodic monitoring this.intervalId = setInterval(() => { this.performHealthCheck(); }, this.CHECK_INTERVAL); } private async performHealthCheck(): Promise<void> { const startTime = Date.now(); try { // Get current configuration status const configStatus = aiConfigService.getStatus(); const circuitBreakerStatus = aiRetryService.getStatus(); // Update status details this.status.details = { provider: configStatus.provider || 'none', model: configStatus.model || 'none', configuration: configStatus.isConfigured ? 'valid' : 'missing', connectivity: 'testing', authentication: configStatus.isValid ? 'valid' : 'invalid', }; // Determine overall health let isHealthy = true; let statusCode: ServiceStatus['statusCode'] = 'operational'; let message = 'AI services are operating normally'; // Check if mock mode is active if (featureFlagService.isEnabled('ai_mock_mode')) { const _mockStatus = mockAIService.getStatus(); this.updateHealthMetrics(startTime, true); this.status = { isHealthy: true, statusCode: 'operational', message: 'Running in mock mode for demos', lastUpdated: Date.now(), details: { ...this.status.details, provider: 'mock', model: 'claude-sonnet-mock', connectivity: 'connected', configuration: 'valid', authentication: 'valid', }, }; this.notifyListeners(); return; } // Check configuration if (!configStatus.isConfigured) { isHealthy = false; statusCode = 'unknown'; message = 'AI assistant not configured'; this.status.details.connectivity = 'disconnected'; } else { // Check circuit breaker if (!circuitBreakerStatus.isHealthy) { isHealthy = false; statusCode = 'outage'; message = 'AI service temporarily unavailable due to repeated failures'; this.status.details.connectivity = 'disconnected'; } else { // Perform actual connectivity test try { await this.testConnectivity(); this.status.details.connectivity = 'connected'; this.updateRateLimitInfo(); } catch (error) { isHealthy = false; statusCode = 'degraded'; message = `AI service experiencing issues: ${error instanceof Error ? error.message : 'Unknown error'}`; this.status.details.connectivity = 'disconnected'; } } } // Update overall status this.status = { isHealthy, statusCode, message, lastUpdated: Date.now(), details: this.status.details, }; this.updateHealthMetrics(startTime, isHealthy); this.checkForAlerts(); this.notifyListeners(); } catch (error) { devLog.error('Health check failed:', error); this.status = { isHealthy: false, statusCode: 'unknown', message: 'Health check failed', lastUpdated: Date.now(), details: this.status.details, }; this.updateHealthMetrics(startTime, false); this.notifyListeners(); } } private async testConnectivity(): Promise<void> { // This would be replaced with actual API connectivity test return new Promise((resolve, _reject) => { setTimeout( () => { if (Math.random() > 0.1) { // 90% success rate for demo resolve(); } else { reject(new Error('Simulated connectivity test failure')); } }, Math.random() * 1000 + 500, ); }); } private updateHealthMetrics(startTime: number, success: boolean): void { const responseTime = Date.now() - startTime; // Add to history this.healthHistory.push({ timestamp: Date.now(), isHealthy: success, responseTime, }); // Clean old history const cutoff = Date.now() - this.HISTORY_RETENTION; this.healthHistory = this.healthHistory.filter((entry) => entry.timestamp >= cutoff); // Calculate metrics from recent history const recentHistory = this.healthHistory.slice(-20); // Last 20 checks const successCount = recentHistory.filter((entry) => entry.isHealthy).length; const avgResponseTime = recentHistory.reduce((sum, _entry) => sum + entry.responseTime, 0) / recentHistory.length; this.healthMetrics = { responseTime: Math.round(avgResponseTime), successRate: recentHistory.length > 0 ? successCount / recentHistory.length : 0, errorRate: recentHistory.length > 0 ? (recentHistory.length - successCount) / recentHistory.length : 1, availabilityScore: Math.round(this.healthMetrics.successRate * 100), lastCheck: Date.now(), }; } private updateRateLimitInfo(): void { // Mock rate limit info - would come from API headers in real implementation const now = Date.now(); const resetTime = now + 60 * 1000; // Reset in 1 minute this.rateLimitInfo = { requestsRemaining: Math.floor(Math.random() * 100) + 50, resetTime, requestsPerMinute: 60, currentUsage: Math.floor(Math.random() * 10), }; } private checkForAlerts(): void { // Check for conditions that warrant user notifications // Service degradation if (this.healthMetrics.successRate < 0.8 && this.healthMetrics.successRate > 0) { this.notifyFeedback({ type: 'warning', title: 'AI Service Performance Issue', message: `Success rate has dropped to ${Math.round(this.healthMetrics.successRate * 100)}%. Some requests may fail.`, actions: [ { label: 'View Status', action: () => devLog.debug('Navigate to AI status page'), }, ], timestamp: Date.now(), }); } // Rate limit warnings if (this.rateLimitInfo.requestsRemaining < 10) { this.notifyFeedback({ type: 'warning', title: 'Rate Limit Warning', message: `Only ${this.rateLimitInfo.requestsRemaining} AI requests remaining. Limit resets at ${new Date(this.rateLimitInfo.resetTime).toLocaleTimeString()}.`, timestamp: Date.now(), }); } // Circuit breaker notifications const circuitStatus = aiRetryService.getStatus(); if (circuitStatus.state === 'open') { this.notifyFeedback({ type: 'error', _title: 'AI Service Temporarily Disabled', _message: 'Too many failures detected. Service will retry automatically.', _actions: [ { label: 'Enable Mock Mode', _action: () => featureFlagService.enableDemoMode(), primary: true, }, ], persistent: true, timestamp: Date.now(), }); } } private subscribeToConfigChanges(): void { aiConfigService.subscribe((_config) => { // Force health check when configuration changes setTimeout(() => this.performHealthCheck(), 1000); }); } private subscribeToFeatureFlags(): void { featureFlagService.subscribe((flags) => { // Check if mock mode or other AI flags changed if (flags.ai_mock_mode !== undefined) { setTimeout(() => this.performHealthCheck(), 500); } }); } private getInitialStatus(): ServiceStatus { return { isHealthy: false, statusCode: 'unknown', message: 'Initializing AI service monitoring...', lastUpdated: Date.now(), details: { provider: 'unknown', model: 'unknown', configuration: 'missing', connectivity: 'testing', authentication: 'invalid', }, }; } private getInitialMetrics(): APIHealthMetrics { return { responseTime: 0, successRate: 0, errorRate: 0, availabilityScore: 0, lastCheck: 0, }; } private getInitialRateLimit(): RateLimitInfo { return { requestsRemaining: 0, resetTime: 0, requestsPerMinute: 0, currentUsage: 0, }; } private notifyListeners(): void { this.listeners.forEach((callback) => { try { callback(this.status); } catch (error) { devLog.error('Status listener error:', error); } }); // Track status changes analyticsService.track('ai_status_changed', { statusCode: this.status.statusCode, isHealthy: this.status.isHealthy, provider: this.status.details.provider, }); } private notifyFeedback(feedback: UserFeedback): void { this.feedbackListeners.forEach((callback) => { try { callback(feedback); } catch (error) { devLog.error('Feedback listener error:', error); } }); // Track feedback notifications analyticsService.track('ai_feedback_notification', { type: feedback.type, title: feedback.title, persistent: feedback.persistent || false, }); } } export const aiStatusMonitor = new AIStatusMonitor(); export default aiStatusMonitor;
