// src/services/timelinePlotConsistencyAnalyzer.ts // Advanced timeline and plot consistency analysis import claudeService from './claudeService'; import type { EnhancedProject } from '../types/project'; export interface TimelineEvent { id: string; type: 'action' | 'dialogue' | 'state_change' | 'revelation' | 'conflict' | 'resolution'; description: string; relativeTime: string; // "Day 1", "3 hours later", "the next morning" absoluteTime?: Date; chapterId: string; chapterTitle: string; sceneId?: string; characters: string[]; location?: string; confidence: number; // 0-1 } export interface ChronologicalError { id: string; type: | 'impossible_timing' | 'character_teleportation' | 'age_inconsistency' | 'season_mismatch' | 'duration_error'; severity: 'low' | 'medium' | 'high' | 'critical'; title: string; description: string; conflictingEvents: TimelineEvent[]; location: { chapterId: string; chapterTitle: string; }; suggestion: string; evidence: string[]; } export interface PlotHole { id: string; type: | 'unresolved_thread' | 'logical_inconsistency' | 'missing_motivation' | 'cause_effect_break' | 'character_knowledge'; severity: 'low' | 'medium' | 'high' | 'critical'; title: string; description: string; relatedElements: { characters?: string[]; plotThreads?: string[]; chapters?: string[]; }; firstMentioned: { chapterId: string; chapterTitle: string; }; lastMentioned?: { chapterId: string; chapterTitle: string; }; suggestion: string; impact: 'story_breaking' | 'confusing' | 'minor_inconsistency'; } export interface SceneSequenceProblem { id: string; type: 'abrupt_transition' | 'missing_bridge' | 'pacing_issue' | 'context_loss' | 'mood_whiplash'; severity: 'low' | 'medium' | 'high' | 'critical'; title: string; description: string; fromChapter: { id: string; title: string; }; toChapter: { id: string; title: string; }; suggestion: string; analysisDetails: string; } export interface TimelinePlotReport { projectId: string; projectName: string; generatedAt: number; timeline: TimelineEvent[]; chronologicalErrors: ChronologicalError[]; plotHoles: PlotHole[]; sequenceProblems: SceneSequenceProblem[]; overallConsistencyScore: number; // 0-100 plotThreads: { id: string; name: string; status: 'resolved' | 'unresolved' | 'abandoned'; firstChapter: string; lastChapter: string; resolution?: string; }[]; recommendations: string[]; analysisMetadata: { totalEvents: number; timeSpanAnalyzed: string; charactersTracked: number; plotThreadsTracked: number; }; } class TimelinePlotConsistencyAnalyzer { private readonly STORAGE_KEY = 'timeline_plot_analysis'; /** * Perform comprehensive timeline and plot consistency analysis */ async analyzeTimelinePlotConsistency( project: EnhancedProject, options: { deepAnalysis?: boolean; includeMinorIssues?: boolean; focusChapters?: string[]; } = {}, ): Promise<TimelinePlotReport> { const { deepAnalysis = false, includeMinorIssues: _includeMinorIssues = false, focusChapters = [], } = options; devLog.debug('Starting timeline and plot consistency analysis...'); // Extract timeline events from the story const timeline = await this.extractTimelineEvents(project, focusChapters); // Analyze for chronological errors const chronologicalErrors = await this.analyzeChronologicalConsistency( project, timeline, deepAnalysis, ); // Detect plot holes const plotHoles = await this.detectPlotHoles(project, deepAnalysis); // Analyze scene sequence problems const sequenceProblems = await this.analyzeSceneSequencing(project, deepAnalysis); // Track plot threads const plotThreads = await this.trackPlotThreads(project); // Calculate overall score const overallConsistencyScore = this.calculateOverallScore( chronologicalErrors, plotHoles, sequenceProblems, ); // Generate recommendations const recommendations = this.generateRecommendations( chronologicalErrors, plotHoles, sequenceProblems, plotThreads, ); const report: TimelinePlotReport = { projectId: project.id, projectName: project.name, generatedAt: Date.now(), timeline, chronologicalErrors, plotHoles, sequenceProblems, overallConsistencyScore, plotThreads, recommendations, analysisMetadata: { totalEvents: timeline.length, timeSpanAnalyzed: this.calculateTimeSpan(timeline), charactersTracked: new Set(timeline.flatMap((e) => e.characters)).size, plotThreadsTracked: plotThreads.length, }, }; // Cache the report this.saveReport(report); return report; } /** * Extract timeline events from story content */ private async extractTimelineEvents( project: EnhancedProject, focusChapters: string[], ): Promise<TimelineEvent[]> { if (!claudeService.isConfigured()) { devLog.warn('Claude not configured, using basic timeline extraction'); return this.basicTimelineExtraction(project, focusChapters); } try { const chaptersToAnalyze = focusChapters.length > 0 ? project.chapters.filter((c) => focusChapters.includes(c.id)) : project.chapters; const events: TimelineEvent[] = []; for (const chapter of chaptersToAnalyze) { const chapterEvents = await this.extractChapterEvents(project, chapter); events.push(...chapterEvents); } return events.sort((a, _b) => a.chapterId.localeCompare(b.chapterId)); } catch (error) { devLog.error('Timeline extraction failed:', error); return this.basicTimelineExtraction(project, focusChapters); } } /** * Extract events from a single chapter */ private async extractChapterEvents( project: EnhancedProject, chapter: import('../types/project').Chapter, ): Promise<TimelineEvent[]> { const prompt = this.buildEventExtractionPrompt(project, chapter); const response = await claudeService.sendMessage(prompt, { maxTokens: 2000, // Low temperature for consistency }); return this.parseTimelineEvents(response, chapter); } /** * Build event extraction prompt for Claude */ private buildEventExtractionPrompt( project: EnhancedProject, chapter: import('../types/project').Chapter, ): string { const characters = project.characters.map((c) => c.name).join(', '); return `Extract key timeline events from this chapter. Focus on events that advance the plot, develop characters, or establish important story elements. PROJECT: ${project.name} CHAPTER: ${chapter.title} MAIN CHARACTERS: ${characters} CHAPTER CONTENT: ${chapter.content.replace(/<[^>]*>/g, '').slice(0, 3000)}... Extract events and respond with a JSON array using this EXACT structure: [ { "type": "action|dialogue|state_change|revelation|conflict|resolution", "description": "Brief description of the event", "relativeTime": "Time reference from the text (e.g., 'morning', 'later that day', '3 hours after')", "characters": ["Character names involved"], "location": "Location if mentioned", "confidence": 0.85 } ] Guidelines: - Focus on plot-advancing events, not every minor action - Include character revelations, conflicts, and resolutions - Note time references carefully ("later", "the next day", "meanwhile") - Track character movements and locations - Confidence should reflect how clearly the event is described Your entire response must be valid JSON only.`; } /** * Parse timeline events from Claude response */ private parseTimelineEvents( response: any, chapter: import('../types/project').Chapter, ): TimelineEvent[] { try { const responseText = typeof response === 'string' ? response : response.content || response.text || ''; let cleanResponse = responseText.trim(); if (cleanResponse.startsWith('```json')) { cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?$/g, ''); } const parsed = JSON.parse(cleanResponse); if (!Array.isArray(parsed)) { devLog.warn('Invalid response format for timeline events'); return []; } return parsed.map((item, _index) => ({ id: `event-${chapter.id}-${Date.now()}-${index}`, type: item.type || 'action', description: item.description || 'Event description unavailable', relativeTime: item.relativeTime || 'Unknown time', chapterId: chapter.id, chapterTitle: chapter.title, characters: Array.isArray(item.characters) ? item.characters : [], location: item.location || undefined, confidence: Math.min(1, Math.max(0, item.confidence || 0.5)), })); } catch (error) { devLog.error('Failed to parse timeline events:', error); return []; } } /** * Basic timeline extraction (fallback when Claude isn't available) */ private basicTimelineExtraction( project: EnhancedProject, focusChapters: string[], ): TimelineEvent[] { const chaptersToAnalyze = focusChapters.length > 0 ? project.chapters.filter((c) => focusChapters.includes(c.id)) : project.chapters; const events: TimelineEvent[] = []; const timeMarkers = [ /\b(morning|afternoon|evening|night|dawn|dusk)\b/gi, /\b(later|meanwhile|then|next|after)\b/gi, /\b(yesterday|today|tomorrow)\b/gi, /\b(\d+) (hour|minute|day|week|month)s? (later|ago|after|before)\b/gi, ]; chaptersToAnalyze.forEach((chapter,  _chapterIndex) => { const text = chapter.content.replace(/<[^>]*>/g, ''); const sentences = text.split(/[.!?]+/).filter((s) => s.trim().length > 20); sentences.forEach((sentence, _sentenceIndex) => { // Look for time markers const hasTimeMarker = timeMarkers.some((pattern) => pattern.test(sentence)); if (hasTimeMarker || sentenceIndex % 10 === 0) { // Sample every 10th sentence or time markers events.push({ id: `basic-event-${chapter.id}-${sentenceIndex}`, type: this.inferEventType(sentence), description: sentence.trim().slice(0, 200), relativeTime: this.extractTimeReference(sentence), chapterId: chapter.id, chapterTitle: chapter.title, characters: this.findCharactersInText(_sentence,  project.characters.map((c) => c.name), ), location: this.extractLocation(sentence), confidence: hasTimeMarker ? 0.7 : 0.3, }); } }); }); return events; } /** * Analyze chronological consistency */ private async analyzeChronologicalConsistency( project: EnhancedProject, timeline: TimelineEvent[], deepAnalysis: boolean, ): Promise<ChronologicalError[]> { if (!claudeService.isConfigured()) { return this.basicChronologicalAnalysis(timeline); } try { const timelineText = timeline .map( (event) => `${event.chapterTitle}: ${event.description} (Time: ${event.relativeTime}, Characters: ${event.characters.join(', ')})`, ) .join('\n'); const prompt = this.buildChronologicalAnalysisPrompt(project, timelineText, deepAnalysis); const response = await claudeService.sendMessage(prompt, { maxTokens: deepAnalysis ? 3000 : 2000, // Low temperature for consistency }); return this.parseChronologicalErrors(response); } catch (error) { devLog.error('Chronological analysis failed:', error); return this.basicChronologicalAnalysis(timeline); } } /** * Build chronological analysis prompt */ private buildChronologicalAnalysisPrompt( project: EnhancedProject, timelineText: string, deepAnalysis: boolean, ): string { return `Analyze this story timeline for chronological inconsistencies and timing errors. PROJECT: ${project.name} CHARACTERS: ${project.characters.map((c) => c.name).join(', ')} TIMELINE EVENTS: ${timelineText} ${ deepAnalysis ? ` PERFORM DEEP ANALYSIS for: - Character travel time inconsistencies - Impossible timing of events - Age/growth contradictions - Seasonal/weather inconsistencies - Sleep/rest pattern violations - Technology/communication delays ` : ` FOCUS ON MAJOR ISSUES: - Clear impossibilities in timing - Character teleportation problems - Major duration errors ` } Look for: - Events happening too close together for characters to travel - Time references that conflict with each other - Characters aging inconsistently - Impossible durations for activities - Contradictory time-of-day references Respond with a JSON array using this structure: [ { "type": "impossible_timing|character_teleportation|age_inconsistency|season_mismatch|duration_error", "severity": "low|medium|high|critical", "title": "Brief title of the error", "description": "Detailed description of the chronological problem", "suggestion": "How to fix this timing issue", "evidence": ["Specific text evidence of the problem"] } ] Your entire response must be valid JSON only.`; } /** * Parse chronological errors from response */ private parseChronologicalErrors(response: any): ChronologicalError[] { try { const responseText = typeof response === 'string' ? response : response.content || response.text || ''; let cleanResponse = responseText.trim(); if (cleanResponse.startsWith('```json')) { cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?$/g, ''); } const parsed = JSON.parse(cleanResponse); if (!Array.isArray(parsed)) { return []; } return parsed.map((item, _index) => ({ id: `chrono-error-${Date.now()}-${index}`, type: item.type || 'impossible_timing', severity: item.severity || 'medium', title: item.title || 'Chronological inconsistency', description: item.description || 'Timeline inconsistency detected', conflictingEvents: [], // Would need to match with actual events location: { chapterId: '', chapterTitle: 'Multiple chapters', }, suggestion: item.suggestion || 'Review timeline for consistency', evidence: Array.isArray(item.evidence) ? item.evidence : [], })); } catch (error) { devLog.error('Failed to parse chronological errors:', error); return []; } } /** * Detect plot holes using AI analysis */ private async detectPlotHoles( project: EnhancedProject, deepAnalysis: boolean, ): Promise<PlotHole[]> { if (!claudeService.isConfigured()) { return []; } try { const storyContent = this.buildStoryOverview(project); const prompt = this.buildPlotHoleAnalysisPrompt(project, storyContent, deepAnalysis); const response = await claudeService.sendMessage(prompt, { maxTokens: deepAnalysis ? 3500 : 2500, // Low temperature for consistency }); return this.parsePlotHoles(response, project); } catch (error) { devLog.error('Plot hole analysis failed:', error); return []; } } /** * Build plot hole analysis prompt */ private buildPlotHoleAnalysisPrompt( project: EnhancedProject, storyContent: string, deepAnalysis: boolean, ): string { return `Analyze this story for plot holes and logical inconsistencies. PROJECT: ${project.name} DESCRIPTION: ${project.description} STORY OVERVIEW: ${storyContent} ${ deepAnalysis ? ` PERFORM COMPREHENSIVE ANALYSIS for: - Unresolved plot threads and subplots - Character motivation gaps - Missing cause-effect connections - Knowledge/information inconsistencies - World-building contradictions - Foreshadowing that goes nowhere ` : ` FOCUS ON MAJOR PLOT HOLES: - Clear logical inconsistencies - Major unresolved plot threads - Obvious character knowledge problems ` } Look for: - Plot threads introduced but never resolved - Characters knowing things they shouldn't - Missing motivations for character actions - Cause-effect relationships that don't make sense - Contradictions in established rules/facts Respond with a JSON array using this structure: [ { "type": "unresolved_thread|logical_inconsistency|missing_motivation|cause_effect_break|character_knowledge", "severity": "low|medium|high|critical", "title": "Brief title of the plot hole", "description": "Detailed description of the logical problem", "relatedElements": { "characters": ["Character names involved"], "plotThreads": ["Plot thread names"], "chapters": ["Chapter titles where this appears"] }, "suggestion": "How to fix this plot hole", "impact": "story_breaking|confusing|minor_inconsistency" } ] Your entire response must be valid JSON only.`; } /** * Parse plot holes from response */ private parsePlotHoles(response: any, project: EnhancedProject): PlotHole[] { try { const responseText = typeof response === 'string' ? response : response.content || response.text || ''; let cleanResponse = responseText.trim(); if (cleanResponse.startsWith('```json')) { cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?$/g, ''); } const parsed = JSON.parse(cleanResponse); if (!Array.isArray(parsed)) { return []; } return parsed.map((item, _index) => ({ id: `plot-hole-${Date.now()}-${index}`, type: item.type || 'logical_inconsistency', severity: item.severity || 'medium', title: item.title || 'Plot inconsistency', description: item.description || 'Logical inconsistency detected', relatedElements: { characters: item.relatedElements?.characters || [], plotThreads: item.relatedElements?.plotThreads || [], chapters: item.relatedElements?.chapters || [], }, firstMentioned: { chapterId: project.chapters[0]?.id || '', chapterTitle: project.chapters[0]?.title || 'Unknown', }, suggestion: item.suggestion || 'Review plot logic', impact: item.impact || 'confusing', })); } catch (error) { devLog.error('Failed to parse plot holes:', error); return []; } } /** * Analyze scene sequencing problems */ private async analyzeSceneSequencing( project: EnhancedProject, deepAnalysis: boolean, ): Promise<SceneSequenceProblem[]> { if (!claudeService.isConfigured() || project.chapters.length < 2) { return []; } try { const sequenceProblems: SceneSequenceProblem[] = []; // Analyze transitions between consecutive chapters for (let i = 0; i < project.chapters.length - 1; i++) { const currentChapter = project.chapters[i]; const nextChapter = project.chapters[i + 1]; if (currentChapter && nextChapter) { const transition = await this.analyzeChapterTransition( currentChapter, nextChapter, deepAnalysis, ); if (transition) { sequenceProblems.push(transition); } } } return sequenceProblems; } catch (error) { devLog.error('Scene sequence analysis failed:', error); return []; } } /** * Analyze transition between two chapters */ private async analyzeChapterTransition( fromChapter: import('../types/project').Chapter, toChapter: import('../types/project').Chapter, deepAnalysis: boolean, ): Promise<SceneSequenceProblem | null> { const prompt = this.buildTransitionAnalysisPrompt(fromChapter, toChapter, deepAnalysis); const response = await claudeService.sendMessage(prompt, { maxTokens: 1500, // Low temperature for consistency }); return this.parseTransitionProblem(response, fromChapter, toChapter); } /** * Build transition analysis prompt */ private buildTransitionAnalysisPrompt( fromChapter: import('../types/project').Chapter, toChapter: import('../types/project').Chapter, deepAnalysis: boolean, ): string { const fromEnd = fromChapter.content.replace(/<[^>]*>/g, '').slice(-500); const toStart = toChapter.content.replace(/<[^>]*>/g, '').slice(0, 500); return `Analyze the transition between these two chapters for pacing and continuity issues. CHAPTER ${fromChapter.title} (ending): ${fromEnd} CHAPTER ${toChapter.title} (beginning): ${toStart} ${ deepAnalysis ? ` ANALYZE FOR: - Abrupt mood/tone changes - Missing context or setup - Pacing inconsistencies - Character continuity breaks - Location/time jumps without explanation - Emotional whiplash ` : ` FOCUS ON MAJOR ISSUES: - Jarring transitions - Missing critical context - Confusing jumps in time/place ` } If you find transition problems, respond with JSON using this structure: { "type": "abrupt_transition|missing_bridge|pacing_issue|context_loss|mood_whiplash", "severity": "low|medium|high|critical", "title": "Brief description of the problem", "description": "Detailed explanation of the transition issue", "suggestion": "How to improve this transition", "analysisDetails": "Specific analysis of what makes this transition problematic" } If the transition is fine, respond with: {"no_problem": true} Your entire response must be valid JSON only.`; } /** * Parse transition problem from response */ private parseTransitionProblem( response: any, fromChapter: import('../types/project').Chapter, toChapter: import('../types/project').Chapter, ): SceneSequenceProblem | null { try { const responseText = typeof response === 'string' ? response : response.content || response.text || ''; let cleanResponse = responseText.trim(); if (cleanResponse.startsWith('```json')) { cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?$/g, ''); } const parsed = JSON.parse(cleanResponse); if (parsed.no_problem) { return null; } return { id: `sequence-${fromChapter.id}-${toChapter.id}-${Date.now()}`, type: parsed.type || 'abrupt_transition', severity: parsed.severity || 'medium', title: parsed.title || 'Scene transition issue', description: parsed.description || 'Transition problem detected', fromChapter: { id: fromChapter.id, title: fromChapter.title, }, toChapter: { id: toChapter.id, title: toChapter.title, }, suggestion: parsed.suggestion || 'Smooth the transition between scenes', analysisDetails: parsed.analysisDetails || 'Transition needs improvement', }; } catch (error) { devLog.error('Failed to parse transition problem:', error); return null; } } /** * Track plot threads throughout the story */ private async trackPlotThreads( project: EnhancedProject, ): Promise<TimelinePlotReport['plotThreads']> { if (!claudeService.isConfigured()) { return []; } try { const storyOverview = this.buildStoryOverview(project); const prompt = this.buildPlotThreadTrackingPrompt(project, storyOverview); const response = await claudeService.sendMessage(prompt, { maxTokens: 2500, // Low temperature for consistency }); return this.parsePlotThreads(response, project); } catch (error) { devLog.error('Plot thread tracking failed:', error); return []; } } /** * Build plot thread tracking prompt */ private buildPlotThreadTrackingPrompt(project: EnhancedProject, storyOverview: string): string { return `Identify and track the main plot threads throughout this story. PROJECT: ${project.name} STORY OVERVIEW: ${storyOverview} Identify major plot threads including: - Main plot (central story arc) - Subplots (secondary storylines) - Character arcs (individual character development) - Romantic threads - Mystery/conflict threads - World-building elements that develop over time For each plot thread, determine if it's properly resolved by the end. Respond with a JSON array using this structure: [ { "name": "Name/description of the plot thread", "status": "resolved|unresolved|abandoned", "firstChapter": "Chapter where this thread begins", "lastChapter": "Chapter where this thread was last mentioned", "resolution": "How it was resolved (if applicable)" } ] Your entire response must be valid JSON only.`; } /** * Parse plot threads from response */ private parsePlotThreads( response: any, project: EnhancedProject, ): TimelinePlotReport['plotThreads'] { try { const responseText = typeof response === 'string' ? response : response.content || response.text || ''; let cleanResponse = responseText.trim(); if (cleanResponse.startsWith('```json')) { cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?$/g, ''); } const parsed = JSON.parse(cleanResponse); if (!Array.isArray(parsed)) { return []; } return parsed.map((item, _index) => ({ id: `plot-thread-${Date.now()}-${index}`, name: item.name || `Plot Thread ${index + 1}`, status: item.status || 'unresolved', firstChapter: item.firstChapter || project.chapters[0]?.title || 'Unknown', lastChapter: item.lastChapter || project.chapters[project.chapters.length - 1]?.title || 'Unknown', resolution: item.resolution, })); } catch (error) { devLog.error('Failed to parse plot threads:', error); return []; } } /** * Helper methods for basic analysis */ private basicChronologicalAnalysis(timeline: TimelineEvent[]): ChronologicalError[] { const errors: ChronologicalError[] = []; // Simple analysis - look for characters mentioned in multiple places too close together const characterLastSeen = new Map<string, TimelineEvent>(); for (const event of timeline) { for (const character of event.characters) { const lastSeen = characterLastSeen.get(character); if (lastSeen && lastSeen.chapterId !== event.chapterId) { // Check if this could be a teleportation issue if ( lastSeen.location && event.location && lastSeen.location !== event.location && this.isImmediateTransition(lastSeen.relativeTime, event.relativeTime) ) { errors.push({ id: `basic-chrono-${character}-${Date.now()}`, type: 'character_teleportation', severity: 'medium', title: `Possible teleportation: ${character}`, description: `${character} appears in ${lastSeen.location} then immediately in ${event.location}`, conflictingEvents: [lastSeen, event], location: { chapterId: event.chapterId, chapterTitle: event.chapterTitle, }, suggestion: 'Add transition time or explanation for character movement', evidence: [lastSeen.description, event.description], }); } } characterLastSeen.set(character, event); } } return errors; } private isImmediateTransition(time1: string, time2: string): boolean { const immediateWords = ['immediately', 'then', 'next', 'suddenly', 'meanwhile']; return immediateWords.some((word) => time2.toLowerCase().includes(word)); } private inferEventType(sentence: string): TimelineEvent['type'] { if (sentence.includes('"')) return 'dialogue'; if ( sentence.includes('discover') || sentence.includes('realize') || sentence.includes('reveal') ) return 'revelation'; if (sentence.includes('fight') || sentence.includes('argue') || sentence.includes('attack')) return 'conflict'; if (sentence.includes('resolve') || sentence.includes('solve') || sentence.includes('end')) return 'resolution'; return 'action'; } private extractTimeReference(sentence: string): string { const timePatterns = [ /\b(morning|afternoon|evening|night|dawn|dusk)\b/gi, /\b(later|meanwhile|then|next|after|before)\b/gi, /\b(\d+) (hour|minute|day|week|month)s? (later|ago|after|before)\b/gi, /\b(yesterday|today|tomorrow)\b/gi, ]; for (const pattern of timePatterns) { const match = sentence.match(pattern); if (match) return match[0]; } return 'unspecified time'; } private findCharactersInText(text: string, characterNames: string[]): string[] { const found = []; const lowerText = text.toLowerCase(); for (const name of characterNames) { if (lowerText.includes(name.toLowerCase())) { found.push(name); } } return found; } private extractLocation(sentence: string): string | undefined { const locationPatterns = [ /\bat the ([\w\s]+)\b/gi, /\bin the ([\w\s]+)\b/gi, /\btoward the ([\w\s]+)\b/gi, ]; for (const pattern of locationPatterns) { const match = sentence.match(pattern); if (match) return match[1]; } return undefined; } private buildStoryOverview(project: EnhancedProject): string { return project.chapters .map((chapter, _index) => { const content = chapter.content.replace(/<[^>]*>/g, ''); const summary = content.slice(0, 300) + (content.length > 300 ? '...' : ''); return `CHAPTER ${index + 1}: ${chapter.title}\n${summary}`; }) .join('\n\n'); } private calculateTimeSpan(timeline: TimelineEvent[]): string { if (timeline.length === 0) return 'No events analyzed'; const timeReferences = timeline .map((e) => e.relativeTime) .filter((t) => t !== 'unspecified time'); if (timeReferences.length === 0) return 'Timespan unclear'; // Simple analysis - could be enhanced const hasDay = timeReferences.some((t) => t.toLowerCase().includes('day')); const hasWeek = timeReferences.some((t) => t.toLowerCase().includes('week')); const hasMonth = timeReferences.some((t) => t.toLowerCase().includes('month')); if (hasMonth) return 'Several months'; if (hasWeek) return 'Several weeks'; if (hasDay) return 'Several days'; return 'Within a day'; } private calculateOverallScore( chronologicalErrors: ChronologicalError[], plotHoles: PlotHole[], sequenceProblems: SceneSequenceProblem[], ): number { let score = 100; // Deduct for chronological errors chronologicalErrors.forEach((error) => { switch (error.severity) { case 'critical': score -= 20; break; case 'high': score -= 15; break; case 'medium': score -= 8; break; case 'low': score -= 3; break; } }); // Deduct for plot holes plotHoles.forEach((hole) => { switch (hole.severity) { case 'critical': score -= 25; break; case 'high': score -= 18; break; case 'medium': score -= 10; break; case 'low': score -= 5; break; } }); // Deduct for sequence problems sequenceProblems.forEach((problem) => { switch (problem.severity) { case 'critical': score -= 15; break; case 'high': score -= 10; break; case 'medium': score -= 6; break; case 'low': score -= 2; break; } }); return Math.max(0, Math.min(100, score)); } private generateRecommendations( chronologicalErrors: ChronologicalError[], plotHoles: PlotHole[], sequenceProblems: SceneSequenceProblem[], plotThreads: TimelinePlotReport['plotThreads'], ): string[] { const recommendations = []; if (chronologicalErrors.length > 0) { recommendations.push('Review timeline for chronological consistency'); if (chronologicalErrors.some((e) => e.type === 'character_teleportation')) { recommendations.push('Add transition time for character movements'); } } if (plotHoles.length > 0) { recommendations.push('Address logical inconsistencies in plot development'); if (plotHoles.some((h) => h.type === 'unresolved_thread')) { recommendations.push('Resolve or properly close unfinished plot threads'); } } if (sequenceProblems.length > 0) { recommendations.push('Smooth chapter transitions for better flow'); } const unresolvedThreads = plotThreads.filter((t) => t.status === 'unresolved'); if (unresolvedThreads.length > 0) { recommendations.push( `Consider resolving ${unresolvedThreads.length} unfinished plot thread(s)`, ); } if (recommendations.length === 0) { recommendations.push('Excellent timeline and plot consistency!'); } return recommendations; } /** * Storage and retrieval methods */ private saveReport(report: TimelinePlotReport): void { try { const reports = this.getStoredReports(); reports[report.projectId] = report; localStorage.setItem(this.STORAGE_KEY, JSON.stringify(reports)); } catch (error) { devLog.error('Failed to save timeline plot report:', error); } } private getStoredReports(): Record<string, TimelinePlotReport> { try { const stored = localStorage.getItem(this.STORAGE_KEY); return stored ? JSON.parse(stored) : {}; } catch (error) { devLog.error('Failed to load stored reports:', error); return {}; } } getReport(projectId: string): TimelinePlotReport | null { const reports = this.getStoredReports(); return reports[projectId] || null; } clearReport(projectId: string): void { try { const reports = this.getStoredReports(); delete reports[projectId]; localStorage.setItem(this.STORAGE_KEY, JSON.stringify(reports)); } catch (error) { devLog.error('Failed to clear timeline plot report:', error); } } } export const timelinePlotConsistencyAnalyzer = new TimelinePlotConsistencyAnalyzer();
