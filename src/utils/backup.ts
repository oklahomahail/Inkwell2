// Backup utilities for project snapshots with integrity checks // Handles project export/import, validation, and recovery operations import { CURRENT_SCHEMA_VERSION, createVersionedData } from '../domain/schemaVersion'; import { Project, ProjectBundle, ProjectManifest, ExportOptions, ExportFormat, } from '../domain/types'; import { storage } from './storage'; /* ========= Types ========= */ export interface BackupError extends Error { code: 'INTEGRITY_FAILED' | 'INVALID_FORMAT' | 'CORRUPTED_DATA' | 'VERSION_MISMATCH'; recoverable?: boolean; suggestedAction?: string; } export interface BackupValidationResult { isValid: boolean; errors: string[]; warnings: string[]; canRecover: boolean; suggestedRepairs?: string[]; } /* ========= Crypto Utilities ========= */ async function _calculateChecksum(data: string): Promise<string> { if (typeof window !== 'undefined' && window.crypto && window.crypto.subtle) { const encoder = new TextEncoder(); const dataBuffer = encoder.encode(data); const hashBuffer = await window.crypto.subtle.digest('SHA-256', dataBuffer); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map((b) => b.toString(16).padStart(2, '0')).join(''); } // Fallback for environments without crypto.subtle let hash = 0; for (let i = 0; i < data.length; i++) { const char = data.charCodeAt(i); hash = (hash << 5) - hash + char; hash = hash & hash; // Convert to 32bit integer } return Math.abs(hash).toString(16); } /* ========= Core Backup Functions ========= */ /** * Create a complete project backup bundle */ export async function _createProjectBackup( projectId: string, options: ExportOptions = { format: ExportFormat.MARKDOWN, includeMetadata: true, includeTimeline: true, includeCharacters: true, }, ): Promise<ProjectBundle> { try { // Load all project data from storage const chapters = (await storage.get(`project:${projectId}:chapters`)) || []; const characters = (await storage.get(`project:${projectId}:characters`)) || []; const timelineEvents = (await storage.get(`project:${projectId}:timeline`)) || []; const writingSessions = (await storage.get(`project:${projectId}:sessions`)) || []; const projectMeta = (await storage.get(`project:${projectId}:meta`)) || {}; const settings = (await storage.get(`project:${projectId}:settings`)) || {}; // Ensure projectMeta is an object const meta = (projectMeta as Partial<Project>) ?? {}; const projectSettings = (settings as Partial<Project['settings']>) ?? {}; // Construct the project object const project: Project = createVersionedData({ id: projectId, name: String(meta.name ?? 'Untitled Project'), description: String(meta.description ?? ''), chapters: Array.isArray(chapters) ? chapters : [], characters: options.includeCharacters ? (Array.isArray(characters) ? characters : []) : [], timelineEvents: options.includeTimeline ? Array.isArray(timelineEvents) ? timelineEvents : [] : [], writingSessions: Array.isArray(writingSessions) ? writingSessions : [], metadata: { totalWordCount: Number( meta.metadata?.totalWordCount ?? (Array.isArray(chapters) ? chapters.reduce( (total: number, _chapter: any) => total + (chapter?.totalWordCount ?? 0), 0, ) : 0), ), targetWordCount: Number(meta.metadata?.targetWordCount ?? 0), genre: String(meta.metadata?.genre ?? ''), tags: Array.isArray(meta.metadata?.tags) ? meta.metadata.tags : [], }, settings: { autoSaveEnabled: Boolean(projectSettings.autoSaveEnabled ?? true), autoSaveInterval: Number(projectSettings.autoSaveInterval ?? 30000), backupEnabled: Boolean(projectSettings.backupEnabled ?? true), theme: (projectSettings.theme ?? 'dark') as 'light' | 'dark', }, createdAt: new Date(meta.createdAt ?? Date.now()), updatedAt: new Date(), }); // Calculate integrity checksum const projectJson = JSON.stringify(project); const checksum = await calculateChecksum(projectJson); // Create manifest const manifest: ProjectManifest = { version: 1, schemaVersion: CURRENT_SCHEMA_VERSION, projectId, name: project.name, exportedAt: new Date(), itemCounts: { chapters: project.chapters.length, scenes: project.chapters.reduce((total, _ch) => total + ch.scenes.length, 0), characters: project.characters.length, timelineEvents: project.timelineEvents.length, writingSessions: project.writingSessions.length, }, integrity: { checksum, algorithm: 'sha256', }, }; console.log( `ðŸ“¦ Created backup for project "${project.name}" with ${manifest.itemCounts.scenes} scenes`, ); return { manifest, project, }; } catch (error: unknown) { const message = error instanceof Error ? error.message : String(error); const backupError: BackupError = new Error( `Failed to create project backup: ${message}`, ) as BackupError; backupError.code = 'CORRUPTED_DATA'; backupError.recoverable = false; throw backupError; } } /** * Validate a project bundle before import */ export async function _validateProjectBundle( bundle: ProjectBundle, ): Promise<BackupValidationResult> { const errors: string[] = []; const warnings: string[] = []; let canRecover = true; try { // Check manifest structure if (!bundle.manifest) { errors.push('Missing manifest in backup bundle'); canRecover = false; } if (!bundle.project) { errors.push('Missing project data in backup bundle'); canRecover = false; } if (errors.length > 0) { return { isValid: false, errors, warnings, canRecover: false }; } const { manifest, project } = bundle; // Validate schema version if (manifest.schemaVersion > CURRENT_SCHEMA_VERSION) { errors.push( `Bundle created with newer schema version ${manifest.schemaVersion}, current version is ${CURRENT_SCHEMA_VERSION}`, ); canRecover = false; } else if (manifest.schemaVersion < CURRENT_SCHEMA_VERSION) { warnings.push( `Bundle uses older schema version ${manifest.schemaVersion}, will be migrated to ${CURRENT_SCHEMA_VERSION}`, ); } // Validate data integrity const projectJson = JSON.stringify(project); const calculatedChecksum = await calculateChecksum(projectJson); if (calculatedChecksum !== manifest.integrity.checksum) { errors.push('Data integrity check failed - backup may be corrupted'); warnings.push('Some data recovery may still be possible'); } // Validate item counts const actualCounts = { chapters: project.chapters?.length || 0, scenes: project.chapters?.reduce((total, _ch) => total + (ch.scenes?.length || 0), 0) || 0, characters: project.characters?.length || 0, timelineEvents: project.timelineEvents?.length || 0, writingSessions: project.writingSessions?.length || 0, }; for (const [key, expectedCount] of Object.entries(manifest.itemCounts)) { const actualCount = actualCounts[key as keyof typeof actualCounts]; if (actualCount !== expectedCount) { warnings.push(`${key} count mismatch: expected ${expectedCount}, found ${actualCount}`); } } // Check required fields if (!project.id) { errors.push('Project missing required ID field'); canRecover = false; } if (!project.name) { warnings.push('Project missing name - will use default'); } // Validate chapters structure if (project.chapters) { project.chapters.forEach((chapter, _index) => { if (!chapter.id) { errors.push(`Chapter ${index + 1} missing ID`); } if (!chapter.title) { warnings.push(`Chapter ${index + 1} missing title`); } if (chapter.scenes) { chapter.scenes.forEach((scene, _sceneIndex) => { if (!scene.id) { errors.push(`Scene ${sceneIndex + 1} in chapter ${index + 1} missing ID`); } }); } }); } } catch (error: unknown) { const message = error instanceof Error ? error.message : String(error); errors.push(`Validation failed with error: ${message}`); canRecover = false; } const suggestedRepairs = []; if (warnings.some((w) => w.includes('count mismatch'))) { suggestedRepairs.push('Rebuild item counts from actual data'); } if (warnings.some((w) => w.includes('missing title'))) { suggestedRepairs.push('Generate default titles for unnamed items'); } return { isValid: errors.length === 0, errors, warnings, canRecover, suggestedRepairs: suggestedRepairs.length > 0 ? suggestedRepairs : undefined, }; } /** * Restore a project from a backup bundle */ export async function _restoreProjectBackup( bundle: ProjectBundle, options: { overwrite?: boolean; repairData?: boolean; newProjectId?: string; } = {}, ): Promise<string> { // Validate bundle first const validation = await validateProjectBundle(bundle); if (!validation.isValid && !validation.canRecover) { const error: BackupError = new Error( `Cannot restore backup: ${validation.errors.join(', ')}`, ) as BackupError; error.code = 'INVALID_FORMAT'; error.recoverable = false; error.suggestedAction = 'Try a different backup file or contact support'; throw error; } if (validation.warnings.length > 0) { console.warn('âš ï¸ Backup has warnings:', validation.warnings); } try { const { project } = bundle; const projectId = options.newProjectId || project.id; // Check if project already exists if (!options.overwrite) { const existing = await storage.get(`project:${projectId}:meta`); if (existing) { const error: BackupError = new Error( `Project ${projectId} already exists. Use overwrite option to replace.`, ) as BackupError; error.code = 'INVALID_FORMAT'; error.recoverable = true; error.suggestedAction = 'Choose a different project ID or enable overwrite'; throw error; } } // Repair data if requested let repairedProject = project; if (options.repairData && validation.suggestedRepairs) { repairedProject = await repairProjectData(project); } // Store the project data await storage.transact([ () => storage.put(`project:${projectId}:chapters`, repairedProject.chapters), () => storage.put(`project:${projectId}:characters`, repairedProject.characters), () => storage.put(`project:${projectId}:timeline`, repairedProject.timelineEvents), () => storage.put(`project:${projectId}:sessions`, repairedProject.writingSessions), () => storage.put(`project:${projectId}:meta`, { name: repairedProject.name, description: repairedProject.description, createdAt: repairedProject.createdAt, updatedAt: new Date(), ...repairedProject.metadata, }), () => storage.put(`project:${projectId}:settings`, repairedProject.settings), ]); console.log(`âœ… Restored project "${repairedProject.name}" with ID: ${projectId}`); return projectId; } catch (error: unknown) { if (error && typeof error === 'object' && 'code' in error) { throw error; // Re-throw BackupError } const message = error instanceof Error ? error.message : String(error); const backupError: BackupError = new Error( `Failed to restore project: ${message}`, ) as BackupError; backupError.code = 'CORRUPTED_DATA'; backupError.recoverable = true; backupError.suggestedAction = 'Try enabling data repair option'; throw backupError; } } /** * Repair common data issues in a project */ async function _repairProjectData(project: Project): Promise<Project> { const repaired = { ...project }; // Generate missing IDs if (repaired.chapters) { repaired.chapters = repaired.chapters.map((chapter, _index) => ({ ...chapter, id: chapter.id || `chapter-${Date.now()}-${index}`, title: chapter.title || `Chapter ${index + 1}`, scenes: chapter.scenes?.map((scene, _sceneIndex) => ({ ...scene, id: scene.id || `scene-${Date.now()}-${index}-${sceneIndex}`, title: scene.title || `Scene ${sceneIndex + 1}`, })) || [], })); } // Recalculate word counts if (repaired.chapters) { repaired.chapters = repaired.chapters.map((chapter) => ({ ...chapter, _totalWordCount: chapter.scenes?.reduce((total, _scene) => total + (scene.wordCount || 0), 0) || 0, })); } // Update metadata repaired.metadata = { ...repaired.metadata, totalWordCount: repaired.chapters?.reduce((total, _chapter) => total + (chapter.totalWordCount || 0), 0) || 0, }; console.log('ðŸ”§ Applied data repairs to project'); return repaired; } /** * Export project bundle as downloadable file */ export async function _exportProjectBundle( bundle: ProjectBundle, _filename?: string, ): Promise<Blob> { const bundleJson = JSON.stringify(bundle, null, 2); const blob = new Blob([bundleJson], { type: 'application/json' }); return blob; } /** * Import project bundle from file */ export async function _importProjectBundle(file: File | Blob): Promise<ProjectBundle> { try { const text = await file.text(); const bundle = JSON.parse(text) as ProjectBundle; // Basic structure validation if (!bundle.manifest || !bundle.project) { throw new Error('Invalid bundle format'); } return bundle; } catch (error: unknown) { const message = error instanceof Error ? error.message : String(error); const backupError: BackupError = new Error( `Failed to import bundle: ${message}`, ) as BackupError; backupError.code = 'INVALID_FORMAT'; backupError.recoverable = false; backupError.suggestedAction = 'Ensure the file is a valid .inkwell backup'; throw backupError; } }
