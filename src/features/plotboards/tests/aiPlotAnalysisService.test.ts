
// Mock the dependencies vi.mock('../../../services/aiConfigService', () => ({ aiConfigService: { getConfiguration: vi.fn(() => ({ isValid: false, provider: 'mock' })), }, })); vi.mock('../../../services/mockAIService', () => ({ mockAnalyzeBoard: vi.fn((input) => Promise.resolve({ summary: 'Mock analysis summary', qualityScore: 75, issues: [ { id: 'issue-1', type: 'continuity_gap', severity: 'medium', title: 'Test issue', description: 'Test description', sceneIds: ['scene-1'], suggestions: ['Test suggestion'], }, ], pacing: [{ sceneId: 'scene-1', index: 0, tension: 0.5, pace: 0.7 }], conflictHeatmap: [{ row: 0, col: 0, value: 0.6 }], }), ), })); vi.mock('../../../utils/id', () => ({ generateId: vi.fn((prefix) => `${prefix}_test_id`), })); describe('aiPlotAnalysisService', () => { it('returns structured output in mock mode', async () => { const input: AnalyzeBoardInput = { profileId: 'p1', projectId: 'proj1', scenes: [ { id: 's1', title: 'Opening', text: 'Once upon a time...', order: 0 }, { id: 's2', title: 'Inciting Incident', text: 'The call to adventure', order: 1 }, ], }; const result = await analyzeBoard(input); // Verify the structure matches our PlotAnalysis interface expect(result).toHaveProperty('id'); expect(result).toHaveProperty('profileId', 'p1'); expect(result).toHaveProperty('projectId', 'proj1'); expect(result).toHaveProperty('model', 'mock'); expect(result).toHaveProperty('updatedAt'); expect(result).toHaveProperty('summary'); expect(result).toHaveProperty('qualityScore'); expect(result).toHaveProperty('issues'); expect(result).toHaveProperty('pacing'); expect(result).toHaveProperty('conflictHeatmap'); // Verify issues structure expect(Array.isArray(result.issues)).toBe(true); expect(result.issues.length).toBeGreaterThan(0); // Verify first issue structure const firstIssue = result.issues[0]; expect(firstIssue).toHaveProperty('id'); expect(firstIssue).toHaveProperty('type'); expect(firstIssue).toHaveProperty('severity'); expect(firstIssue).toHaveProperty('title'); expect(firstIssue).toHaveProperty('description'); expect(firstIssue).toHaveProperty('sceneIds'); expect(firstIssue).toHaveProperty('suggestions'); // Verify pacing structure expect(Array.isArray(result.pacing)).toBe(true); expect(result.pacing.length).toBeGreaterThan(0); const firstPacing = result.pacing[0]!; expect(firstPacing).toHaveProperty('sceneId'); expect(firstPacing).toHaveProperty('index'); expect(firstPacing).toHaveProperty('tension'); expect(firstPacing).toHaveProperty('pace'); expect(typeof firstPacing.tension).toBe('number'); expect(typeof firstPacing.pace).toBe('number'); // Verify conflict heatmap structure expect(Array.isArray(result.conflictHeatmap)).toBe(true); expect(result.conflictHeatmap.length).toBeGreaterThan(0); const firstCell = result.conflictHeatmap[0]!; expect(firstCell).toHaveProperty('row'); expect(firstCell).toHaveProperty('col'); expect(firstCell).toHaveProperty('value'); expect(typeof firstCell.value).toBe('number'); // Verify quality score is in valid range expect(result.qualityScore).toBeGreaterThanOrEqual(0); expect(result.qualityScore).toBeLessThanOrEqual(100); }); it('handles empty scenes input', async () => { const input: AnalyzeBoardInput = { profileId: 'p1', projectId: 'proj1', scenes: [], }; const result = await analyzeBoard(input); // Should still return a valid analysis structure even with no scenes expect(result).toHaveProperty('id'); expect(result).toHaveProperty('profileId', 'p1'); expect(result).toHaveProperty('projectId', 'proj1'); expect(result).toHaveProperty('model', 'mock'); expect(Array.isArray(result.issues)).toBe(true); expect(Array.isArray(result.pacing)).toBe(true); expect(Array.isArray(result.conflictHeatmap)).toBe(true); }); it('generates unique IDs for analysis', async () => { const input: AnalyzeBoardInput = { profileId: 'p1', projectId: 'proj1', scenes: [{ id: 's1', title: 'Scene 1', text: 'Some text', order: 0 }], }; const result1 = await analyzeBoard(input); const result2 = await analyzeBoard(input); // IDs should be unique (though in our mock they'll be the same pattern) expect(result1.id).toBeTruthy(); expect(result2.id).toBeTruthy(); }); it('preserves input metadata in output', async () => { const input: AnalyzeBoardInput = { profileId: 'test-profile', projectId: 'test-project', scenes: [{ id: 's1', title: 'Test Scene', text: 'Test content', order: 0 }], structure: 'heros_journey', }; const result = await analyzeBoard(input); expect(result.profileId).toBe('test-profile'); expect(result.projectId).toBe('test-project'); expect(result.updatedAt).toBeGreaterThan(0); }); }); 