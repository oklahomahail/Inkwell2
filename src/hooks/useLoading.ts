// src/hooks/useLoading.ts import { useState, useCallback, useRef, useEffect } from 'react'; export interface LoadingState { isLoading: boolean; error: string | null; data: any; } export interface UseLoadingReturn<T = any> { isLoading: boolean; error: string | null; data: T | null; execute: (_fn: () => Promise<T>) => Promise<T | null>; reset: () => void; setLoading: (_loading: boolean) => void; setError: (_error: string | null) => void; setData: (_data: T | null) => void; } // ========================================== // MAIN LOADING HOOK // ========================================== export function useLoading<T = any>(initialData: T | null = null): UseLoadingReturn<T> { const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState<string | null>(null); const [data, setData] = useState<T | null>(initialData); // Track if component is mounted to prevent state updates after unmount const isMountedRef = useRef(true); const execute = useCallback(async (fn: () => Promise<T>): Promise<T | null> => { if (!isMountedRef.current) return null; setIsLoading(true); setError(null); try { const result = await fn(); if (isMountedRef.current) { setData(result); setIsLoading(false); return result; } return null; } catch (err) { if (isMountedRef.current) { const errorMessage = err instanceof Error ? err.message : 'An unexpected error occurred'; setError(errorMessage); setIsLoading(false); } return null; } }, []); const reset = useCallback(() => { if (isMountedRef.current) { setIsLoading(false); setError(null); setData(initialData); } }, [initialData]); const setLoadingState = useCallback((loading: boolean) => { if (isMountedRef.current) { setIsLoading(loading); } }, []); const setErrorState = useCallback((error: string | null) => { if (isMountedRef.current) { setError(error); } }, []); const setDataState = useCallback((data: T | null) => { if (isMountedRef.current) { setData(data); } }, []); // Cleanup on unmount useEffect(() => { return () => { isMountedRef.current = false; }; }, []); return { isLoading, error, data, execute, reset, setLoading: setLoadingState, setError: setErrorState, setData: setDataState, }; } // ========================================== // SPECIALIZED LOADING HOOKS // ========================================== // For async operations with automatic error handling export function useAsyncOperation<T = any>() { const { isLoading, error, execute, reset } = useLoading<T>(); const runAsync = useCallback( async ( operation: () => Promise<T>, options?: { onSuccess?: (_data: T) => void; onError?: (_error: string) => void; successMessage?: string; }, ): Promise<T | null> => { const result = await execute(operation); if (result && options?.onSuccess) { options.onSuccess(result); } if (error && options?.onError) { options.onError(error); } return result; }, [execute, error], ); return { isLoading, error, runAsync, reset, }; } // For save operations export function _useSaveOperation() { const [lastSaved, setLastSaved] = useState<Date | null>(null); const { isLoading: isSaving, error, execute } = useLoading(); const save = useCallback( async (saveFunction: () => Promise<any>) => { const result = await execute(saveFunction); if (result) { setLastSaved(new Date()); } return result; }, [execute], ); return { isSaving, error, lastSaved, save, reset: () => { setLastSaved(null); }, }; } // For export operations export function _useExportOperation() { const { isLoading: isExporting, error, execute } = useLoading(); const [progress, setProgress] = useState(0); const exportWithProgress = useCallback( async (exportFunction: (onProgress?: (progress: number) => void) => Promise<any>) => { setProgress(0); const result = await execute(() => exportFunction((p) => setProgress(p))); if (result) { setProgress(100); // Reset progress after a delay setTimeout(() => setProgress(0), 2000); } return result; }, [execute], ); return { isExporting, error, progress, exportWithProgress, }; } // For Claude AI operations export function _useClaudeOperation() { const { isLoading: isProcessing, error, execute, reset } = useLoading(); const [tokenCount, setTokenCount] = useState(0); const processWithClaude = useCallback( async (claudeFunction: () => Promise<any>) => { const result = await execute(claudeFunction); // Mock token counting - replace with actual implementation if (result) { setTokenCount((prev) => prev + Math.floor(Math.random() * 1000) + 500); } return result; }, [execute], ); return { isProcessing, error, tokenCount, processWithClaude, reset: () => { reset(); setTokenCount(0); }, }; } // ========================================== // BATCH OPERATIONS // ========================================== interface BatchItem<T> { id: string; operation: () => Promise<T>; } export function useBatchOperation<T = any>() { const [batchState, setBatchState] = useState<{ isRunning: boolean; completed: number; total: number; currentItem: string | null; errors: Array<{ id: string; error: string }>; results: Array<{ id: string; result: T }>; }>({ isRunning: false, completed: 0, total: 0, currentItem: null, errors: [], results: [], }); const runBatch = useCallback(async (items: BatchItem<T>[]) => { setBatchState({ isRunning: true, completed: 0, total: items.length, currentItem: null, errors: [], results: [], }); const results: Array<{ id: string; result: T }> = []; const errors: Array<{ id: string; error: string }> = []; for (let i = 0; i < items.length; i++) { const item = items[i]; if (!item) { console.warn(`Batch operation: item at index ${i} is undefined`); continue; } setBatchState((prev) => ({ ...prev, currentItem: item.id, })); try { const result = await item.operation(); results.push({ id: item.id, result }); } catch (err) { const errorMessage = err instanceof Error ? err.message : 'Unknown error'; errors.push({ id: item.id, error: errorMessage }); } setBatchState((prev) => ({ ...prev, completed: i + 1, })); } setBatchState((prev) => ({ ...prev, isRunning: false, currentItem: null, results, errors, })); return { results, errors }; }, []); return { ...batchState, runBatch, }; } // ========================================== // UTILITY FUNCTIONS // ========================================== // Debounced loading state for auto-save scenarios export function _useDebouncedLoading(delay = 300) { const [isLoading, setIsLoading] = useState(false); const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null); const setDebouncedLoading = useCallback( (loading: boolean) => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } if (loading) { setIsLoading(true); } else { timeoutRef.current = setTimeout(() => { setIsLoading(false); }, delay); } }, [delay], ); useEffect(() => { return () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } }; }, []); return [isLoading, setDebouncedLoading] as const; } // Multiple loading states manager export function useMultipleLoading<K extends string>(keys: K[]) { const [loadingStates, setLoadingStates] = useState<Record<K, boolean>>( keys.reduce((acc, _key) => ({ ...acc, [key]: false }), {} as Record<K, boolean>), ); const setLoading = useCallback((key: K, _loading: boolean) => { setLoadingStates((prev) => ({ ...prev, [key]: loading })); }, []); const isAnyLoading = Object.values(loadingStates).some(Boolean); return { loadingStates, setLoading, isAnyLoading, }; }
