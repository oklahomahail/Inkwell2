// src/hooks/useDeferred.ts import { useState, useEffect, useCallback, useRef } from 'react'; /** * Hook that defers expensive operations until after a timeout * @param operation The expensive operation to defer * @param delay The delay before executing the operation * @returns Object with execute function, loading state, and result */ export function useDeferred<T>(operation: () => Promise<T> | T, delay = 0) { const [result, setResult] = useState<T | null>(null); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState<Error | null>(null); const timeoutRef = useRef<NodeJS.Timeout | null>(null); const abortControllerRef = useRef<AbortController | null>(null); const execute = useCallback(async () => { // Clear any existing timeout if (timeoutRef.current) { clearTimeout(timeoutRef.current); } // Abort any ongoing operation if (abortControllerRef.current) { abortControllerRef.current.abort(); } setIsLoading(true); setError(null); abortControllerRef.current = new AbortController(); const executeOperation = async () => { try { const operationResult = await operation(); if (!abortControllerRef.current?.signal.aborted) { setResult(operationResult); } } catch (err) { if (!abortControllerRef.current?.signal.aborted) { setError(err as Error); } } finally { if (!abortControllerRef.current?.signal.aborted) { setIsLoading(false); } } }; if (delay > 0) { timeoutRef.current = setTimeout(executeOperation, delay); } else { await executeOperation(); } }, [operation, delay]); useEffect(() => { return () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } if (abortControllerRef.current) { abortControllerRef.current.abort(); } }; }, []); return { execute, result, isLoading, error, }; } /** * Hook that manages expensive list operations with pagination and deferred loading */ export function useDeferredList<T>(items: T[], batchSize = 50, delay = 100) { const [visibleItems, setVisibleItems] = useState<T[]>([]); const [isLoadingMore, setIsLoadingMore] = useState(false); const timeoutRef = useRef<NodeJS.Timeout | null>(null); const currentBatchRef = useRef(0); const loadNextBatch = useCallback(() => { if (isLoadingMore) return; const currentBatch = currentBatchRef.current; const startIndex = currentBatch * batchSize; const endIndex = Math.min(startIndex + batchSize, items.length); if (startIndex >= items.length) return; setIsLoadingMore(true); if (timeoutRef.current) { clearTimeout(timeoutRef.current); } timeoutRef.current = setTimeout(() => { setVisibleItems((prev) => [...prev, ...items.slice(startIndex, endIndex)]); currentBatchRef.current += 1; setIsLoadingMore(false); }, delay); }, [items, batchSize, delay, isLoadingMore]); const reset = useCallback(() => { setVisibleItems([]); currentBatchRef.current = 0; setIsLoadingMore(false); if (timeoutRef.current) { clearTimeout(timeoutRef.current); } }, []); // Reset when items change useEffect(() => { reset(); loadNextBatch(); // Load first batch }, [items, reset, loadNextBatch]); useEffect(() => { return () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } }; }, []); const hasMore = visibleItems.length < items.length; return { visibleItems, isLoadingMore, hasMore, loadNextBatch, reset, }; } 