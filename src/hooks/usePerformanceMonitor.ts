// src/hooks/usePerformanceMonitor.ts import { useCallback, useRef } from 'react'; interface PerformanceMetrics { renderTime: number; scrollLatency: number; memoryUsage?: number; listSize: number; timestamp: number; } interface PerformanceMonitorOptions { enabled?: boolean; sampleRate?: number; // 0-1, how often to collect metrics logToConsole?: boolean; onMetric?: (metric: PerformanceMetrics) => void; } /** * Hook for monitoring rendering and scroll performance */ export function usePerformanceMonitor(listSize: number, options: PerformanceMonitorOptions = {}) { const { enabled = true, sampleRate = 0.1, // Sample 10% of renders logToConsole = false, onMetric, } = options; const renderStartRef = useRef<number>(0); const scrollStartRef = useRef<number>(0); const metricsRef = useRef<PerformanceMetrics[]>([]); // Start measuring render time const startRenderMeasure = useCallback(() => { if (!enabled || Math.random() > sampleRate) return; renderStartRef.current = performance.now(); }, [enabled, sampleRate]); // End measuring render time const endRenderMeasure = useCallback(() => { if (!enabled || !renderStartRef.current) return; const renderTime = performance.now() - renderStartRef.current; renderStartRef.current = 0; const metric: PerformanceMetrics = { renderTime, scrollLatency: 0, // Will be updated during scroll events listSize, timestamp: Date.now(), memoryUsage: (performance as any).memory?.usedJSHeapSize || undefined, }; metricsRef.current.push(metric); // Keep only last 100 metrics to prevent memory leaks if (metricsRef.current.length > 100) { metricsRef.current = metricsRef.current.slice(-100); } if (logToConsole) { console.log(`[Performance] Render: ${renderTime.toFixed(2)}ms, List size: ${listSize}`); } onMetric?.(metric); }, [enabled, listSize, logToConsole, onMetric]); // Measure scroll performance const measureScroll = useCallback( (element: HTMLElement | null) => { if (!enabled || !element) return; let scrollTimeoutRef: NodeJS.Timeout; const handleScrollStart = () => { scrollStartRef.current = performance.now(); }; const handleScrollEnd = () => { if (!scrollStartRef.current) return; const scrollLatency = performance.now() - scrollStartRef.current; scrollStartRef.current = 0; if (logToConsole && scrollLatency > 16) { // Log if >16ms (60fps threshold) console.log(`[Performance] Scroll latency: ${scrollLatency.toFixed(2)}ms`); } }; const handleScroll = () => { if (!scrollStartRef.current) { handleScrollStart(); } clearTimeout(scrollTimeoutRef); scrollTimeoutRef = setTimeout(handleScrollEnd, 100); }; element.addEventListener('scroll', handleScroll, { passive: true }); return () => { element.removeEventListener('scroll', handleScroll); clearTimeout(scrollTimeoutRef); }; }, [enabled, logToConsole], ); // Get performance summary const getPerformanceSummary = useCallback(() => { const metrics = metricsRef.current; if (metrics.length === 0) return null; const renderTimes = metrics.map((m) => m.renderTime); const avgRenderTime = renderTimes.reduce((sum, time) => sum + time, 0) / renderTimes.length; const maxRenderTime = Math.max(...renderTimes); const minRenderTime = Math.min(...renderTimes); const recentMetrics = metrics.slice(-10); const recentAvgRender = recentMetrics.reduce((sum, m) => sum + m.renderTime, 0) / recentMetrics.length; return { totalSamples: metrics.length, avgRenderTime: Math.round(avgRenderTime * 100) / 100, maxRenderTime: Math.round(maxRenderTime * 100) / 100, minRenderTime: Math.round(minRenderTime * 100) / 100, recentAvgRender: Math.round(recentAvgRender * 100) / 100, isPerformanceGood: recentAvgRender < 16, // 60fps threshold currentListSize: listSize, }; }, [listSize]); // Clear metrics const clearMetrics = useCallback(() => { metricsRef.current = []; }, []); return { startRenderMeasure, endRenderMeasure, measureScroll, getPerformanceSummary, clearMetrics, isEnabled: enabled, }; } /** * Hook specifically for monitoring virtualized list performance */ export function useVirtualListPerformance( totalItems: number, visibleItems: number, options?: PerformanceMonitorOptions, ) { const monitor = usePerformanceMonitor(totalItems, options); const measureVirtualScroll = useCallback( ( parentElement: HTMLElement | null, onScrollMetric?: (metric: { fps: number; scrollLatency: number }) => void, ) => { if (!parentElement) return; let frameCount = 0; let fpsStartTime = performance.now(); let rafId: number; const measureFPS = () => { frameCount++; const elapsed = performance.now() - fpsStartTime; if (elapsed >= 1000) { const fps = Math.round((frameCount * 1000) / elapsed); if (options?.logToConsole && fps < 55) { console.log(`[Performance] Virtual scroll FPS: ${fps}`); } onScrollMetric?.({ fps, scrollLatency: 0 }); frameCount = 0; fpsStartTime = performance.now(); } rafId = requestAnimationFrame(measureFPS); }; const handleScroll = () => { if (!rafId) { rafId = requestAnimationFrame(measureFPS); } }; parentElement.addEventListener('scroll', handleScroll, { passive: true }); return () => { parentElement.removeEventListener('scroll', handleScroll); if (rafId) { cancelAnimationFrame(rafId); } }; }, [options], ); const getVirtualListSummary = useCallback(() => { const baseSummary = monitor.getPerformanceSummary(); return { ...baseSummary, totalItems, visibleItems, virtualizationRatio: Math.round((visibleItems / totalItems) * 100), isVirtualizationEffective: visibleItems < totalItems * 0.5, }; }, [monitor, totalItems, visibleItems]); return { ...monitor, measureVirtualScroll, getVirtualListSummary, }; } 