// src/test/baselineTest.ts // Quick test to establish current search performance baseline import { generateSyntheticCorpus } from './syntheticCorpusGenerator'; import { describe, it, expect } from 'vitest'; import { searchService } from '@/services/searchService'; import { storageService } from '@/services/storageService'; interface BaselineResult { corpusStats: { totalWords: number; totalScenes: number; totalChapters: number; }; indexingPerformance: { timeMs: number; sizeBytes: number; }; queryPerformance: { singleWordP50: number; singleWordP95: number; multiWordP50: number; multiWordP95: number; overallP50: number; overallP95: number; }; issues: string[]; } describe('baseline harness', () => { it('is wired', () => { expect(true).toBe(true); }); }); /** * Quick baseline test - run this first to see where your current implementation stands */ export async function establishBaseline(): Promise<BaselineResult> { console.log('Establishing search performance baseline...'); const issues: string[] = []; // Step 1: Generate a smaller corpus for quick testing console.log('Generating test corpus (smaller for baseline)...'); const corpus = generateSyntheticCorpus({ targetWordCount: 50000, // Smaller for quick test chapterCount: 20, sceneCount: 300, characterCount: 10, seed: 12345, }); console.log( `Generated corpus: ${corpus.stats.totalWords} words, ${corpus.stats.totalScenes} scenes`, ); // Step 2: Mock the storage service to return our synthetic data // We need to temporarily override the storage methods for testing const originalLoadProject = storageService.loadProject; const originalLoadWritingChapters = storageService.loadWritingChapters; try { // Mock storage methods with proper typing (storageService as any).loadProject = () => corpus.project; (storageService as any).loadWritingChapters = async (_projectId: string) => corpus.chapters; // Step 3: Initialize search index and measure performance console.log('Building search index...'); const indexStart = performance.now(); await searchService.initializeProject('test-baseline'); const indexEnd = performance.now(); const indexTime = indexEnd - indexStart; // Get index stats const stats = searchService.getStats('test-baseline'); const indexSize = stats?.indexSize || 0; console.log( `Index built in ${indexTime.toFixed(1)}ms, size: ${(indexSize / 1024).toFixed(1)}KB`, ); if (indexTime > 5000) { issues.push( `Index build time (${indexTime.toFixed(0)}ms) is slow for ${corpus.stats.totalScenes} scenes`, ); } // Step 4: Test query performance with representative queries const testQueries = { singleWord: [ 'Henry', 'mystery', 'school', 'locker', 'hallway', 'teacher', 'student', 'class', 'friend', 'discover', ], multiWord: [ 'art hallway', 'science class', 'lunch table', 'old locker', 'middle school', 'after school', 'time capsule', 'strange column', 'figure out', 'work together', ], }; // Test single-word queries console.log('Testing single-word queries...'); const singleWordLatencies: number[] = []; for (const query of testQueries.singleWord) { const start = performance.now(); try { const results = await searchService.search(query, { projectId: 'test-baseline' }); const end = performance.now(); singleWordLatencies.push(end - start); if (results.length === 0 && query === 'Henry') { issues.push('Character name "Henry" returned no results - indexing may be broken'); } } catch (error) { issues.push(`Single-word query "${query}" failed: ${error}`); singleWordLatencies.push(1000); // Penalty for failures } } // Test multi-word queries console.log('Testing multi-word queries...'); const multiWordLatencies: number[] = []; for (const query of testQueries.multiWord) { const start = performance.now(); try { await searchService.search(query, { projectId: 'test-baseline' }); const end = performance.now(); multiWordLatencies.push(end - start); } catch (error) { issues.push(`Multi-word query "${query}" failed: ${error}`); multiWordLatencies.push(1000); // Penalty for failures } } // Calculate percentiles const allLatencies = [...singleWordLatencies, ...multiWordLatencies]; allLatencies.sort((a, b) => a - b); singleWordLatencies.sort((a, b) => a - b); multiWordLatencies.sort((a, b) => a - b); const p50 = (arr: number[]) => arr[Math.floor(arr.length * 0.5)] || 0; const p95 = (arr: number[]) => arr[Math.floor(arr.length * 0.95)] || 0; const overallP50 = p50(allLatencies); const overallP95 = p95(allLatencies); const singleP50 = p50(singleWordLatencies); const singleP95 = p95(singleWordLatencies); const multiP50 = p50(multiWordLatencies); const multiP95 = p95(multiWordLatencies); // Performance analysis if (overallP50 > 50) { issues.push(`P50 latency (${overallP50.toFixed(1)}ms) exceeds target of 50ms`); } if (overallP95 > 120) { issues.push(`P95 latency (${overallP95.toFixed(1)}ms) exceeds target of 120ms`); } if (singleP50 > multiP50 * 2) { issues.push('Single-word queries are unexpectedly slower than multi-word queries'); } if (indexSize > 10 * 1024 * 1024) { // 10MB for 50k words seems excessive issues.push( `Index size (${(indexSize / 1024 / 1024).toFixed(1)}MB) may be too large for corpus size`, ); } const result: BaselineResult = { corpusStats: corpus.stats, indexingPerformance: { timeMs: indexTime, sizeBytes: indexSize, }, queryPerformance: { singleWordP50: singleP50, singleWordP95: singleP95, multiWordP50: multiP50, multiWordP95: multiP95, overallP50, overallP95, }, issues, }; // Report results console.log('\n=== BASELINE RESULTS ==='); console.log( `Corpus: ${corpus.stats.totalWords.toLocaleString()} words, ${corpus.stats.totalScenes} scenes`, ); console.log(`Indexing: ${indexTime.toFixed(1)}ms, ${(indexSize / 1024).toFixed(1)}KB`); console.log(`Query Performance:`); console.log( ` Overall P50: ${overallP50.toFixed(1)}ms (target: ≤50ms) ${overallP50 <= 50 ? '✅' : '❌'}`, ); console.log( ` Overall P95: ${overallP95.toFixed(1)}ms (target: ≤120ms) ${overallP95 <= 120 ? '✅' : '❌'}`, ); console.log(` Single-word P50: ${singleP50.toFixed(1)}ms`); console.log(` Multi-word P50: ${multiP50.toFixed(1)}ms`); if (issues.length > 0) { console.log('\nIssues detected:'); issues.forEach((issue, i) => console.log(` ${i + 1}. ${issue}`)); } else { console.log('\n✅ No issues detected - performance looks good!'); } // Get current search service performance metrics const perfMetrics = searchService.getPerformanceMetrics(); if (perfMetrics.queries > 0) { console.log(`\nSearch Service Metrics:`); console.log(` Total queries: ${perfMetrics.queries}`); console.log(` Service P50: ${perfMetrics.p50.toFixed(1)}ms`); console.log(` Service P95: ${perfMetrics.p95.toFixed(1)}ms`); } return result; } finally { // Restore original storage methods storageService.loadProject = originalLoadProject; storageService.loadWritingChapters = originalLoadWritingChapters; } } /** * Quick test you can run in browser console or during development */ export async function quickPerformanceCheck(): Promise<void> { try { const baseline = await establishBaseline(); // Simple pass/fail assessment const passed = baseline.queryPerformance.overallP50 <= 50 && baseline.queryPerformance.overallP95 <= 120 && baseline.indexingPerformance.timeMs <= 5000 && baseline.issues.length === 0; console.log(`\n🎯 QUICK ASSESSMENT: ${passed ? 'READY FOR P0' : 'NEEDS OPTIMIZATION'}`); if (!passed) { console.log('\nRecommendations:'); if (baseline.queryPerformance.overallP50 > 50) { console.log(' • Focus on query optimization - tokenization/BM25 bottlenecks likely'); } if (baseline.indexingPerformance.timeMs > 2000) { console.log(' • Consider web worker for indexing to avoid blocking main thread'); } if (baseline.issues.some((i) => i.includes('failed'))) { console.log(' • Fix search errors before performance optimization'); } if (baseline.indexingPerformance.sizeBytes > 5 * 1024 * 1024) { console.log(' • Index size optimization needed - term filtering or compression'); } } } catch (error) { console.error('Baseline test failed:', error); console.log( '\nThis likely indicates fundamental issues with the search system that need fixing first.', ); } } // For use in development console if (typeof window !== 'undefined') { (window as any).testSearchPerformance = quickPerformanceCheck; console.log('💡 Run `testSearchPerformance()` in console to check search performance'); } 