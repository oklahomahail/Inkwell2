import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, act, waitFor } from '@testing-library/react';
import React from 'react';

import { PWAInstallButton } from '../PWAInstallButton';
import { pwaService, usePWA } from '../../../services/pwaService';

// Define mock values and functions outside the mock for easy manipulation in tests
const mockInstallApp = vi.fn().mockResolvedValue(true);
let mockCanInstall = false; // Start with false to test appearing behavior
const mockListeners: (() => void)[] = [];

// Function to manipulate the mock canInstall state
const setCanInstall = (value: boolean) => {
  mockCanInstall = value;
};

// Function to trigger install prompt event
const simulateInstallPrompt = () => {
  mockCanInstall = true;
  mockListeners.forEach((listener) => listener());
};

// Mock the pwaService and usePWA hook
vi.mock('../../../services/pwaService', () => {
  return {
    pwaService: {
      onInstallPromptReady: vi.fn((callback) => {
        mockListeners.push(callback);
        return () => {
          const index = mockListeners.indexOf(callback);
          if (index !== -1) {
            mockListeners.splice(index, 1);
          }
        };
      }),
      // Function to trigger install prompt for testing
      simulateInstallPrompt: () => simulateInstallPrompt(),
    },
    usePWA: () => ({
      installApp: mockInstallApp,
      canInstall: mockCanInstall,
      updateApp: vi.fn(),
      isOffline: false,
      isOfflineReady: false,
      needsRefresh: false,
    }),
  };
});

describe('PWAInstallButton', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockCanInstall = false; // Reset for each test
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('Rendering variants', () => {
    it('renders nothing when prompt is not available', () => {
      const { container } = render(<PWAInstallButton />);
      
      // The component should render nothing initially
      expect(container).toBeEmptyDOMElement();
    });

    it('renders button variant when install prompt is available', async () => {
      const { container, rerender } = render(<PWAInstallButton />);
      
      // Initially renders nothing
      expect(container).toBeEmptyDOMElement();
      
      // Trigger install prompt
      await act(async () => {
        simulateInstallPrompt();
      });
      
      // Force re-render to reflect state change
      rerender(<PWAInstallButton />);
      
      // Now look for a button that contains "install" text
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(0);
        const installButton = buttons[0];
        expect(installButton).toHaveClass('bg-blue-600');
      });
    });

    it('renders fab variant when install prompt is available', async () => {
      const { container, rerender } = render(<PWAInstallButton variant="fab" />);
      
      // Initially renders nothing
      expect(container).toBeEmptyDOMElement();
      
      // Trigger install prompt
      await act(async () => {
        simulateInstallPrompt();
      });
      
      // Force re-render to reflect state change
      rerender(<PWAInstallButton variant="fab" />);
      
      // Now look for the FAB button
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(0);
        const fabButton = buttons[0];
        expect(fabButton).toHaveClass('rounded-full');
      });
    });

    it('renders banner variant when install prompt is available', async () => {
      const { container, rerender } = render(<PWAInstallButton variant="banner" />);
      
      // Initially renders nothing
      expect(container).toBeEmptyDOMElement();
      
      // Trigger install prompt
      await act(async () => {
        simulateInstallPrompt();
      });
      
      // Force re-render to reflect state change
      rerender(<PWAInstallButton variant="banner" />);
      
      // Now look for the banner elements with less strict matching
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(0);
      });
      expect(screen.getByText('Maybe Later')).toBeInTheDocument();
    });
  });

  describe('Installation process', () => {
    it('calls installApp when button is clicked', async () => {
      // Reset the mock function before test
      mockInstallApp.mockClear().mockResolvedValue(true);
      
      // Set canInstall to true to make the button appear
      setCanInstall(true);
      
      render(<PWAInstallButton />);
      
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(0);
      });
      
      const installButton = screen.getByRole('button', { name: /Install/i });
      expect(installButton).toBeInTheDocument();
      
      // Click the install button
      await act(async () => {
        fireEvent.click(installButton);
      });
      
      // Check that the install function was called
      expect(mockInstallApp).toHaveBeenCalledTimes(1);
    });

    it('shows loading state during installation', async () => {
      // Create a promise that we can resolve manually
      let resolveInstall: (value: boolean) => void;
      const installPromise = new Promise<boolean>((resolve) => {
        resolveInstall = resolve;
      });
      
      // Setup the mock to return our controlled promise
      mockInstallApp.mockClear().mockReturnValue(installPromise);
      setCanInstall(true);
      
      render(<PWAInstallButton />);
      
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(0);
      });
      
      const installButton = screen.getByRole('button', { name: /Install/i });
      
      // Click the install button to start the installation process
      await act(async () => {
        fireEvent.click(installButton);
      });
      
      // Check for disabled button as indicator of loading state
      await waitFor(() => {
        expect(screen.getByRole('button')).toBeDisabled();
      });
      
      // Resolve the install promise
      await act(async () => {
        resolveInstall!(true);
      });
      
      // Should not be disabled anymore after installation completes
      await waitFor(() => {
        // The button might be gone since install completed
        const buttons = screen.queryAllByRole('button');
        // If any buttons are present, they should not be disabled
        if (buttons.length > 0) {
          expect(buttons[0]).not.toBeDisabled();
        }
      });
    });

    it('calls onInstall callback when installation completes', async () => {
      // Setup callback and mock
      const onInstall = vi.fn();
      mockInstallApp.mockClear().mockResolvedValue(true);
      setCanInstall(true);
      
      render(<PWAInstallButton onInstall={onInstall} />);
      
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(0);
      });
      
      const installButton = screen.getByRole('button', { name: /Install/i });
      
      // Click the install button
      await act(async () => {
        fireEvent.click(installButton);
      });
      
      // Check callback was called with success=true
      await waitFor(() => {
        expect(onInstall).toHaveBeenCalledWith(true);
      });
    });
    
    it('calls onDismiss callback when dismissed', async () => {
      // Setup dismiss callback
      const onDismiss = vi.fn();
      setCanInstall(true);
      
      render(<PWAInstallButton variant="banner" onDismiss={onDismiss} />);
      
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(1); // Should have at least 2 buttons in banner mode
      });
      
      // Find the "Maybe Later" button
      const dismissButton = screen.getByText('Maybe Later');
      
      // Click the dismiss button
      await act(async () => {
        fireEvent.click(dismissButton);
      });
      
      // Check dismiss callback was called
      expect(onDismiss).toHaveBeenCalled();
    });
    
    it('handles installation errors', async () => {
      // Setup callback and error mock
      const onInstall = vi.fn();
      const testError = new Error('Installation failed');
      mockInstallApp.mockClear().mockRejectedValue(testError);
      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
      setCanInstall(true);
      
      render(<PWAInstallButton onInstall={onInstall} />);
      
      await waitFor(() => {
        const buttons = screen.getAllByRole('button');
        expect(buttons.length).toBeGreaterThan(0);
      });
      
      const installButton = screen.getByRole('button', { name: /Install/i });
      
      // Click the install button
      await act(async () => {
        fireEvent.click(installButton);
      });
      
      // Check error was logged and callback was called with failure
      await waitFor(() => {
        expect(consoleSpy).toHaveBeenCalledWith('Installation error:', testError);
        expect(onInstall).toHaveBeenCalledWith(false);
      });
      
      consoleSpy.mockRestore();
    });
  });

  describe('Cleanup and event handling', () => {
    it('unsubscribes from install prompt ready on unmount', () => {
      // Setup spy for the unsubscribe function
      const unsubscribeSpy = vi.fn();
      vi.spyOn(pwaService, 'onInstallPromptReady').mockReturnValue(unsubscribeSpy);
      
      const { unmount } = render(<PWAInstallButton />);
      
      // Unmount the component
      unmount();
      
      // Check that the unsubscribe function was called
      expect(unsubscribeSpy).toHaveBeenCalledTimes(1);
    });
  });
});
