// src/components/Planning/RelationshipMapper.tsx - Interactive relationship network visualization import { RotateCcw, ZoomIn, ZoomOut, Filter } from 'lucide-react'; import React, { useState, useMemo, useRef, useEffect } from 'react'; import type { GeneratedCharacter, CharacterRelationship, } from '../../services/storyArchitectService'; interface RelationshipNode { id: string; name: string; role: string; x: number; y: number; connections: number; isDragging: boolean; color: string; } interface RelationshipEdge { id: string; source: string; target: string; type: string; strength: number; color: string; arcInfluence: string; chapter?: number; } interface RelationshipMapperProps { characters: GeneratedCharacter[]; totalChapters?: number; onRelationshipUpdate?: ( sourceChar: string, targetChar: string, relationship: CharacterRelationship, ) => void; className?: string; } export default function RelationshipMapper({ characters = [], totalChapters: _totalChapters = 20, onRelationshipUpdate: _onRelationshipUpdate, className = '', }: RelationshipMapperProps) { const canvasRef = useRef<HTMLCanvasElement>(null); const containerRef = useRef<HTMLDivElement>(null); const [zoom, setZoom] = useState(1); const [panX, setPanX] = useState(0); const [panY, setPanY] = useState(0); const [isDragging, setIsDragging] = useState(false); const [dragStart, setDragStart] = useState({ x: 0, y: 0 }); const [selectedNode, setSelectedNode] = useState<string | null>(null); const [selectedEdge, setSelectedEdge] = useState<string | null>(null); const [relationshipFilter, setRelationshipFilter] = useState<string>('all'); const [showLabels, setShowLabels] = useState(true); const [layoutMode, setLayoutMode] = useState<'force' | 'circular' | 'hierarchical'>('force'); // Generate nodes and edges from character data const { nodes, edges } = useMemo(() => { const nodeMap = new Map<string, RelationshipNode>(); const edgeList: RelationshipEdge[] = []; const canvasWidth = 800; const canvasHeight = 600; // Create nodes characters.forEach((character, index) => { let nodeColor = '#3B82F6'; // blue if (character.role === 'protagonist') nodeColor = '#10B981'; // green else if (character.role === 'antagonist') nodeColor = '#EF4444'; // red else if (character.role === 'supporting') nodeColor = '#F59E0B'; // amber // Position based on layout mode let x, y; if (layoutMode === 'circular') { const angle = (index / characters.length) * Math.PI * 2; const radius = Math.min(canvasWidth, canvasHeight) / 3; x = canvasWidth / 2 + Math.cos(angle) * radius; y = canvasHeight / 2 + Math.sin(angle) * radius; } else if (layoutMode === 'hierarchical') { const levelMap = { protagonist: 0, antagonist: 0, supporting: 1, minor: 2 }; const level = levelMap[character.role as keyof typeof levelMap] || 2; x = (index % 3) * (canvasWidth / 3) + canvasWidth / 6; y = level * (canvasHeight / 4) + canvasHeight / 8; } else { // Force-directed layout (simple random positioning) x = Math.random() * (canvasWidth - 100) + 50; y = Math.random() * (canvasHeight - 100) + 50; } const connectionCount = character.relationships?.length || 0; nodeMap.set(character.name, { id: character.name, name: character.name, role: character.role, x, y, connections: connectionCount, isDragging: false, color: nodeColor, }); }); // Create edges characters.forEach((character) => { character.relationships?.forEach((rel, relIndex) => { if (nodeMap.has(rel.withCharacter)) { let edgeColor = '#6B7280'; // gray if (rel.type === 'ally') edgeColor = '#10B981'; // green else if (rel.type === 'enemy') edgeColor = '#EF4444'; // red else if (rel.type === 'love_interest') edgeColor = '#EC4899'; // pink else if (rel.type === 'mentor') edgeColor = '#8B5CF6'; // purple const strength = rel.arcInfluence === 'major' ? 3 : rel.arcInfluence === 'moderate' ? 2 : 1; edgeList.push({ id: `${character.name}-${rel.withCharacter}-${relIndex}`, source: character.name, target: rel.withCharacter, type: rel.type, strength, color: edgeColor, arcInfluence: rel.arcInfluence, }); } }); }); return { nodes: Array.from(nodeMap.values()), edges: edgeList }; }, [characters, layoutMode]); // Filter edges based on selected filter const filteredEdges = useMemo(() => { if (relationshipFilter === 'all') return edges; return edges.filter((edge) => edge.type === relationshipFilter); }, [edges, relationshipFilter]); // Canvas drawing function const drawCanvas = (ctx: CanvasRenderingContext2D) => { const canvas = ctx.canvas; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.translate(panX, panY); ctx.scale(zoom, zoom); // Draw edges filteredEdges.forEach((edge) => { const sourceNode = nodes.find((n) => n.id === edge.source); const targetNode = nodes.find((n) => n.id === edge.target); if (sourceNode && targetNode) { ctx.beginPath(); ctx.strokeStyle = edge.color; ctx.lineWidth = edge.strength; ctx.globalAlpha = selectedEdge === edge.id ? 1 : 0.7; // Draw curved line for better visualization const midX = (sourceNode.x + targetNode.x) / 2; const midY = (sourceNode.y + targetNode.y) / 2; const offset = 20; ctx.moveTo(sourceNode.x, sourceNode.y); ctx.quadraticCurveTo(midX + offset, midY - offset, targetNode.x, targetNode.y); ctx.stroke(); // Draw arrow const angle = Math.atan2(targetNode.y - midY, targetNode.x - midX); const arrowLength = 10; ctx.beginPath(); ctx.moveTo( targetNode.x - arrowLength * Math.cos(angle - Math.PI / 6), targetNode.y - arrowLength * Math.sin(angle - Math.PI / 6), ); ctx.lineTo(targetNode.x, targetNode.y); ctx.lineTo( targetNode.x - arrowLength * Math.cos(angle + Math.PI / 6), targetNode.y - arrowLength * Math.sin(angle + Math.PI / 6), ); ctx.stroke(); // Draw relationship label if (showLabels) { ctx.fillStyle = edge.color; ctx.font = '10px Arial'; ctx.textAlign = 'center'; ctx.fillText(edge.type.replace('_', ' '), midX, midY - 5); } } }); // Draw nodes nodes.forEach((node) => { ctx.beginPath(); const radius = Math.max(15, node.connections * 3); ctx.arc(node.x, node.y, radius, 0, Math.PI * 2); ctx.fillStyle = node.color; ctx.globalAlpha = selectedNode === node.id ? 1 : 0.8; ctx.fill(); // Node border ctx.strokeStyle = selectedNode === node.id ? '#1F2937' : '#FFFFFF'; ctx.lineWidth = 2; ctx.stroke(); // Node label if (showLabels) { ctx.fillStyle = '#1F2937'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.globalAlpha = 1; ctx.fillText(node.name, node.x, node.y + radius + 15); // Role label ctx.font = '10px Arial'; ctx.fillStyle = '#6B7280'; ctx.fillText(node.role, node.x, node.y + radius + 28); } }); ctx.restore(); }; // Handle canvas interactions const handleCanvasMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => { const canvas = canvasRef.current; if (!canvas) return; const rect = canvas.getBoundingClientRect(); const x = (e.clientX - rect.left - panX) / zoom; const y = (e.clientY - rect.top - panY) / zoom; // Check if clicking on a node const clickedNode = nodes.find((node) => { const radius = Math.max(15, node.connections * 3); const distance = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2); return distance <= radius; }); if (clickedNode) { setSelectedNode(clickedNode.id); setSelectedEdge(null); } else { setSelectedNode(null); setSelectedEdge(null); setIsDragging(true); setDragStart({ x: e.clientX - panX, y: e.clientY - panY }); } }; const handleCanvasMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => { if (isDragging) { setPanX(e.clientX - dragStart.x); setPanY(e.clientY - dragStart.y); } }; const handleCanvasMouseUp = () => { setIsDragging(false); }; const handleZoomIn = () => setZoom((prev) => Math.min(prev * 1.2, 3)); const handleZoomOut = () => setZoom((prev) => Math.max(prev / 1.2, 0.3)); const resetView = () => { setZoom(1); setPanX(0); setPanY(0); setSelectedNode(null); setSelectedEdge(null); }; // Redraw canvas when data changes useEffect(() => { const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); if (!ctx) return; drawCanvas(ctx); }, [nodes, filteredEdges, zoom, panX, panY, selectedNode, selectedEdge, showLabels]); const relationshipTypes = [ { id: 'all', name: 'All Relationships', color: '#6B7280' }, { id: 'ally', name: 'Allies', color: '#10B981' }, { id: 'enemy', name: 'Enemies', color: '#EF4444' }, { id: 'love_interest', name: 'Love Interests', color: '#EC4899' }, { id: 'mentor', name: 'Mentors', color: '#8B5CF6' }, { id: 'family', name: 'Family', color: '#F59E0B' }, ]; const selectedCharacter = selectedNode ? characters.find((char) => char.name === selectedNode) : null; return ( <div className={`bg-white rounded-lg shadow-sm border border-gray-200 ${className}`} > {/* Header */} <div className="p-4 border-b border-gray-200"> <div className="flex items-center justify-between"> <div> <h2 className="text-lg font-semibold text-gray-900"> Relationship Mapper </h2> <p className="text-sm text-gray-600"> Interactive visualization of character relationships and connections </p> </div> <div className="flex items-center gap-2"> <button onClick={handleZoomIn} className="p-2 text-gray-500 hover:text-gray-700" title="Zoom In" > <ZoomIn className="w-4 h-4" /> </button> <button onClick={handleZoomOut} className="p-2 text-gray-500 hover:text-gray-700" title="Zoom Out" > <ZoomOut className="w-4 h-4" /> </button> <button onClick={resetView} className="p-2 text-gray-500 hover:text-gray-700" title="Reset View" > <RotateCcw className="w-4 h-4" /> </button> </div> </div> </div> {/* Controls */} <div className="p-4 border-b border-gray-200 bg-gray-50"> <div className="flex flex-wrap gap-4 items-center"> <div className="flex items-center gap-2"> <Filter className="w-4 h-4 text-gray-500" /> <select value={relationshipFilter} onChange={(e) => setRelationshipFilter(e.target.value)} className="bg-white border border-gray-300 rounded px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" > {relationshipTypes.map((type) => ( <option key={type.id} value={type.id}> {type.name} </option> ))} </select> </div> <div className="flex items-center gap-2"> <label className="text-sm font-medium text-gray-700">Layout:</label> <select value={layoutMode} onChange={(e) => setLayoutMode(e.target.value as any)} className="bg-white border border-gray-300 rounded px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" > <option value="force">Force-Directed</option> <option value="circular">Circular</option> <option value="hierarchical">Hierarchical</option> </select> </div> <label className="flex items-center gap-2 text-sm"> <input type="checkbox" checked={showLabels} onChange={(e) => setShowLabels(e.target.checked)} className="rounded border-gray-300" /> <span className="text-gray-700">Show Labels</span> </label> </div> </div> {/* Main Content */} <div className="flex"> {/* Canvas */} <div className="flex-1 p-4"> <div ref={containerRef} className="relative border border-gray-200 rounded" > <canvas ref={canvasRef} width={800} height={600} className="cursor-grab active:cursor-grabbing" onMouseDown={handleCanvasMouseDown} onMouseMove={handleCanvasMouseMove} onMouseUp={handleCanvasMouseUp} onMouseLeave={() => setIsDragging(false)} /> </div> </div> {/* Sidebar */} <div className="w-80 border-l border-gray-200"> {/* Legend */} <div className="p-4 border-b border-gray-200"> <h3 className="font-medium text-gray-900 mb-3">Legend</h3> <div className="space-y-2"> {relationshipTypes.slice(1).map((type) => ( <div key={type.id} className="flex items-center gap-2 text-sm"> <div className="w-3 h-3 rounded" style={{ backgroundColor: type.color }} /> <span className="text-gray-700">{type.name}</span> </div> ))} </div> </div> {/* Selected Character Info */} {selectedCharacter && ( <div className="p-4 border-b border-gray-200"> <h3 className="font-medium text-gray-900 mb-3"> {selectedCharacter.name} </h3> <div className="space-y-3 text-sm"> <div> <span className="font-medium text-gray-700">Role:</span> <span className="ml-2 text-gray-600 capitalize"> {selectedCharacter.role} </span> </div> <div> <span className="font-medium text-gray-700"> Relationships: </span> <span className="ml-2 text-gray-600"> {selectedCharacter.relationships?.length || 0} </span> </div> {selectedCharacter.relationships && selectedCharacter.relationships.length > 0 && ( <div> <span className="font-medium text-gray-700 block mb-2"> Connections: </span> <div className="space-y-1 max-h-40 overflow-y-auto"> {selectedCharacter.relationships.map((rel, index) => ( <div key={index} className="flex items-center justify-between p-2 bg-gray-50 rounded text-xs" > <div className="flex items-center gap-2"> <span className="font-medium">{rel.withCharacter}</span> <span className="px-2 py-1 rounded-full" style={{ backgroundColor: relationshipTypes.find((t) => t.id === rel.type)?.color + '20', color: relationshipTypes.find((t) => t.id === rel.type)?.color, }} > {rel.type.replace('_', ' ')} </span> </div> <span className="text-gray-500"> {rel.arcInfluence} </span> </div> ))} </div> </div> )} </div> </div> )} {/* Network Stats */} <div className="p-4"> <h3 className="font-medium text-gray-900 mb-3">Network Stats</h3> <div className="space-y-2 text-sm"> <div className="flex justify-between"> <span className="text-gray-600">Characters:</span> <span className="font-medium text-gray-900">{nodes.length}</span> </div> <div className="flex justify-between"> <span className="text-gray-600">Relationships:</span> <span className="font-medium text-gray-900">{edges.length}</span> </div> <div className="flex justify-between"> <span className="text-gray-600">Avg Connections:</span> <span className="font-medium text-gray-900"> {nodes.length > 0 ? (edges.length / nodes.length).toFixed(1) : 0} </span> </div> <div className="flex justify-between"> <span className="text-gray-600">Most Connected:</span> <span className="font-medium text-gray-900 text-xs"> {nodes.sort((a, b) => b.connections - a.connections)[0]?.name || 'None'} </span> </div> </div> </div> </div> </div> </div> ); } 